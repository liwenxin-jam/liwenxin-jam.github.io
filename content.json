[{"title":"如何阅读一本书 - 莫提默·J.艾德勒","date":"2021-07-04T09:33:48.000Z","path":"2021/07/04/如何阅读一本书/","text":"法国学者帕斯卡尔（Pascal）在三百年前就说过：“读得太快或太慢，都一无所获。”现在既然速读已经形成全国性的狂热，新版的《如何阅读一本书》就针对这个问题，提出不同速度的阅读法才是解决之道。我们的目标是要读得更好，永远更好，不过，有时候要读得慢一点，有时候要读得快一点。既然任何一种阅读都是一种活动，那就必须要有一些主动的活力。完全被动，就阅读不了——我们不可能在双眼停滞、头脑昏睡的状况下阅读。 作者写书的初衷：这是一本为阅读的人，或是想要成为阅读的人而写的书。尤其是想要阅读书的人。说得更具体一点，这本书是为那些想把读书的主要目的当作是增进理解能力的人而写。 阅读的目标：为获得资讯而读，以及为求得理解而读。 四个层次，一共有四种层次的阅读。我们称之为层次，而不称为种类的原因是，严格来说，种类是样样都不相同的，而层次却是再高的层次也包含了较低层次的特性。也就是说，阅读的层次是渐进的。 1. 基础阅读（elementary reading）特点在强调识字 第一层次的阅读所问的问题是：“这个句子在说什么？” 蒙田说：“初学者的无知在于未学，而学者的无知在于学后。” 阅读就是学习：指导型的学习（指导型的学习是“辅助型的自我发现学习”），以及自我发现型的学习之间的差异（或辅助型与非辅助型自我发现学习）。不论是哪一种方式，只有真正学习到的人才是主动的学习者。 “阅读”这两个字已经出现过许多不同的意义。让我们挑出其中三个意义：当我们谈到“阅读”时，可能是指（1）为娱乐而阅读；（2）为获得资讯而阅读；（3）为追求理解力而阅读。 在什么样的状况下，我们会为了增进理解而阅读？有两种状况： 第一是一开始时不相等的理解程度。在对一本书的理解力上，作者一定要比读者来得“高杆”，写书时一定要用可读的形式来传达他有而读者所无的洞见。 其次，阅读的人一定要把不相等的理解力克服到一定程度之内，虽然不能说全盘了解，但总是要达到与作者相当的程度。一旦达到相同的理解程度，就完成了清楚的沟通（达成共识是作者与读者要一起努力的事。因为这是阅读与写作的艺术要追求的终极成就，所以我们可以将达成共识看作是一种使用文字的技巧，以达到沟通知识的目的。）。简单来说，我们只能从比我们“更高杆”的人身上学习。 继续学习与发现，我们就要懂得如何让书本来教导我们。事实上，这就是本书最主要的目的 阅读准备阶段——相当于学前教育或幼稚园的学习经验 认字——相当于一年级学生典型的学习经验 字汇的增长及对课文的运用——通常是，四年级读写能力 小学或初中毕业的读写能力（成熟期） 2. 检视阅读（inspectionalreading）特点在强调时间 在这个层次要问的典型问题就是：“这本书在谈什么？”这是个表象的问题。还有些类似的问题是：“这本书的架构如何？”或是：“这本书包含哪些部分？” 用另一种方式来形容这个层次的阅读，就是在一定的时间之内，抓出一本书的重点——通常是很短，而且总是（就定义上说）过短，很难掌握一本书所有重点。 两个步骤——第一个是浏览（目录、序言），第二个是粗浅地阅读（全文）。浏览能帮助你准备做分析阅读的第一个步骤：你能确定自己在读的是什么主题，能说明这是什么样的书，并拟出大纲架构。粗浅的阅读对分析阅读的第一步骤也有帮助。基本上这是进入第二步骤的准备动作。在第二个步骤中，你要能够与作者达成共识，说明他的主旨，跟随他的论述，才能够诠释整本书的内容。 什么叫对的方向？答案是一个很重要又有帮助的阅读规则，但却经常被忽略。这个规则很简单：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索。 检视阅读是系统化略读（skimming systematically）的一门艺术。 3. 分析阅读 特点在无限时间追寻理解的 分析阅读就是全盘的阅读、完整的阅读，或是说优质的阅读——你能做到的最好的阅读方式。如果说检视阅读是在有限的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。 弗兰西斯·培根曾经说过：“有些书可以浅尝即止，有些书是要生吞活剥，只有少数的书是要咀嚼与消化的。”分析阅读就是要咀嚼与消化一本书。 找出一本书在谈些什么的四个规则： 依照书本的种类与主题作分类。 用最简短的句子说出整本书在谈些什么。 按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。 找出作者在问的问题，或作者想要解决的问题。 “用你自己的话来说”，是测验你懂不懂一个句子的主旨的最佳方法。如果要求你针对作者所写的某个句子作解释，而你只会重复他的话，或在前后顺序上作一些小小的改变，你最好怀疑自己是否真的了解了这句话。理想上，你应该能用完全不同的用语说出同样的意义。当然，这个理想的精确度又可以分成许多程度。但是如果你无法放下作者所使用的字句，那表示他所传给你的，只是这个“字”，而不是他的“思想或知识”。你知道的只是他的用字，而不是他的思想。他想要跟你沟通的是知识，而你获得的只是一些文字而已。 分析阅读的三阶段 分析阅读的第一阶段：找出一本书在谈些什么的规则（1）依照书的种类与主题来分类。（2）使用最简短的文字说明整本书在谈些什么。（3）将主要部分按顺序与关联性列举出来。将全书的大纲列举出来，并将各个部分的大纲也列出来。（4）确定作者想要解决的问题。 分析阅读的第二阶段：诠释一本书的内容规则（5）诠释作者的关键字，与他达成共识。（6）由最重要的句子中，抓住作者的重要主旨。（7）知道作者的论述是什么，从内容中找出相关的句子，再重新架构出来。（8）确定作者已经解决了哪些问题，还有哪些是没解决的。再判断哪些是作者知道他没解决的问题。 分析阅读的第三阶段：像是沟通知识一样地评论一本书的规则 A．智慧礼节的一般规则（9）除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。（在你说出：“我读懂了!”之前，不要说你同意、不同意或暂缓评论。）（10）不要争强好胜，非辩到底不可。（11）在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。 B．批评观点的特别标准（12）证明作者的知识不足。（13）证明作者的知识错误。（14）证明作者不合逻辑。（15）证明作者的分析与理由是不完整的。 4.主题阅读（syntopical reading） 主题阅读的讨论 五个步骤 找到相关的章节。 带引作者与你达成共识。 厘清问题。 界定议题。 分析讨论。 主题阅读的练习实例：进步论 阅读的艺术 俗话说：“你必须读出言外之意，才会有更大的收获。”而所谓阅读的规则，就是用一种比较正式的说法来说明这件事而已。此外，我们也鼓励你“写出言外之意”。不这么做，就难以达到最有效的阅读的境界。阅读的艺术就是要以适当的顺序提出适当的问题。关于一本书，你一定要提出四个主要的问题。 整体来说，这本书到底在谈些什么？你一定要想办法找出这本书的主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来。 作者细部说了什么，怎么说的？你一定要想办法找出主要的想法、声明与论点。这些组合成作者想要传达的特殊讯息。 这本书说得有道理吗？是全部有道理，还是部分有道理？除非你能回答前两个问题，否则你没法回答这个问题。在你判断这本书是否有道理之前，你必须先了解整本书在说些什么才行。然而，等你了解了一本书，如果你又读得很认真的话，你会觉得有责任为这本书做个自己的判断。光是知道作者的想法是不够的。 这本书跟你有什么关系？如果这本书给了你一些资讯，你一定要问问这些资讯有什么意义。为什么这位作者会认为知道这件事很重要？你真的有必要去了解吗？如果这本书不只提供了资讯，还启发了你，就更有必要找出其他相关的、更深的含意或建议，以获得更多的启示。 阅读不同读物的方法 (书中提供讨论不展开，需要的时候再做深入了解) 第三篇是全书增加最多的部分，详加说明了以不同阅读方法接触不同读物之道——如何阅读实用性与理论性作品、想象的文学（抒情诗、史诗、小说、戏剧）、历史、科学与数学、社会科学与哲学，以及参考书、报章杂志，甚至广告。 如何阅读实用型的书 如何阅读想象文学 阅读故事、戏剧与诗的一些建议 如何阅读历史书（如何阅读传记与自传） 如何阅读科学与数学 如何阅读哲学书（如何阅读“经书”） 如何阅读社会科学 建议阅读书目有作者提供的书单，考虑较多，这里不在一一列举","tags":[{"name":"自我成长","slug":"自我成长","permalink":"https://liwenxin-jam.github.io/tags/自我成长/"}]},{"title":"沟通训练营","date":"2021-04-22T12:59:52.000Z","path":"2021/04/22/沟通训练营/","text":"集体学习，沟通训练营，个人整理笔记 1. 结构化倾听：怎样听懂对方的真实意图？ 成功的沟通并不是建立在多说话和说漂亮话的基础上，而是建立在能不能和他人形成信任关系的基础上。如果你在意的是漂亮的话术，那么你恰恰是在关闭沟通。 在无限游戏的视角下，沟通从来都不会失败，我们只是可以努力地去建立一个又一个的新的沟通。 良好的沟通不在于此刻，而在于未来要面对的所有时间。 良好的沟通也不是你和对面这个人之间的事，而是你和整个世界之间的事。 良好的沟通不在于你是否能达成眼前的目的，而在于你能否不断地自我塑造。 书单《有限与无限的游戏》 一千个人眼里有一千个哈姆雷特，游戏可以理解为博弈 场景如婚姻，如果争吵是为了离婚就是有限，如果是为了关系更好延续，获得幸福，就是无限 美团创始人王兴对这本书评价，有限游戏在边界内玩，无限游戏却是和边界玩，探索、改变边界本身。 区别 有限游戏以取胜为目的，三种边界：时空、人员、规则 无限游戏以延续游戏为目的，扩展边界：消除时空、人员边界，不停修改规则 2. 结构化理解：怎么让对方相信我听懂了？ 三步确认法 确认事实 响应情绪 明确行动 有效确认 = 确认事实 + 响应情绪 + 明确行动 情绪化的路标：总、总是、经常、千万别、每次、从不、从来、都是、肯定、必须 反向叙述，就是用自己的话把对方的要求再说一遍，通过反述和追问把信息量套出来。这才叫有效确认了对方的信息，对方才确认你真的听懂了。 小技巧：当对方说完一段话之后，你要像一个拳击裁判一样，内心默默数秒。数三秒，1、2、3再开口。 3. 积极回应：怎样有针对性地做反馈 四步确认法 = 确认需求+肯定需求的合理性+不超过三项的行动计 划+开放性结尾 积极回应艰难沟通和回应 换时间：先不明确回确答复，而是请问我需要在什么时间之前答复您？ 换场合：公开场合换到私密空间再交流请求，对方同意你的申请会大大增加 换角色：从回应者变成主持人的方法，让更多的人，都参与到对话当中来 假话绝不说，真话不全说 回应的第一句，永远是给对方传递一个肯定 您刚刚说的这些太有启发了 你的意见对我一直都很重要 您提的这个问题，对我们的帮助很大 4. 开放性：怎样创造共识？ 开放性 = 扩大共识 + 消除盲区 乔哈里窗，是心理学家乔瑟夫·勒夫和哈里·英汉姆提出的一个模型。它把人们的信息划分为四种类型 我知道、你也知道的信息，这是沟通中的共识区，因为我们的信息完全对称 我不知道、但是你知道的信息，叫做我的盲区 我知道、但你不知道的信息，叫做你的盲区 是特别可怕的一类，咱俩都不知道的信息，这是我们共同的盲区 沟通的意义，就是不断同步我们双方的信息流，让共识区慢慢变大，让盲区越来越小 少说你，多说我、我们，“你”字激发了对方的防御状态，接下来说的任何话，在他心里都是抵触的。而当我们用“我们”开头的时候，就把我和你建立成了一个共同体。我们不是对立关系，不是你的工作没做好，而是我们共同面临一个大挑战，我们怎么样才能解决这个问题 所有的谈话都应该留下开放性的结尾，例如当对方说完话，”是个思路”、”有启发” 5. 目标感：怎样达成目标？ 目标感的本质是方案力，也就是提供解决方案的能力 把“我的目标”翻译成“我们的方案” 句式：我们有一个目标要达成，对比我有一个方案 艰难的沟通，可以把视角拉长到六个月后 6. 建设性：怎样导向行动？ 建议性 = 把沟通导向行动 方法一：来，我们抓抓落实 方法二：请对方给自己提一个需求 绝不使用负面词汇 松浦弥太郎讲过一段话。他说，永远不要抱怨说自己没时间、没钱。因为在有限的时间和金钱内把目标达成，就是你的责任。你的那些负面词汇潜在的意思，就是给自己找一个借口：我不干是有原因的。我可以不行动。这就会给人留下一个非常不好的印象 7. 卡位：怎样破冰？ 职场破冰，本质上不为了是展现自己，而是为了赢得信任 赢得信任，就是让对方觉得对我有掌控感 破冰三步骤 第一步：在对方的世界里，实现精准卡位 第二步：展现你对对方的关切 第三步：把自己的一部分交给对方 双线定位法：自我介绍不能是单维的，必须是一根经线、一根纬线 在对方的世界里定个位 = 我是谁 + 双方的共同关系 展现关切是为了缩短社交距离，但是不能缩短到没有距离 什么叫把我的一部分交给TA？ 最轻：交换电话号码 较重：我为你落实一件事 最重：共享一个小秘密 创业成功最关键的个人要素是什么？ 工程思维 = 科学思维 + 干 + 生天 (火星救援，我一定要用科学在这个星球干出生天)，如埃隆-马斯克、任正非 结构、约束和取舍是工程师思维的三大法宝 科学的核心是发现，工程的配制是实现 8. 追光：怎样赞美一个人？ 用行动而不是用语言，来表达赞美 一个嗯度，从一开始的嗯嗯，慢慢到是啊、对啊、天啊、原来是这样 摸机率 = 单位时间里摸手机的次数 让对方被看见 做笔记 拍照 赞美 = 发现并指出对方的独特行为 从差异中发现内容，就是看TA和别人有什么不一样 是赞美行为，而不是天赋 赞美三大要领（九字箴言）：轻轻地、深深地、常常地 轻轻地：赞美的时候，不要给别人造成负担 深深地：把对方的优点嵌入到我的生命中，不是你真棒，是你的优秀深深地影响了我 常常地：给自己提个要求，任何场景都要给别人一个正反馈 9. 建模：怎样激励一个人？ 激励不是表扬，而是表扬的升级 激励是领导力的核心 激励 = 赞美 + 行为建模 激励和激励也不一样，因为它传递的力量也不一样。通过场合的升级变化，我传递给对方的力量强度是可以不断升级的 10. 击穿：怎样说服一个人？ 说服 = 说话有分量 + 击穿心理阈值 说话有分量：简单来说，就是强准备。即使人微，也不言轻。用超强准备所形成的心理和信息的优势，来碾压对方 击穿心理阈值：说服不是在一瞬间完成的。它是一个沟通流，对方从接收信息到转变观念需要一个过程。 击穿心理阈值的办法有两种： 吹风 慢熬 熬的正确方式是：挖掘，不断调整可变条件，创造一个新局面 可视化：能用场景或图片加强说服力、渲染力，避免文档过于抽象 11. 结界：怎样辅导一个人？ 教行动方法，不教价值观 教价值观念存在两个问题 无法透明，你并不知道对方真实的想法 无法度量，你在这说半天，到底教没教会，你根据不知道 辅导别人，不能停留在理念的沟通上，理念要落地，价值观念也要翻译成行动方法，才有可能辅导成功 辅导 = 植入目标 + 发现盲区 植入目标，就是给对方一个正向的拉力，给他听你说话的动力，这是启动辅导的前提，当我们是共同体的时候，辅导是自然发生的 辅导不是责备，是要以教会他为目标，让他五个月之后变得更好 发现盲区，当你在职场上，看到一个不好的行为的时候，应该先默认为对方是不懂、不会，而不是意愿和态度出了问题 你得先定位原因，才能去辅导他 结界：为沟通创造一个小结界，你不能边干事、边辅导 12. 支持：怎样安慰一个人？ 安慰要的是同理心，而不是同情心 安慰 = 轻度介入 + 提供支持 轻度介入：安慰是一种被动沟通，在职场上，只有当别人需要我们的安慰的时候，我才能提供安慰 提供支持两种方式 情绪支持，转移注意力 提供同类经验 安慰两大原则 轻度介入，当对方需要安慰的时候你才提供安慰 提供社会支持，而不是告诉他应该怎么做 13. 刷新：怎样批评一个人？ 批评不是责备，而是刷新 批评 = 刷新，不是告诉他哪错了，而是告诉他怎么对，不是让他服，而是让他好 五步批评法 控制环境，事情发生之后，第一时间批评，一对一或极小范围内批评 定义问题 我对你的什么行为不满意？ 发生了什么？ 你怎么看这件事儿？ 你都试了什么办法？ 需要我做什么？ 还有吗？ 刷新动作，重要的不是怎么不对，而是怎么才能对 设定反馈点，做对了，正反馈，没做对，做辅导 完成重启，让TA带着目标走，而不是带着批评走 14. 直给：怎样提意见？ 如果你对一个人有管理权，也负有管理责任，你就能批评他 如果你对他没有管理权，也负不了责任，你对他就只能提意见 批评这个工具只适用于一种对象，就是你管辖范围之内的员工 提意见 = 提建议 提意见 = 定义双方关系 + 提供具体建议 第一个要领：提意见之前，一定要先问问对方是否需要 第二个要领：跟对方约一个时间，让他有心理准备 第三个要领：事前打草稿 提意见只有一个目标是100%正确的，就是我要获得对方的信任，我要极大地加强我们双方之间的关系 提意见的沟通的目标 定义双方关系，一定要证明这事和我有关系，我是作为共同体的一分子来发言的，而不是一个评判者 给出具体建议，当一个问题你也不知道咋解决的时候，这个意见我劝你就别提。只要没有带出具体的方案提意见，对方一定会认为你在刷存在感 检验一个建议好不好的标准，是你愿不愿意把自己放进去 不论我提的意见是什么，我的核心目标一定是促进关系 提意见常态化 咱们得有同理心，如果对方给你提了一个意见，他的心理压力是很大的 如果别人给你提了一个意见，一定要给对方反馈 是一个提醒。如果你是接收意见的人，一定要留痕。但反过来，如果你是提意见的人，你可尽量别留痕 15. 透明：怎样作绩效谈话？ 绩效面谈，是你对团队的绩效水平、工作方式进行干预的最重要的时刻 绩效面谈 = 透明化 + 换框架 两个任务： 给下属充分展示透明化的决心和态度 给下属换一个更大的视野框架 展现透明化的绩效面谈技巧 事前沟通：给对方掌控感，让对方有准备度 利用环境沟通：不说话的沟通，学会利用环境 换框架：从日常工作里“拔”出来 知道 为什么而战的士兵是不可战胜的 让对方总结 发个邮件，抄送给人力资源 16. 控场：怎样主持会议？ 会议主持人就是牧羊人 当你是一个会议主持人的时候，你一定要时刻提醒自己，我是一个牧羊人 主持会议 = 设计 + 控场 行为设计四招 场地 时间 环境 规则 三星开会法则 八个必须 凡是会议，必有准备 凡是会议，必有主题 凡是会议，必有纪律 凡是会议，会前必有议程 凡是会议，必有结果 凡是会议，必有训练 凡是会议，必有守时 凡是会议，必有记录 三个公式 光是开会，会后没有人落实等于零 会议上布置了工作，但是会后不进行检查，等于零 抓住了不落实的事，同时追究不落实的人，等于落实 会议控场四招 第一：会前积极跑动 第二：开场自我赋能 第三：会中敢于干预 第四：结束出口成章 会前和领导沟通清单 这个会您希望怎么开？ 有什么需要我注意的？ 您给我的主持提提要求？ 您有什么想强调的？ 您希望会议多长时间内结束？ 您的发言安排在什么时候？ 17. 承诺：怎样进行道歉？ 不是“我错了”，而是“你是对的” 因为道歉的终极奥义，不是跟对方承认 道歉 = 关闭过去 + 开启未来 道歉的完整流程，不要回避道歉，越是艰难的，越要在当下解决 诚恳，道歉的时候，一定要当面谈，实在见不了见的就打电话 完全接纳对方的情绪，肯定对方感受的合理性，在道歉的时候，不能出现否定句 开启未来：接下来我准备怎么办 上个请教，上个小礼物，一定要便宜，它要实现的功能，是不给对方增加负担，但是让对方看到你想要改变的决心 不原谅怎么办？ 我们跟对方道歉，不仅仅是为了他，也是为了这个疤痕不在自己身上留着。所以，不论对方是个什么样的人，道歉该做的事，我都要做全套。这是我对我自己的交代。 大事向领导请求支援，小事打个时间隔断 道歉三大原则 坦然地接受对方的道歉 是你一定要阻止对方把问题升级 是如果涉及到外部关系，那应该秉公处理的，就秉公处理 18. 补网：怎样调解矛盾 调解矛盾不是解扣，而是补网 把自己定位为社会网络的枢纽节点 救火队要先打隔离带，防止蔓延 调解矛盾 = 释放情绪 + 否定情绪 + 重建目标 + 最小改善 让对方重新“入轨” 释放情绪：引导对方彻底倾诉 否定情绪：给对方制造一个认知失调 重建目标：逼问被遮蔽的目标 最小改善：设置一个当下去做的改善行动 19. 示弱：怎样请求帮助？ 求助的内核，是发起协作 钱钟书先生说，男妇之间最好的起点是借书和吃饭，“一借一还，一请一去，情份就结下了” 心理学上有个富兰克林效应，说人总会倾向于帮助自己帮助过的人 求助 = 别人帮得了 +自己值得帮 别人帮得了，在求助之前，你要先营造条件，让对方能帮得了你 我觉得你帮得了，但对方并不觉得 要在时间精力上可启动 在职责边界内可启动 要在关系程度内可启动 自己值得帮 先干为敬，先证明自己在这件事上已经付出了极大的努力 真诚领情，把感谢的场合升级 被拒绝了怎么办？请别人帮忙，不帮是本分，帮了是人情 20. 洗牌：怎样拒绝一个人？ 拒绝要拒绝的事，团结该团结的人，这两条是完全可以和谐统一的 表达拒绝，记住“洗牌”，洗牌不会给双方带来新牌，但是洗牌可以把已有的东西重新排列组合 拒绝= 开门见山 + 移花接木 开门见山 简单来说，就是拒绝一定要直接 表达立场，在你拒绝别人的时候，第一句话就应该先表明立场，直接拒绝 给个理由，你可以给没信息量的理由，“我忙不过来”，“我不想去”，这都不得罪人，但你不要撒谎。最好只用一个理由，来说明你的拒绝 移花接木 重新发牌，给个替代方案 Yes后面带了个条件，如果你怎么样，我才怎么样。这叫不找借口，提条件 如果能……的话，我可以同意，如果对方接受了你的条件，那你就得履行自己的承诺 Yes, if 延迟交付 交换条件 拒绝的时候，可以谈条件，但是不能谈无关条件，更不能谈威胁性的条件 当你去给别人提要求的时候，手里就应该准备个次优方案 21. 备场：怎样即兴发言？ 没有无准备的谈话 半准备发言 参加前的准备 做笔记的准备 争取时间的准备 即兴发言 = 万能开头 + 谈感受(讲虚)/谈行动(讲实，例如今天我特别有收获/启发，我回去要干一件什么事儿) 准备一个万能开头 用自黑的方式做自我介绍 赞美一个细节 即兴发言的三个提醒 你所有的材料一定来自现场 观察一个特殊性 千万不要长篇大论 22. 界面：怎样和人闲谈 打靶式沟通 涟漪式沟通 闲谈 = 传递尊重 + 传递价值 上个请教，你请教的东西，必须要是对方擅长的领域 多给一点，多给一些关键信息 深度破冰 管理人设 不是要贴什么标签，而是想好绝对不贴什么标签 不管你是什么人设，你都不要谈或者少谈三观问题 闲谈是温和且发散的沟通 沟通是双目标系统 以行动为目标 以关系为目标 23. 呈现：怎样作汇报/提案 汇报提案：不是请示，而是预演 提案 = 融目标 + 抢进度 + 提诉求 两个小技巧 大方向和细节沟通要分开 制造听觉锤 抢进度可不是为了增强你的说服力，而是为了增强你的责任担当 把实质性成果的工作往前做 把展现自己决心的工作往前做 你要推销的不是方案，而是你自己 24. MOT：怎样做晋升答辩？ 竞聘不是为了赢 竞聘的本质，不是和对手竞争，而是向组织请战 竞聘 = 请战 注意五个大坑 不要说前任的坏处，要肯定现有战场 不要摆过去的功劳，要讲未来的打算 不要说对未来的畅想，要说对示来的抓手 讲自己的准备，要突出你的特质 不管有没有把握当选，要准备一个败选方案 高手过招，拼到底就是谁的目标更坚定 世界各有计划，但是，我们有自己的计划","tags":[{"name":"杂篇","slug":"杂篇","permalink":"https://liwenxin-jam.github.io/tags/杂篇/"}]},{"title":"typescript学习笔记","date":"2020-03-20T15:09:25.000Z","path":"2020/03/20/typescript学习笔记/","text":"个人typescript学习笔记，加深记忆使用，方便自己查阅。分为基础篇、进阶篇、爬坑篇，客官各取所需 基础篇00. 开发环境搭建 它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程 nodejs环境 nodejs官网 全局安装typescript 1npm install -g typescript 编译ts文件 123tsc test.ts// 开启监测模式tsc test.ts -w 生成tsconfig.json 配置文件 1tsc --init 01. 原始数据类型 原始数据类型包括：布尔值(boolean)、数值(number)、字符串(string)、null、undefined 以及 ES6 中的新类型 Symbol 和 BigInt 非原始类型是指除前面所列的原始类型之外的类型，如数组(array)、元组(tuple)、枚举(enum)、任意类型(any)、空类型(void)、永不存在的值类型(never) 通过 new String() 创建引用类型字符串变量，而 String() 创建值类型字符串变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Uses the JavaScript String objectvar str: String = new String(\"Hello world\"); // Uses the TypeScript string typevar str: string = String(\"Hello World\"); // 不等价，Type 'Boolean' is not assignable to type 'boolean'.let createdByNewBoolean: boolean = new Boolean(1);// Symbols是不可改变且唯一的let sym2 = Symbol(\"key\"); // 可选的字符串keylet sym3 = Symbol(\"key\");console.log(sym2 === sym3); // false, symbols是唯一的// JavaScript 中可以用 Number 表示的最大整数为 2^53 - 1，可以写为 Number.MAX_SAFE_INTEGER。如果超过了这个界限，可以用 BigInt来表示，它可以表示任意大的整数const biggest = Number.MAX_SAFE_INTEGERconst biggest1 = biggest + 1const biggest2 = biggest + 2biggest1 === biggest2 // true 超过精度// 使用BigInt情况下const biggest = BigInt(Number.MAX_SAFE_INTEGER)const biggest1 = biggest + 1nconst biggest2 = biggest + 2nbiggest1 === biggest2 // false// 注意参数的arguments类数组不是真正的数组/* 类数组 VS 数组- 相同点：都可用下标访问每个元素都有length属性- 不同点：数组对象的类型是Array，类数组对象的类型是Object；类数组对象不能直接调用数组API；*/let arr1: string[]// 数组泛型 Array&lt;T&gt;let arr2: Array&lt;string&gt;// tuple(元组)，元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组// Declare a tuple typelet x: [string, number];// Initialize itx = ['hello', 10]; // OK// Initialize it incorrectlyx = [10, 'hello']; // Error// 针对一些常量做命名规范，默认情况下，从0开始为元素编号enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green;// 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null，但如果方法没有返回值，可以声明为voidlet unusable: void = undefined;// 返回never的函数必须存在无法达到的终点，如果真的来到了，证明代码逻辑有问题，跳过了某些判断，来到了它不该到达的地方，例如union type + switch defaultfunction error(message: string): never &#123; throw new Error(message);&#125; 02. TypeScript断言 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。 123456// “尖括号” 语法let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length;// as 语法let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 03. TypeScript类型守卫 类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护。 in 关键字 123456789101112131415161718192021interface Admin &#123; name: string; privileges: string[];&#125;interface Employee &#123; name: string; startDate: Date;&#125;// 联合类型type UnknownEmployee = Employee | Admin;function printEmployeeInformation(emp: UnknownEmployee) &#123; console.log(\"Name: \" + emp.name); // 使用前先判断是否存在，不然编译器会警告过不去校验 if (\"privileges\" in emp) &#123; console.log(\"Privileges: \" + emp.privileges); &#125; if (\"startDate\" in emp) &#123; console.log(\"Start Date: \" + emp.startDate); &#125;&#125; typeof关键字 12345678910function padLeft(value: string, padding: string | number) &#123; // 先判断具体类型是属于哪个联合守卫 if (typeof padding === \"number\") &#123; return Array(padding + 1).join(\" \") + value; &#125; if (typeof padding === \"string\") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; instanceof关键字 12345678910111213141516171819202122232425// 接口interface Padder &#123; // 待implements继承具体实现的方法定义 getPaddingString(): string;&#125;// Number继承类class NumberPadder implements Padder &#123; constructor(private numSpaces: number) &#123;&#125; // 具体实现 getPaddingString() &#123; return Array(this.numSpaces + 1).join(\" \"); &#125;&#125;// String继承类class StringPadder implements Padder &#123; constructor(private value: string) &#123;&#125; getPaddingString() &#123; return this.value; &#125;&#125;// 实例let padder: Padder = new NumberPadder(6);if (padder instanceof NumberPadder) &#123; // padder的类型收窄为 'NumberPadder'&#125; 自定义类型保护的类型谓词，个人感觉有点鸡肋 1234567function isNumber(x: any): x is number &#123; return typeof x === \"number\";&#125;function isString(x: any): x is string &#123; return typeof x === \"string\";&#125; 04. 联合类型和类型别名 联合类型用 | 联接，通常与 null 或 undefined 一起使用 12345678const sayHello = (name: string | undefined) =&gt; &#123; /* ... */&#125;;let value: string | number// 以下两个是等价的let obj: &#123; name: string, age: number &#125;let obj: &#123; name: string &#125; &amp; &#123; age: number &#125; 类型别名用来给一个类型起个新名字 123456789101112131415161718192021222324// 描述一个对象的类型type myType = &#123; name: string, age: number&#125;const obj: myType = &#123; name: 'xx', age: 18&#125;type MyType = stringlet s1: stringlet s2: MyTypetype data = 1 | 2 | 3let data1 = datalet data2 = data// type定义某种类型或者数据type Message = string | string[];let greet = (message: Message) =&gt; &#123; // ...&#125;; 05. TypeScript交叉类型 交叉类型用 &amp; 联接 123456789101112131415161718interface IPerson &#123; id: string; age: number;&#125;interface IWorker &#123; companyId: string;&#125;type IStaff = IPerson &amp; IWorker;// 三个属性缺一不可const staff: IStaff = &#123; id: 'E1006', age: 33, companyId: 'EFT'&#125;;console.dir(staff) 06. TypeScript函数 参数类型和返回类型 123function createUserId(name: string, id: number): string &#123; return name + id;&#125; 可选参数(名称后面加上问号?) 和 默认参数 在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数 在函数参数可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了 12345678910111213141516171819202122232425// 可选参数function createUserId(name: string, id: number, age?: number): string &#123; return name + id;&#125;// 默认参数function createUserId( name: string = \"Semlinker\", id: number, age?: number): string &#123; return name + id;&#125;let obj: &#123; name: string, age?: number &#125;obj = &#123; name: '张三' &#125;obj = &#123; name: '李四', age: 18 &#125;// 动态匹配key-valuelet dynamicObj: &#123; name: string, [propName: string]: any &#125;dynamicObj = &#123; name: '张三' &#125;dynamicObj = &#123; name: '李四', age: 18 &#125;function buildName(firstName: string, lastName?: string) function buildName(firstName: string, lastName: string = 'Cat') 剩余参数，ES6 中，可以使用 …rest 的方式获取函数中的剩余参数（rest 参数），rest 参数只能是最后一个参数 12345678function push(array: any[], ...items) &#123; items.forEach(function (item) &#123; array.push(item); &#125;);&#125;let a = [];push(a, 1, 2, 3); 函数重载 12345678910111213141516171819202122232425262728// 函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。class Calculator &#123; add(a: number, b: number): number; add(a: string, b: string): string; add(a: string, b: number): string; add(a: number, b: string): string; add(a: Combinable, b: Combinable) &#123; if (typeof a === \"string\" || typeof b === \"string\") &#123; return a.toString() + b.toString(); &#125; return a + b; &#125;&#125;const calculator = new Calculator();const result = calculator.add(\"Semlinker\", \" Kakuqo\");// 重载，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string | void &#123; // 根据入参类型返回出参类型 if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return x.split('').reverse().join(''); &#125;&#125; 07. TypeScript数组 数组解构 123let x: number; let y: number; let z: number;let five_array = [0,1,2,3,4];[x,y,z] = five_array; 数组展开运算符 12let two_array = [0, 1];let five_array = [...two_array, 2, 3, 4]; 数组遍历 1234let colors: string[] = [\"red\", \"green\", \"blue\"];for (let i of colors) &#123; console.log(i);&#125; 08. TypeScript对象 对象解构 123456let person = &#123; name: \"Semlinker\", gender: \"Male\",&#125;;let &#123; name, gender &#125; = person; 对象展开运算符 1234567891011let person = &#123; name: \"Semlinker\", gender: \"Male\", address: \"Xiamen\",&#125;;// 组装对象let personWithAge = &#123; ...person, age: 33 &#125;;// 获取除了某些项外的其它项let &#123; name, ...rest &#125; = person; 09. 编译上下文 tsconfig.json，用于标识 TypeScript 项目的根路径，用于配置 TypeScript 编译器，用于指定编译的文件 files - 设置要编译的文件的名称； include - 设置需要进行编译的文件，支持路径模式匹配； exclude - 设置无需进行编译的文件，支持路径模式匹配； compilerOptions - 设置与编译流程相关的选项。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; \"compilerOptions\": &#123; /* 基本选项 */ \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"lib\": [], // 指定要包含在编译中的库文件 \"allowJs\": true, // 允许编译 javascript 文件 \"checkJs\": true, // 报告 javascript 文件中的错误 \"jsx\": \"preserve\", // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react' \"declaration\": true, // 生成相应的 '.d.ts' 文件 \"sourceMap\": true, // 生成相应的 '.map' 文件 \"outFile\": \"./\", // 将输出文件合并为一个文件 \"outDir\": \"./\", // 指定输出目录 \"rootDir\": \"./\", // 用来控制输出目录结构 --outDir. \"removeComments\": true, // 删除编译后的所有的注释 \"noEmit\": true, // 不生成输出文件 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"isolatedModules\": true, // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）. /* 严格的类型检查选项 */ \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"strictNullChecks\": true, // 启用严格的 null 检查 \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict' /* 额外的检查 */ \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误 \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误 \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误 \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) \"baseUrl\": \"./\", // 用于解析非相对模块名称的基目录 \"paths\": &#123;&#125;, // 模块名到基于 baseUrl 的路径映射的列表 \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \"typeRoots\": [], // 包含类型声明的文件列表 \"types\": [], // 需要包含的类型声明文件名列表 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置 \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \"experimentalDecorators\": true, // 启用装饰器 \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持 &#125;&#125; 进阶篇10. TypeScript接口 接口形式，interface接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀 123456789interface Person &#123; name: string; age: number;&#125;let Semlinker: Person = &#123; name: \"Semlinker\", age: 33,&#125;; 可选 ｜ 只读属性 123456interface Person &#123; // 注意，readonly只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候 readonly name: string; age?: number; [propName: string]: any;&#125; 只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray&lt;T&gt; 类型，它与 Array&lt;T&gt; 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改 123456let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! 11. TypeScript类 通过 Class 关键字来定义一个类，定义类需要注意开闭原则(Open Closed Principle)，实体应该对扩展开放，对修改关闭 成员属性与静态属性，成员方法与静态方法有什么区别？ 1234567891011121314151617181920212223242526class Person &#123; // public(公共)、protected(保护)、private(私有)，默认不写是公共属性public // public允许类、子类、类外部访问修改 // protected只允许类、子类访问修改 // private只允许类自身访问修改，能提高代码健壮性，通过暴露方法去实现get和set // public name: string name: string // 构造函数，每个实例单独存在 constructor(name) &#123; this.name = name &#125; // 静态属性，允许类直接访问 static readonly age: number = 18; // 实例属性，不允许类直接访问 desc: string = 'hello world'; sayHi() &#123; console.log('Hi') &#125;&#125;const p1 = new Person('aa')const p2 = new Person('bb')// 错误，不允许直接访问实例属性// console.log(Person.name)p1.desc = 'hello typescript'console.log(p1.desc)console.log(p2.desc) 访问器，我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据 12345678910111213141516171819202122232425// 定义变量let passcode = \"Hello TypeScript\";class Employee &#123; private _fullName: string; // 获取数据 get fullName(): string &#123; return this._fullName; &#125; // 赋值数据 set fullName(newName: string) &#123; // 校验是否合规或是否允许写入 if (passcode &amp;&amp; passcode == \"Hello TypeScript\") &#123; this._fullName = newName; &#125; else &#123; console.log(\"Error: Unauthorized update of employee!\"); &#125; &#125;&#125;let employee = new Employee();employee.fullName = \"Semlinker\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 类的继承，extends、super 123456789101112131415161718192021222324252627// 父类class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;// 子类class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\"); super.move(distanceInMeters); &#125;&#125;let sam = new Snake(\"Sammy the Python\");sam.move(); 抽象类abstract 1234567891011121314151617181920212223/** * 抽象类和其它类区别不大，只是不能创建实例，专门用来被继承 * 抽象类可以添加抽象方法*/abstract class Animal &#123; name: string constructor(name) &#123; this.name = name &#125; // 抽象方法只能定义在抽象类中，没有方法体，必须在派生类具体实现 abstract sayHello(): void&#125;// 错误，抽象类无法被实例化// const animal = new Animalclass Dog extends Animal &#123; constructor(name) &#123; super(name) &#125; // 子类必须对抽象方法进行重写 sayHello() &#123; &#125;&#125; 继承extends类 实现一个新的类，从父类或者接口实现所有的属性和方法，同时可以重写属性和方法，包含一些新的功能，注意super的用法 一个类不能extends多个类，但是可以通过接口然后让一个类去implements多个接口，class A extends B implements C,D,E extends可以继承父类的方法，也可以重写他，但是要注意的是，如果父类是抽象类，内部有抽象的方法，子类在extends的时候，如果子类不是抽象类，那么子类就一定要对父类中的抽象方法进行重写。但如果子类也是抽象类，则可以不可考虑重写。extends支持子类，孙类……即可以继承多代 123456789101112131415161718// 父类animalclass Animal &#123; constructor(name) &#123; this.name = name &#125;&#125;// 子类dogclass Dog extends Animal &#123; constructor(name) &#123; super(name) &#125;&#125;// 子类catclass Cat extends Animal &#123; constructor(name) &#123; super(name) &#125;&#125; 继承implements接口 class A implements B，B是interface类型的，B里面的方法默认可以理解为都是abstract类型的方法，implements接口的子类必须实现接口定义的方法 123456789101112131415161718192021/** * 接口只定义对象的结构，所有属性都不能有实际的值 * 所有方法都是抽象方法*/interface myInter &#123; name: string sayHello(): void&#125;// 实现接口就是让类满足接口的要求class MyClass implements myInter &#123; name: string constructor(name: string) &#123; this.name = name &#125; sayHello() &#123; console.log('Hello') &#125;&#125; 12. TypeScript泛型 泛型是指不确定的类型，泛型变量，使用大写字母 A-Z 定义的类型变量都属于泛型。泛型可以帮助我们避免重复的代码以及对不特定类型的支持(类型校验) T（Type）：表示一个 TypeScript 类型 K（Key）：表示对象中的键类型 V（Value）：表示对象中的值类型 E（Element）：表示元素类型 泛型接口 1234interface GenericIdentityFn&lt;T&gt; &#123; // &lt;T&gt;(arg: T): T; (arg: T): T;&#125; 泛型类 12345678910111213141516171819202122232425262728293031323334353637383940414243// 定义不确定类型的泛型类class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;// T在定义的时候是不确定的，只有在实例化类的时候才能确定它最终是类型的数据let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) &#123; return x + y;&#125;;// 等价下边泛型方法，但定义any会丢失掉typescript的类型校验function fn(params: any): any &#123; return params&#125;// T是任意类型，只有调用执行的时候才知道，自动对类型进行推断function fn&lt;T&gt;(params: T): T &#123; return params&#125;function fn2&lt;T, K&gt;(a: T, b: K): T &#123; console.log(b) return a&#125;// 泛型支持继承interface Inter &#123; length: number&#125;// function fn3&lt;T extends String&gt;(a: T): number &#123; return a.length&#125;fn3('123')// 泛型类class MyClass&lt;T&gt; &#123; name: T constructor(name: T) &#123; this.name = name &#125;&#125;const mc = new MyClass&lt;string&gt;('abc') 泛型工具类型 typeof ，可以用来获取一个变量声明或对象的类型 1234567891011121314interface Person &#123; name: string; age: number;&#125;const sem: Person = &#123; name: 'semlinker', age: 30 &#125;;type Sem = typeof sem; // -&gt; Personfunction toArray(x: number): Array&lt;number&gt; &#123; return [x];&#125;// js typeof 用来检测一个变量的类型，会返回 undefined、boolean、string、number、object(null)、functiontype Func = typeof toArray; // -&gt; (x: number) =&gt; number[] keyof，可以用来获取一个对象中的所有 key 值 1234567891011interface Person &#123; name: string; age: number;&#125;type K1 = keyof Person; // \"name\" | \"age\"type K2 = keyof Person[]; // \"length\" | \"toString\" | \"pop\" | \"push\" | \"concat\" | \"join\" type K3 = keyof &#123; [x: string]: Person &#125;; // string | number// 只允许赋值类型声明的keyconst key: K1 = 'name';console.log(key) // name in，遍历枚举类型 12345type Keys = \"a\" | \"b\" | \"c\"type Obj = &#123; [p in Keys]: any&#125; // -&gt; &#123; a: any, b: any, c: any &#125; infer，声明一个类型变量并且对它进行使用 123type ReturnType&lt;T&gt; = T extends ( ...args: any[]) =&gt; infer R ? R : any; extends 123456789101112interface ILengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends ILengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;// 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型loggingIdentity(3); // Error, number doesn't have a .length property// 这时我们需要传入符合约束类型的值，必须包含必须的属性loggingIdentity(&#123; length: 10, value: 3 &#125;); Partial，Partial 的作用就是将某个类型里的属性全部变为可选项 ? 12345678// 首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值。中间的 ? 号，用于将所有属性变为可选/** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;; 13. TypeScript装饰器 装饰器是什么 它是一个表达式(方法)，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能 该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象 普通装饰器(无法传参)、装饰器工厂(可传参) 装饰器的分类 类装饰器（Class decorators），应用于类构造函数，可以用来监视、修改或替换类定义，传入一个参数 属性装饰器（Property decorators） 方法装饰器（Method decorators） 参数装饰器（Parameter decorators） 执行顺序：属性装饰器(从后到前) -&gt; 方法装饰器(从后到前) -&gt; 方法参数装饰器(从右到左) -&gt; 类装饰器(从后到前) 类装饰器 target: TFunction - 被装饰的类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 不传参的情况下function (target) &#123; // 当前装饰的类 console.log(target); // 动态扩展一个greet方法 target.prototype.greet = function (): void &#123; console.log(\"Hello TS!\"); &#125;;&#125;// 传参的情况下function Greeter(greeting: string) &#123; return function (target) &#123; target.prototype.greet = function (): void &#123; console.log(greeting); &#125;; &#125;;&#125;// 不传参的情况下，普通装饰器// @Greeter// 带参数的情况下，装饰器工厂@Greeter(\"Hello TS!\") // 多个装饰器，写在前面的后执行class Greeting &#123; constructor() &#123; // 内部实现 &#125;&#125;let myGreeting = new Greeting();myGreeting.greet(); // console output: 'Hello TS!';// 类重载，类的构造函数作为其唯一的参数，它会使用提供的构造函数来替换类的声明function logClass(target) &#123; console.log(target); return class extends target &#123; apiUrl: string = '我是修改后的数据' // 方法也可以重载 getData() &#123; this.apiUrl += '---'; console.log(this.apiUrl); &#125; &#125;&#125;@logClassclass HttpClient &#123; public apiUrl: string | undefined constructor() &#123; this.apiUrl = '我是构造函数里面的apiUrl' &#125; getData() &#123; console.log(this.apiUrl); &#125;&#125;let http = new HttpClient();http.getData(); 属性装饰器，可以用来监视、修改或替换类定义，两个参数 target: Object - 被装饰的类，对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 propertyKey: string | symbol - 被装饰类的属性名，成员的名字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 属性装饰器function logProperty(params: any) &#123; return function(target: any, attr:any) &#123; console.log(target); console.log(attr); // url // 等价于在target.prototype target[attr] = params; &#125;&#125;class HttpClient &#123; @logProperty('http://baidu.com') public url: string | undefined; constructor() &#123;&#125; getData() &#123; console.log(this.url); &#125;&#125;let http = new HttpClient();http.getData();// 属性装饰器function logProperty(target: any, key: string) &#123; delete target[key]; const backingField = \"_\" + key; Object.defineProperty(target, backingField, &#123; writable: true, // 可覆写 enumerable: true, // 可枚举 configurable: true &#125;); // property getter const getter = function (this: any) &#123; const currVal = this[backingField]; console.log(`Get: $&#123;key&#125; =&gt; $&#123;currVal&#125;`); return currVal; &#125;; // property setter const setter = function (this: any, newVal: any) &#123; console.log(`Set: $&#123;key&#125; =&gt; $&#123;newVal&#125;`); this[backingField] = newVal; &#125;; // Create new property with getter and setter Object.defineProperty(target, key, &#123; get: getter, set: setter, enumerable: true, configurable: true &#125;);&#125;class Person &#123; @logProperty public name: string; constructor(name : string) &#123; this.name = name; &#125;&#125;const p1 = new Person(\"semlinker\");p1.name = \"kakuqo\"; 方法装饰器，可以用来监视、修改或替换类定义，三个参数 target: Object - 被装饰的类，对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 propertyKey: string | symbol - 成员的名称(方法名) descriptor: TypePropertyDescript - 成员的属性描述符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function logMethod(params: any) &#123; return function(target:any, methodName: string, descript: string) &#123; console.log(target); console.log(methodName); console.log(descript); target.apiUrl = 'xxx'; target.run = function() &#123; console.log('run'); &#125; &#125;&#125;class HttpClient &#123; public url: string | undefined; constructor () &#123;&#125; @logMethod('www.baidu.com') getData() &#123; console.log(this.url); &#125;&#125;let http = new HttpClient();console.log(this.apiUrl);http.run();function LogOutput(tarage: Function, key: string, descriptor: any) &#123; // 原先的方法，保留指向 let originalMethod = descriptor.value; let newMethod = function(...args: any[]): any &#123; // 将参数全部转成字符串类型，或者将一些数据转成特定类型再计算 // args = args.map(value =&gt; &#123; // return String(value); // &#125;) // 计算结果 let result: any = originalMethod.apply(this, args); if(!this.loggedOutput) &#123; this.loggedOutput = new Array&lt;any&gt;(); &#125; this.loggedOutput.push(&#123; method: key, parameters: args, output: result, timestamp: new Date() &#125;); return result; &#125;; // 将新方法重定向 descriptor.value = newMethod;&#125;class Calculator &#123; @LogOutput double (num: number): number &#123; return num * 2; &#125;&#125;let calc = new Calculator();calc.double(11);// console ouput: [&#123;method: \"double\", output: 22, ...&#125;]console.log(calc.loggedOutput); 方法参数装饰器，可以使用参数装饰器为类的原型增加一些元素数据，三个参数 target: Object - 被装饰的方法，对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 propertyKey: string | symbol - 参数的名称 parameterIndex: number - 方法中参数的索引值 1234567891011121314151617181920212223242526272829303132333435function logParams(params: any) &#123; return function(target: any, paramName: string, paramIndex: number) &#123; console.log(params); // xxxx console.log(target); // &#123;getData: f, constructor: f&#125; console.log(paramName); // getData console.log(paramIndex); // 0 &#125;&#125;class HttpClient &#123; public url: string | undefined; constructor () &#123;&#125; @logMethod('www.baidu.com') // 多个装饰器，写在前面的后执行 getData(@logParams('xxxx') uuid: any) &#123; console.log(this.uuid); &#125;&#125;let http = new HttpClient();http.getData();function Log(target: Function, key: string, parameterIndex: number) &#123; let functionLogged = key || target.prototype.constructor.name; console.log(`The parameter in position $&#123;parameterIndex&#125; at $&#123;functionLogged&#125; has been decorated`);&#125;class Greeter &#123; greeting: string; constructor(@Log phrase: string) &#123; this.greeting = phrase; &#125;&#125;// console output: The parameter in position 0 // at Greeter has been decorated 爬坑篇小技巧 判断对象是否存在某个属性 123obj.propNameobj.hasOwnProperty(propName)obj?.propName 判断某个元素是否存在 123(arr ?? []).forEach(item =&gt; &#123; console.log(item)&#125;) ！作用 12// 后面加!代表这个元素不可能为空，跳过校验document.getElementById('id').text!.getElementsByTagName('div'); $refs问题 1234public $refs!: &#123; tableW: HTMLElement&#125;;this.myTable = this.$refs.tableW; any 和 unknown 区别 在任意值上访问任何属性都是允许的 允许调用任何方法 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型（类型推论） 相同点：都为顶级类型 不同点： 任何类型的值都可以赋值给 any 类型，类型 any 也可被可赋值给每一种类型（使用 any，我们将会失去通常由 TypeScript 的静态类型系统所给予的所有保护。因此，如果我们无法使用更具体的类型或 unknown，则只能将其用作最后的手段） unknown 类型是 any 的类型安全版本。每当你想使用 any 时，应该先试着用 unknown，在对 unknown 类型的值执行任何操作之前，必须先通过以下方法限定其类型 类型断言 12345678910111213141516171819202122value.toFixed(2)(value as number).toFixed(2)// 类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误interface Cat &#123; name: string; run(): void;&#125;interface Fish &#123; name: string; swim(): void;&#125;function swim(animal: Cat | Fish) &#123; (animal as Fish).swim();&#125;const tom: Cat = &#123; name: 'Tom', run() &#123; console.log('run') &#125;&#125;;swim(tom); 相等 12345value * 5;// equalityif (value === 123) &#123; value * 5;&#125; 类型防护/类型收缩 1typeof value === 'string' 断言函数 1reg instanceof RegExp type 和 interface 区别 相同点：都可以描述一个对象或者函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// interfaceinterface User &#123; name: string age: number&#125;interface SetUser &#123; (name: string, age: number): void;&#125;// typetype User = &#123; name: string age: number&#125;;type SetUser = (name: string, age: number): void;/** interface可以extends，但type是不允许extends和implement的，但是type缺可以通过交叉类型实现interface的 extend行为，并且两者并不是相互独立的，也就是说interface 可以extends type, type也可以与interface类型交叉，虽然效果差不多，但是两者语法不同*/// interface extends interfaceinterface Name &#123; name: string;&#125;interface User extends Name &#123; age: number;&#125;// type 与 type 交叉type Name = &#123; name: string;&#125;type User = Name &amp; &#123; age: number &#125;;// interface extends typetype Name = &#123; name: string;&#125;interface User extends Name &#123; age: number;&#125;// type 与 interface 交叉interface Name &#123; name: string;&#125;type User = Name &amp; &#123; age: number;&#125; 不同点： type 可以声明基本类型别名，联合类型（使用 | 分隔每个类型），元组等类型，还可以使用 typeof 获取实例的类型进行赋值，但不允许重复声明相同名称 123456789101112131415161718192021222324252627// 基本类型别名type Name = string// 联合类型interface Dog &#123; wong();&#125;interface Cat &#123; miao();&#125;type Pet = Dog | Cat// 具体定义数组每个位置的类型type PetList = [Dog, Pet]// 当你想获取一个变量的类型时，使用 typeoflet div = document.createElement('div');type B = typeof div// 其他骚操作type StringOrNumber = string | number; type Text = string | &#123; text: string &#125;; type NameLookup = Dictionary&lt;string, Person&gt;; type Callback&lt;T&gt; = (data: T) =&gt; void; type Pair&lt;T&gt; = [T, T]; type Coordinates = Pair&lt;number&gt;; type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;; interface 允许重复声明(合并) 12345678910111213141516interface User &#123; name: string age: number&#125;interface User &#123; sex: string&#125;/*User 接口为 &#123; name: string age: number sex: string&#125;*/ 建议 如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"阐述__proto__和prototype的关系","date":"2020-03-12T14:21:15.000Z","path":"2020/03/12/阐述__proto__和prototype的关系/","text":"原型是 javascript 面向对象编程中非常重要的概念，而且并不是那么容易懂。偶然看到一个题目：阐述 proto 和 prototype 的关系。看到这个问题的时候，我的脑海浮现出一些概念，但却说不出来 构造函数 使用构造函数创建对象，Person 就是一个构造函数，通过 new 创建了 person1 对象实例，其实构造函数就和普通函数没有多大区别，首字母大写只是约定俗成，不大写照样可以 1234function Person() &#123;&#125;var person = new Person()person.name = 'xx'console.log(person.name) prototype Person 构造函数下有一个 prototype 属性，这个并不是构造函数专有，每个函数都会有一个 prototype 属性，这个属性是一个指针，指向一个对象，记住只有函数才有，并且通过 bind()绑定的也没有 12345678910111213function Person() &#123;&#125;// 原型对象的好处是可以让所有对象实例共享它所包含的属性和方法Person.prototype.name = 'xx'var person1 = new Person()var person2 = new Person()console.log(person1.name)console.log(person2.name)var obj = &#123; name: 'xx' &#125;console.log(obj.prototype) // undefinedvar a = Object.prototype.toString.bind(Array)console.log(a.prototype) // undefined proto 在 person1 和 person2 实例对象下面有一个[[prototype]],其实没有标准的方式可以访问它，但是主流浏览器上在每个对象上(null 除外)都支持一个属性,那就是 proto，这个属性会指向该对象的原型 123function Person() &#123;&#125;var person1 = new Person()person1.__proto__ === Person.prototype // true constructor 原型对象(Person.prototype)下 constructor 属性将原型对象指向关联的构造函数 1234function Person() &#123;&#125;Person.prototype.constructor === Person // truevar person1 = new Person()person1.constructor === Person // true hasOwnProperty 如何检测一个属性存在于实例中，还是原型中?使用方法 hasOwnProperty，属性只有存在于实例中才会返回 true 1234function Person() &#123;&#125;var person1 = new Person()// 实例属性person1.hasOwnProperty('name') in in 则会遍历所有属性，不管是实例上的，还是原型上的，in 操作符有两种使用方式，单独使用和在 for-in 循环中使用 12345678910111213function Person() &#123;&#125;Person.prototype.age = '20'var person1 = new Person()person1.name = 'xx''age' in person1 // true'name' in person1 // true// Object.keys() 此方法可以获取对象的所有可枚举的属性的名字var keys = Object.keys(person1)console.log(keys) // [\"name\"]var keys = Object.keys(Person.prototype)console.log(keys) // [\"age\"] Object.prototype 有原型吗 所有的原型最终都会指向 Object.prototype，所以对象的很多方法其实都是继承于此，比如 toString()、valueOf()，前面用到的 hasOwnProperty，甚至是 constructor、proto 1console.log(Object.prototype.__proto__ ) // null 镇楼图 参考文献1、一篇文章看懂proto和prototype的关系及区别","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"求无序数组第几大的数字","date":"2020-03-03T15:12:51.000Z","path":"2020/03/03/求无序数组第几大的数字/","text":"编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第 2 大的数字为 4，第 5 大的数字为 1？ 求无序数组第几大的数字1234567891011121314151617function getMaxNumBySortArr(k, arr) &#123; // 排序 + 反转，实际为降序排序 const descArr = arr.sort((a, b) =&gt; b - a) // 去重 const removeDuplicateArr = new Set(descArr) // 将类数组转回数组 const result = Array.from(removeDuplicateArr) // 是否存在的最大数 const maxNum = result[k - 1] if (typeof maxNum !== 'undefined') &#123; console.log(maxNum) &#125; else &#123; throw new Error('找不到匹配的第几大数') &#125;&#125;// 校验getMaxNumBySortArr(1, [3, 1, 3, 2, 5, 4, 5])","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"call、apply、bind探索之路","date":"2020-02-13T14:23:00.000Z","path":"2020/02/13/call、apply、bind探索之路/","text":"call/apply 改变了函数的 this 上下文后马上执行该函数，返回 fun 的执行结果。bind 则是返回改变了上下文后的函数，不执行该函数，返回 fun 的拷贝，并指定了 fun 的 this 指向，保存了 fun 的参数。 语法糖格式 apply 是以 a 开头，它传给 fun 的参数是 Array，也是以 a 开头的。 123fun.call(thisArg, param1, param2, ...)fun.apply(thisArg, [param1,param2,...])fun.bind(thisArg, param1, param2, ...) 回调函数 this 丢失问题123456789101112131415161718192021222324class Page &#123; constructor(callBack) &#123; this.className = 'Page' // callBack() // 直接执行的话 由于class 内部是严格模式，所以this 实际指向的是 undefined this.MessageCallBack = callBack // this.MessageCallBack('发给注册页面的信息') // 执行PageA的回调函数 &#125;&#125;class PageA &#123; constructor() &#123; this.className = 'PageA' // 回调函数this丢失问题，绑定回调函数的this指向为PageA // PS： 这也是为什么react的render函数在绑定回调函数的时候，也要使用bind绑定一下this的指向，也是因为同样的问题以及原理。 this.pageClass = new Page(this.handleMessage.bind(this)) // 注册页面 传递回调函数 问题在这里 &#125; // 与页面通信回调 handleMessage(msg) &#123; console.log('处理通信', this.className, msg) // 'Page' this指向错误 &#125;&#125;new PageA() 经典作用域问题1234567891011121314151617181920for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function test() &#123; console.log(i) // 依次输出：6 6 6 6 6 &#125;, i * 1000);&#125;for (var i = 1; i &lt;= 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log('闭包:', i); // 依次输出：1 2 3 4 5 &#125;, i * 1000); &#125;(i));&#125;for (var i = 1; i &lt;= 5; i++) &#123; // 缓存参数 setTimeout(function(i) &#123; console.log('bind', i) // 依次输出：1 2 3 4 5 &#125;.bind(null, i), i * 1000);&#125; 你能手写实现一个 call 吗？ 1、根据 call 的规则设置上下文对象,也就是 this 的指向。 2、通过设置 context 的属性,将函数的 this 指向隐式绑定到 context 上 3、通过隐式绑定执行函数并传递参数。 4、删除临时属性，返回函数执行结果 123456789101112131415161718Function.prototype.myCall = function(context, ...arr) &#123; if ([null, undefined].includes(context)) &#123; // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window) context = window &#125; else &#123; context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象 &#125; const specialPrototype = Symbol('特殊属性Symbol') // 用于临时储存函数 context[specialPrototype] = this; // 函数的this指向隐式绑定到context上 let result = context[specialPrototype](...arr); // 通过隐式绑定执行函数并传递参数 delete context[specialPrototype]; // 删除上下文对象的属性 return result; // 返回函数执行结果&#125;const arr = [15, 6, 12, 13, 16];const max1 = Math.max.call(Math, ...arr); // 16const max2 = Math.max.myCall(Math, ...arr); // 16console.log(max1, max2) 你能手写实现一个 call 吗？1、根据 call 的规则设置上下文对象,也就是 this 的指向。2、通过设置 context 的属性,将函数的 this 指向隐式绑定到 context 上3、通过隐式绑定执行函数并传递参数。4、删除临时属性，返回函数执行结果 123456789101112131415161718Function.prototype.myCall = function(context, ...arr) &#123; if ([null, undefined].includes(context)) &#123; // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window) context = window &#125; else &#123; context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象 &#125; const specialPrototype = Symbol('特殊属性Symbol') // 用于临时储存函数 context[specialPrototype] = this; // 函数的this指向隐式绑定到context上 let result = context[specialPrototype](...arr); // 通过隐式绑定执行函数并传递参数 delete context[specialPrototype]; // 删除上下文对象的属性 return result; // 返回函数执行结果&#125;const arr = [15, 6, 12, 13, 16];const max1 = Math.max.call(Math, ...arr); // 16const max2 = Math.max.myCall(Math, ...arr); // 16console.log(max1, max2) 你能手写实现一个 apply 吗？ 1、传递给函数的参数处理，不太一样，其他部分跟 call 一样。 2、apply 接受第二个参数为类数组对象, 这里用了 JavaScript 权威指南中判断是否为类数组对象的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041Function.prototype.myApply = function(context) &#123; if (context === null || context === undefined) &#123; context = window // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window) &#125; else &#123; context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象 &#125; // JavaScript权威指南判断是否为类数组对象 function isArrayLike(o) &#123; if (o &amp;&amp; // o不是null、undefined等 typeof o === 'object' &amp;&amp; // o是对象 isFinite(o.length) &amp;&amp; // o.length是有限数值 o.length &gt;= 0 &amp;&amp; // o.length为非负值 o.length === Math.floor(o.length) &amp;&amp; // o.length是整数 o.length &lt; 4294967296) // o.length &lt; 2^32 return true else return false &#125; const specialPrototype = Symbol('特殊属性Symbol') // 用于临时储存函数 context[specialPrototype] = this; // 隐式绑定this指向到context上 let args = arguments[1]; // 获取参数数组 let result // 处理传进来的第二个参数 if (args) &#123; // 是否传递第二个参数 if (!Array.isArray(args) &amp;&amp; !isArrayLike(args)) &#123; throw new TypeError('myApply 第二个参数不为数组并且不为类数组对象抛出错误'); &#125; else &#123; args = Array.from(args) // 预防是类数组而不是真正的数组，需要转为数组 result = context[specialPrototype](...args); // 执行函数并展开数组，传递函数参数 &#125; &#125; else &#123; result = context[specialPrototype](); // 执行函数 &#125; delete context[specialPrototype]; // 删除上下文对象的属性 return result; // 返回函数执行结果&#125;const arr = [15, 6, 12, 13, 16];const max1 = Math.max.apply(Math, arr); // 16const max2 = Math.max.myApply(Math, arr); // 16console.log(max1, max2) 你能手写实现一个 bind 吗？ 1.拷贝源函数:通过变量储存源函数使用 Object.create 复制源函数的 prototype 给 fToBind 2.返回拷贝的函数 3.调用拷贝的函数：new 调用判断：通过 instanceof 判断函数是否通过 new 调用，来决定绑定的 context绑定 this+传递参数返回源函数的执行结果 12345678910111213141516171819202122Function.prototype.myBind = function(objThis, ...params) &#123; const thisFn = this; // 存储源函数以及上方的params(函数参数) // 对返回的函数 secondParams 二次传参 let fToBind = function(...secondParams) &#123; console.log('secondParams', secondParams, ...secondParams) const isNew = this instanceof fToBind // this是否是fToBind的实例 也就是返回的fToBind是否通过new调用 const context = isNew ? this : Object(objThis) // new调用就绑定到this上,否则就绑定到传入的objThis上 return thisFn.call(context, ...params, ...secondParams); // 用call调用源函数绑定this的指向并传递参数,返回执行结果 &#125;; fToBind.prototype = Object.create(thisFn.prototype); // 复制源函数的prototype给fToBind return fToBind; // 返回拷贝的函数&#125;function handleMessage(message) &#123; console.log(message)&#125;const bind1 = handleMessage.bind(null, 'hello wrold!'); // 16const bind2 = handleMessage.myBind(null, 'hello jam!'); // 16console.log(bind1, bind2)console.log(bind1(), bind2())const bind3 = new bind2('hello xx')console.log(bind3) 参考文献1、面试官想知道你有多理解 call,apply,bind？","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"vue2.0学习心得","date":"2020-01-25T12:12:24.000Z","path":"2020/01/25/vue学习心得/","text":"vue 是一个 mvvm 框架(库)，它和 angular 类似，但相对比较容易上手、小巧。具体详情可以查阅vue 官网 1、初始化 vue ui (可视化) vue create ‘projectName’ (方向键上下切换，空格选择，回车确定) 2、生命周期 生命周期-初始化阶段Vue 实例的生命周期，可以分为 4 个阶段：初始化阶段、模板编译阶段、挂载阶段、卸载阶段new Vue()到 created 之间的阶段叫作初始化阶段（beforeCreate、created）主要目的实例化一些属性、事件及响应式数据，如 props、methods、data、computed、watch、provide 和 inject 等 生命周期-模板编译阶段在 created 钩子函数与 beforeMount 钩子函数之间的阶段是模板编译阶段。主要目的是将模板编译为渲函数 ，只存在于完整版中。根据是否需要编译器分为: 运行时版本和完整版（template 模板、render 函数） 生命周期-挂载阶段beforeMount 钩子函数到 mounted 钩子函数 之间是持载阶段通俗地讲，就是将模板渲染到指定的 Dom 元素中。在挂载的过程中，vue 会开启 watcher 来持续 追踪依赖的变化当数据（状态）发生变化时，watcher 会通知虚拟 Dom 重新渲染视图，在渲染视图前触发 beforeUpdate 钩子函数，渲染完毕后触发 updated 钩子函数 ，这就是常说的响应式已挂载阶段（beforeUpdate、updated） 生命周期-卸载阶段卸载阶段（beforeDestroy、destroyed）会将自身从父组件中删除，取消实例上所有依赖的追踪并且移除所有的事件监听器 生命周期-activated 和 deactivated将需要缓存的组件缓存在内存当中，下次再次访问的时候，直接从缓存中读取，而不是重新创建或者销毁。在 keep-alive 下有效activate：是在被包裹组建被激活的状态下使用的生命周期钩子deactivated：在被包裹组件停止使用时调用 生命周期-errorCapturederrorCaptured 钩子函数的作用是捕获来自子孙组件的错误，有三个参数（错误对象、发生错误的组件实例、包含错误来源信息的字符串），可以返回 false，阻止该错误继续向上传播。类似 try catch 可以不停向上抛相关代码源码路径：vue/src/core/util/error.js源码调试，在想断点调试打上 debugger，重启本地服务 3、双向绑定 Input 为受控组件，它总会显示 Vue 绑定值。通常情况下，应当处理 input 事件，并更新组件的绑定值（或使用 v-model）。否则，输入框内显示的值将不会改变。 4、组件和组件通信 1.props / $emit 适用于父子组件通信这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。 2.ref 与 $parent / $children适用于父子组件通信ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例$parent / $children：访问父 / 子实例 3.EventBus （$emit / $on）适用于父子、隔代、兄弟组件通信这种方法通过一个空的 Vue 实例/作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。 4.$attrs/$listeners 适用于隔代组件通信$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=“$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=“$listeners” 传入内部组件 5.provide / inject 适用于隔代组件通信祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 6.Vuex 适用于父子、隔代、兄弟组件通信 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化 5、v-show 和 v-if 的区别是什么？v-show 只是在 display: none 和 display: block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。 v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件， 并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。 6、keep-alive 组件有什么作用？如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。 对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 7、computed 和 watch 区别?computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作 8、最佳实践 &amp; 踩坑记录1、Vue 不能检测实时检测变动的复杂类型，例如对象和数组解决方案：this.$set(obj, key, val) 、this.$set(arr, index, val)2、event bus 多次触发解决方案：$on 的事件可在 created 或 mounted 注册，但需在 beforeDestroy 或 destoryed 的时候使用用 $off 销毁否则在某些情况下会被被多次触发3、变量命名解决方案：变量名不要以、$开头，因为名字以 \\ 或 $ 开始的属性不会被 Vue 实例代理，因为它们可能与 Vue 的内置属性与 API 方法冲突。vue 内部需要用 vm.$data._property 访问它们。","tags":[{"name":"框架","slug":"框架","permalink":"https://liwenxin-jam.github.io/tags/框架/"}]},{"title":"js基础和设计模式","date":"2019-12-04T12:46:06.000Z","path":"2019/12/04/js基础和设计模式/","text":"其实我个人在项目用过的模式也不多，对模式的概念的理解也没有那么抽象，所以最近在面试中如果面试官问到与模式相关的问题，自己感觉在对答过程中很郁闷，很多东西表达不清楚，于是就找了些相关资料，才会有这篇文章分享。JavaScript模式与前端的工作和成长密不可分，因为这确实不是一个简单的话题，所以我只能尽力用简单表达和例子阐明。 1、基础概念 in 判断一个对象, 是否拥有某个属性(如果对象身上没有, 会到原型对象里面查找) 1234567891011function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.address = '上海';var p = new Person('jam', 18);// 一定要注意, 不能直接写名称, 不然会被当做变量名处理, 要以字符串的形式来写// console.log(name in p); // 为啥是false?console.log('name' in p);console.log('address' in p); hasOwnProperty: 只到对象自身查找 123456789function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.address = '上海';var p = new Person('sz', 18);console.log(p.hasOwnProperty('name'));console.log(p.hasOwnProperty('address')); isPrototypeOf: 判断一个对象, 是否是某个实例的原型对象 1234567891011121314151617181920function Person() &#123;&#125;var p = new Person();console.log(Person.prototype.isPrototypeOf(p)); // true/*var obj = &#123; name: 'xx'&#125;;Person.prototype = obj;console.log(Person.prototype.isPrototypeOf(p)); // false*/var obj = &#123; name: 'xx'&#125;;Person.prototype = obj;var p2 = new Person();console.log(Person.prototype.isPrototypeOf(p2)); // true instanceOf : 判断一个对象, 是否是某个构造函数的原型链上 123456789101112function Person() &#123;&#125;var p = new Person();console.log(p instanceof Person); // truevar obj = &#123; name: 'xx'&#125;;Person.prototype = obj;var p2 = new Person();console.log(p2);console.log(p2 instanceof Person); 细细品味会发现isPrototypeOf、instanceOf两者的区别主要是： A.isPrototypeOf(B) 判断的是A对象是否存在于B对象的原型链之中 A instanceof B 判断的是B.prototype是否存在与A的原型链之中 结论： 如果 A.isPrototypeOf(B) 返回true 则B instanceof A 一定返回true construnctor: 构造器 123456789101112131415function Person() &#123;&#125;var p = new Person();console.log(p);// 可以沿着这条线找到类型名称console.log(p.constructor.name);Person.prototype = &#123; constructor: Person, // 一定要设置, 否则就指向了Object name: 'sz', age: 18&#125;;var p2 = new Person();console.log(p2.constructor.name); 对象.属性的方法去访问属性的时候，先查找有没有对应的实例属性，如果有那么就直接使用。如果没有，那么就去该对象的原型对象上面去找，如果有那么就直接使用。如果没有，那么就接着查找原型对象的原型对象，如果有，那么就直接使用，如果没有，那么就继续上面的搜索过程，直到搜索到Object.prototype为止，如果还是没有找到就返回undefined或者是报错，原型链搜索的路径越长，查询属性所花费的时间就越多。注意：原型链搜索的路径越长，查询属性所花费的时间就越多，原则：就近原型 12345678910111213141516171819202122232425262728293031323334// 画出 arr 的完整原型图var arr = [1, 2, 3];console.log(arr.constructor.name);// 1. Array的构造函数: Functionconsole.log(Array.__proto__.constructor.name);// 2. Function的原型对象// 3. Array的__proto__// 4. Function的原型对象的constructorconsole.log(Function.prototype.constructor.name); // Function// 5. Function对象的构造函数console.log(Function.__proto__.constructor.name); // 到头了// 6. Function的__proto__: Function的原型对象// 7. Array的原型对象的构造函数console.log(Array.prototype.__proto__.constructor.name); // Object// 8. Object的原型对象, constructor// 9. Object的原型对象的构造函数console.log(Object.prototype.__proto__); // null 到头了// 10. Object对象的构造函数console.log(Object.__proto__.constructor.name); // Functionfunction Person(name) &#123; this.name = name; this.toString = function () &#123; console.log('我是增加在对象上的方法'); &#125;;&#125;Person.prototype.toString = function () &#123; console.log('我是增加在原型对象上的方法');&#125;;var p = new Person('sz');p.toString(); 2、浅拷贝和深拷贝 浅拷贝，拷贝属性。如果属性的值是引用类型的,那么子对象和父对象共享一块数据,修改了某个对象对另外一个对象有影响 123456789101112131415161718192021222324var obj = &#123;name: '撩课', age: 18&#125;;var obj2 = &#123;&#125;;// 目标, 让obj2, 拥有obj内的所有属性for (var key in obj) &#123; obj2[key] = obj[key];&#125;console.log(obj2);var obj3 = &#123;class: '09'&#125;;Object.assign(obj3, obj, &#123;address: '上海'&#125;);console.log(obj3);var p = &#123;name: '张三', pets: ['小花', '小黑', '土豆']&#125;;var copyP = &#123;&#125;;/*for (var key in p) &#123; copyP[key] = p[key];&#125;*/// 默认情况下, 全部都是浅拷贝Object.assign(copyP, p);copyP.pets.push('马铃薯');console.log(p); 深拷贝 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 1. 要拷贝的对象var obj = &#123; name: '撩课', age: 18, friends: ['小花', '小黑'], goodF: &#123; name: '小撩', age: 19, address: '上海', pets: [&#123;name: '土豆'&#125;, &#123;name: '马铃薯'&#125;] &#125;, bir: new Date()&#125;;/** * 深拷贝fromObj面的所有属性/值, 到toObj对象里面 * @param fromObj 拷贝对象 * @param toObj 目标对象*/function deepCopyObj2NewObj(fromObj, toObj) &#123; for (var key in fromObj) &#123; var fromValue = fromObj[key]; // 如果是值类型，那么就直接拷贝赋值 if (!isObj(fromValue)) &#123; toObj[key] = fromValue; &#125; else &#123; // 如果是引用类型，那么就再调用一次这个方法， // 去内部拷贝这个对象的所有属性 // fromValue是什么类型, 创建一个该类型的空对象 var tmpObj = new fromValue.constructor; // console.log(tmpObj); // debugger; deepCopyObj2NewObj(fromValue, tmpObj); toObj[key] = tmpObj; &#125; &#125;&#125;/** * 辅助函数, 判定是否是对象 * @param obj * @returns &#123;boolean&#125;*/function isObj(obj) &#123; return obj instanceof Object;&#125;/** * 辅助函数, 判定是否是数组 * @param obj * @returns &#123;boolean&#125;*/function isArray(obj) &#123; return Array.isArray(obj); // Object.prototype.toString.call(obj) == '[object Array]'&#125;var newObj = &#123;&#125;; // 0x1111deepCopyObj2NewObj(obj, newObj);obj.goodF.pets[0]['size'] = '20px';console.log(obj);console.log(newObj); 3、原型链继承 原型链继承 1234567891011121314151617181920212223242526272829303132333435/*** 构造函数Person*/function Person() &#123; this.name = '撩课学院'; this.pets = ['小煤球', 'Python'];&#125;Person.prototype.run = function () &#123; console.log('跑');&#125;;/*** 构造函数Student*/function Stu() &#123; this.num = 'itlike.com';&#125;// 1. 构造父类的实例var p = new Person();// 2. 并设置为子类的原型对象Stu.prototype = p;// 3. 修复constructor指针Stu.prototype.constructor = Stu;// 3. 全部都继承var stu = new Stu();console.log(stu);console.log(stu.num);console.log(stu.name);console.log(stu.pets);stu.run();console.log(stu.constructor.name); //stu 寄生式组合继承，寄生式组合继承 = 寄生式(原型式继承+对象增加) + 原型链 + 借助构造函数继承 1234567891011121314151617181920212223242526272829303132function Person(name, pets) &#123; this.name = name; this.pets = pets;&#125;Person.prototype.run = function () &#123; console.log('跑');&#125;;function Student(num, name, pets) &#123; Person.call(this, name, pets); this.num = num;&#125;// 1.原型式继承function Tmp() &#123;&#125;Tmp.prototype = Person.prototype;var stuPro = new Tmp();// 增强动作stuPro.constructor = Student;// 原型链继承Student.prototype = stuPro;var stu = new Student('001', 'sz', ['小花']);console.log(stu);stu.run();var stu2 = new Student('002','王二小', ['土豆']);console.log(stu2);stu2.run(); 4、设计模式 工厂模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 简单工厂模式: 给定原材料,加工出给定的产品// 咖啡机// 放入咖啡豆和水, 加工出不同比例的咖啡function makeCoffee(dou, water) &#123; var obj = new Object(); obj.dou = dou; obj.water = water; obj.bili = dou / water; return obj;&#125;var coffee = makeCoffee(1, 10);console.log('造出了纯度为', coffee.bili, '的咖啡');var coffee2 = makeCoffee(2, 10);console.log('造出了纯度为', coffee2.bili, '的咖啡');// 复杂工厂模式// 果汁厂(苹果汁, 橘子汁, 香蕉汁, ....)/** * 果汁工厂*/function FruitMaker() &#123;&#125;/** * 对外招商 * @param type 类型 * @param meta 材料*/FruitMaker.prototype.make = function (type, meta) &#123; // 2.1 根据传入, 检测, 是否具备生产能力 if (typeof this[type] === 'function') &#123; // 2.2 如果具备, 则使用某条生产线, 开始生产产品 var func = this[type]; // 2.3 修改生产厂家(对外统一) func.prototype = FruitMaker.prototype; // 2.3 返回产品 return new func(meta); &#125;else &#123; throw '很抱歉, 公司还不能生产这种产品, 后期会扩充生产线!'; &#125;&#125;;// 3. 设置工厂具备能力-扩展生产线FruitMaker.prototype.extend = function (obj) &#123; for (var key in obj) &#123; this[key] = obj[key]; &#125;&#125;;// 4. 工厂扩展生产线FruitMaker.prototype.extend(&#123; 'Apple': function (meta) &#123; console.log('造了一杯苹果汁, 材料有:', meta); &#125;, 'Pear': function (meta) &#123; console.log('造了一杯梨汁, 材料有:', meta); &#125;&#125;);// 1. 实例化水果工厂var maker = new FruitMaker();var appleObj = maker.make('Apple', '一个苹果, 一斤水');console.log(appleObj.constructor.name);var pearObj = maker.make('Pear', '两个梨, 一吨水');console.log(pearObj.constructor.name);var buzhidao = maker.make('xxx'); 单例模式，实现的方式可以有几种 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 全局变量的方式var instance = null;function Tool() &#123; // 1. 判断 if (instance) &#123; return instance; &#125; // 2. 指向 instance = this; this.name = '撩课学院'; this.intro = '喜欢IT, 就上撩课(itlike.com)';&#125;// 3. 实例化var t1 = new Tool();var t2 = new Tool();var t3 = new Tool();console.log(t1 === t2);console.log(t3 === t2);// 即时函数的方式(function () &#123; var instance = null; function Tool() &#123; // 1. 判断 if (instance) &#123; return instance; &#125; // 2. 指向 instance = this; this.name = 'xx'; this.intro = '喜欢IT'; &#125; window.Tool = Tool;&#125;)(window);var t1 = new Tool();var t2 = new Tool();var t3 = new Tool();console.log(t1 === t2);console.log(t1 === t3);t1.name = 'itlike';console.log(t1);console.log(t2);console.log(t3);// 惰性函数单例的方式function Tool() &#123; var instance = this; this.name = '张三'; this.age = 18; // 惰性函数, 函数只会在第一次被执行, 后面直接调用 Tool = function () &#123; return instance; &#125;;&#125;/*var t1 = new Tool();var t2 = new Tool();console.log(t1 === t2);*/var t1 = new Tool();Tool.prototype.run = function () &#123; console.log('跑');&#125;;var t2 = new Tool();console.log(t1 === t2);t2.run();// 原型对象的方式function Tool() &#123; // 1. 声明 var instance = null; var oldPrototype = Tool.prototype; // 保存Tool的原型对象 Tool = function () &#123; return instance; &#125;; Tool.prototype = oldPrototype; instance = new Tool(); // 修正constructor instance.constructor = Tool; instance.name = '张三'; instance.age = 18; return instance;&#125;Tool.prototype.run = function () &#123; console.log('跑');&#125;;var t1 = new Tool();Tool.prototype.desc = 'xxx';var t2 = new Tool();var t3 = new Tool();var t4 = new Tool();console.log(t1 === t2);console.log(t3 === t4);console.log(t3 === t1);console.log(t1.desc);console.log(t2.desc);console.log(t3.desc);console.log(t1.constructor); 观察者模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 消息的发布者// 可以让别人订阅某个消息// 可以发布消息var lk = &#123; typeTargetAction: &#123;&#125;, addUser: function (type, target, action) &#123; if (typeof this.typeTargetAction[type] === 'undefined') &#123; this.typeTargetAction[type] = []; &#125; var obj = &#123;target: target, action: action&#125;; this.typeTargetAction[type].push(obj); &#125;, publishMsg: function (type, msgContent) &#123; var targetActions = this.typeTargetAction[type] || []; for (var i = 0, len = targetActions.length; i &lt; len; i++) &#123; var obj = targetActions[i]; var target = obj['target']; var action = obj['action']; action.call(target, msgContent); &#125; &#125;&#125;;var stu1 = &#123;name: '张三'&#125;;var stu2 = &#123;name: '李四'&#125;;lk.addUser('h5', stu1, function (msgContent) &#123; console.log(msgContent, '已推送', this.name);&#125;);lk.addUser('h5', stu2, function (msgContent) &#123; console.log(msgContent, '已推送', this.name);&#125;);lk.addUser('java', stu1, function (msgContent) &#123; console.log(msgContent, '已推送', this.name);&#125;);lk.addUser('python', stu2, function (msgContent) &#123; console.log(msgContent, '已推送', this.name);&#125;);// 广播消息lk.publishMsg('h5', 'H5学院消息: 今晚上课');lk.publishMsg('java', 'Java学院消息: 今晚不上课'); 策略模式 12345678910111213141516171819202122232425var Celue = &#123; slow: function (distance) &#123; console.log('慢速运动策略耗时:', distance * 2, '小时'); &#125;, normal: function (distance) &#123; console.log('普通运动策略耗时:', distance, '小时'); &#125;, fast: function (distance) &#123; console.log('快速运动策略耗时:', distance / 2, '小时'); &#125;&#125;;function PersonRun(from, to) &#123; this.from = from; this.to = to;&#125;PersonRun.prototype.run = function (celue) &#123; celue(this.to - this.from);&#125;;var p = new PersonRun(0, 20);p.run(Celue.slow);p.run(Celue.normal);p.run(Celue.fast); 模板模式 1234567891011121314151617181920212223242526272829303132333435363738function Fruit() &#123;&#125;Fruit.prototype.make = function () &#123; this.water(); this.cailiao(); this.jiaoban(); this.liangliang();&#125;;Fruit.prototype.water = function () &#123; console.log('烧好开水, 到开水');&#125;;Fruit.prototype.cailiao = function () &#123; throw new Error('必须由子类重写这个方法');&#125;;Fruit.prototype.jiaoban = function () &#123; console.log('搅拌搅拌');&#125;;Fruit.prototype.liangliang = function () &#123; console.log('凉一下, 就可以喝了');&#125;function Apple() &#123;&#125;// 继承原型对象方法Apple.prototype = new Fruit();Apple.prototype.cailiao = function () &#123; console.log('放苹果');&#125;;var apple = new Apple();console.log(apple);apple.make();function Pear() &#123;Fruit.call(this);&#125;// 继承原型对象方法Pear.prototype = new Fruit();Pear.prototype.cailiao = function () &#123; console.log('放梨子');&#125;;var pear = new Pear();pear.make(); 命令模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 类似于, 点餐人员, 关注的是菜单;厨房老大关注的是分配,厨师关注的是做菜, 业务分离, 低耦合// 厨师var cook1 = &#123;name: '王二小', make: function (foodType) &#123; switch (foodType) &#123; case 'tudou': console.log(this.name, '做土豆'); break; case 'jidan': console.log(this.name, '做鸡蛋'); break; case 'fanqie': console.log(this.name, '做番茄'); break; default: console.log('不会做'); &#125;&#125;&#125;;var cook2 = &#123;name: '王大小', make: function (foodType) &#123; switch (foodType) &#123; case 'tudou': console.log(this.name, '做土豆加辣椒'); break; case 'jidan': console.log(this.name, '做鸡蛋加白糖'); break; case 'fanqie': console.log(this.name, '做番茄加酱油'); break; default: console.log('不会做'); &#125;&#125;&#125;;// 服务员点餐// 服务员, 帮客人点菜var foodList = ['tudou', 'jidan', 'fanqie'];// 厨房根据菜单, 创建不同的命令, 分配给不同的厨师// 点餐系统function MakeFoodCommand(cook, foodType)&#123; this.cook = cook; this.foodType = foodType;&#125;MakeFoodCommand.prototype.execute = function() &#123; this.cook.make(this.foodType);&#125;;// 点餐系统生成做菜命令// ['tudou', 'jidan', 'fanqie'];var commonds = [];for (var i = 0; i &lt; foodList.length; i ++) &#123; var commond = null; if (i % 2 === 0) &#123; commond = new MakeFoodCommand(cook1, foodList[i]); &#125;else &#123; commond = new MakeFoodCommand(cook2, foodList[i]); &#125; commonds.push(commond);&#125;console.log(commonds);// 开始根据不同的规则, 让这些命令开始执行commonds.forEach(function (cmd) &#123; console.log(cmd); cmd.execute();&#125;)","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"记一次vue升级爬坑之旅","date":"2019-11-27T14:56:34.000Z","path":"2019/11/27/记一次vue升级爬坑之旅/","text":"写这篇日记的起因是用 vue 重构公司项目，自己升级了一下项目的 vue 为最新版本 2.6.10，发现 npm run build 打包出来的。在涉及 slot-scope=”scope”的问题，抛出了一个错误。[Vue warn]:TypeError: Cannot create property ‘default’ on boolean ‘true’”。在这里与大家做一些分享，共同学习。 google 查阅文档 查到以下相关资料资料 1资料 2 解决方案 123456a) 先删除已经存在的node_modules 删除package-lock.json npm cache clean --force npm installb) npm i vue-hot-reload-api@2.3.3c) npm i vue-template-compile -S 解决方案 切记，如果项目中有引入 CDN 的 vue 文件，一定要保证 vue-template-compile 版本要跟 CDN 版本号一致，例如最新的是 2.6.10，两个都要是一样才可以。不然就会出现，为什么本地正常，线上生产环境为什么会报错。原因就在于解析器版本对不上，导致解析语法出错。","tags":[{"name":"框架","slug":"框架","permalink":"https://liwenxin-jam.github.io/tags/框架/"}]},{"title":"scrollload插件使用小结","date":"2019-10-06T13:01:39.000Z","path":"2019/10/06/scrollload插件使用小结/","text":"最开始使用这个插件的出发点是better-scroll不支持PC端滚轮下滑无限加载数据。有兴趣的童鞋也可以自己去深究下BetterScroll。在谷歌搜寻了一遍，最终决定采用scrollload 简单示例，详细配置可以参考官网1、引用1import Scrollload from 'Scrollload' 2、模板12345678910&lt;div class=\"scroll-list-wrap\"&gt; &lt;div class=\"scroll-container\"&gt; &lt;ul class=\"total-list\"&gt; &lt;li class=\"content\" v-for=\"(item, index) in tableData\" :key=\"item.id\"&gt; &lt;div class=\"left\"&gt;&#123;&#123;item.startTime | dateFilter&#125;&#125;&lt;/div&gt; &lt;div class=\"right\"&gt;&#123;&#123;item.imageHubFileTotal&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 3、样式1234567891011121314151617181920212223.scroll-list-wrap &#123; width: calc(100% - 20px); height: 413px; overflow-y: auto; .total-list &#123; margin: 0 0 0 20px; border: 1px solid #e0e0e0; li &#123; display: flex; border-bottom: 1px solid #e7e7e7; &amp;:last-child &#123; border-bottom: none; &#125; &#125; .content &#123; padding: 13px 0; &#125; &#125;&#125; 4、初始化12345678910111213141516171819202122232425262728293031323334353637let self = this;new Scrollload(&#123; container: document.querySelector('.scroll-container'), content: document.querySelector('.total-list'), // 视窗(默认是window，如果是局部滚动需要设置滚动的dom) window: document.querySelector('.scroll-list-wrap'), isInitLock: false, enableLoadMore: true, threshold: 10, useLocalScrollFix: false, loadMore: function(sl) &#123; //this===sl if (self.historyTotal !== -1 &amp;&amp; self.tableData.length &gt;= self.historyTotal) &#123; //如果加载完了，那么需要调用noMoreData方法。这样底部DOM会从原来的加载动画变成结束div sl.noMoreData(); return; &#125; ApiGetHistoryDailyCount(self.totalTableParams).then(response =&gt; &#123; let res = response.data; if (res.status) &#123; self.historyTotal = res.data.total; if (res.data &amp;&amp; res.data.rows.length) &#123; self.tableData = self.tableData.concat(res.data.rows); self.$forceUpdate() &#125; self.totalPageIndex++; self.totalTableParams.offset = self.totalPageIndex * self.totalPageSize; self.$nextTick(() =&gt; &#123; sl.unLock(); &#125;) &#125; else &#123; self.showMessage(res.message, 'error'); // 加载出错，需要执行该方法。这样底部DOM会出现出现异常的样式。 sl.throwException(); &#125; &#125;); &#125;&#125;)","tags":[{"name":"工具","slug":"工具","permalink":"https://liwenxin-jam.github.io/tags/工具/"}]},{"title":"Grid网格布局","date":"2019-09-26T11:44:32.000Z","path":"2019/09/26/Grid网格布局/","text":"flexbox 是一维布局，他只能在一条直线上放置你的内容区块；而 grid 是一个二维布局。前面也简单说到，你可以根据你的设计需求，将内容区块放置到任何你想要放的地方。IE10+默认支持 CSS Grid Layout 模块功能之外，其他的浏览器 Chrome、Safari、Opera 和 Firefox 都需要重新设置（启用开发中的实验性网络平台功能）。 Chrome 浏览器在 Chrome 浏览器中开启 CSS-Grid-Layout 模块功能比较简单，只需要在您的浏览器地址栏中输入：chrome://flags，回车后在列表清单中找到“启用实验性网络平台功能”（#enable-experimental-web-platform-features），一个更为简单的方法，可以直接在浏览器地址栏中输入网址：chrome://flags#enable-experimental-web-platform-features 立马定位需要的选项，然后点击“启用”(enable)按钮。 可以给父容器的 display 属性设置为 grid 或者 inline-grid 来定义一个网格。这样你就可以使用 grid-template-columns 和 grid-template-rows 属性来创建一个网格。在这个示例中，创建了一个三列网格，其中三个列的列宽是 100px，并且指定列与列之间的间距为 10px。同时网格具有三行，每行的高度是自动的，另外行与行之间的间距是 10px。简单点说就是一个三行三列的网格，并且列与列之间，行与行之间的间距都是 10px。 默认以下栗子的 Dom 结构都是如此 123456789101112&lt;div class=\"wrapper\"&gt; &lt;div class=\"box a\"&gt;A&lt;/div&gt; &lt;div class=\"box b\"&gt;B&lt;/div&gt; &lt;div class=\"box c\"&gt;C&lt;/div&gt; &lt;div class=\"box d\"&gt;D&lt;/div&gt; &lt;div class=\"box e\"&gt;E&lt;/div&gt; &lt;div class=\"box f\"&gt;F&lt;/div&gt; &lt;div class=\"box g\"&gt;G&lt;/div&gt; &lt;div class=\"box h\"&gt;H&lt;/div&gt; &lt;div class=\"box i\"&gt;I&lt;/div&gt; &lt;div class=\"box j\"&gt;J&lt;/div&gt;&lt;/div&gt; 三列网格布局，核心样式代码是.wrapper。12345678910111213141516171819202122&lt;style type=\"text/css\"&gt; body &#123; padding: 50px; &#125; .wrapper &#123; display: grid; grid-template-columns: 100px 10px 100px 10px 100px; /* 指定了列宽100px、列间距10px*/ grid-template-rows: auto 10px auto; /* 指定了行宽auto、行间距10px*/ &#125; .box &#123; background-color: #444; color: #fff; font-size: 150%; padding: 20px; &#125; .b, .d, .g, .i &#123; background-color: red; &#125;&lt;/style&gt; 单元格占位区域，注意 grid-column-start、grid-column-end、grid-row-start、grid-row-end 的使用，默认都是从 1 开始算起。网格线的简写方式，其实就是 grid-column 和 grid-row 的 start 与 end 值合并在一起，两者之间用/来分隔。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;style type=\"text/css\"&gt; body &#123; padding: 50px; &#125; .wrapper &#123; display: grid; grid-template-columns: 100px 10px 100px 10px 100px 10px 100px; grid-template-rows: auto 10px auto 10px auto; &#125; .box &#123; background-color: #444; color: #fff; font-size: 150%; padding: 20px; text-align: center; &#125; .a &#123; grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2; &#125; .b &#123; grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2; &#125; .c &#123; grid-column-start: 5; grid-column-end: 6; grid-row-start: 1; grid-row-end: 2; &#125; .d &#123; grid-column-start: 7; grid-column-end: 8; grid-row-start: 1; grid-row-end: 2; &#125; .e &#123; grid-column-start: 1; grid-column-end: 2; grid-row-start: 3; grid-row-end: 4; &#125; .f &#123; grid-column-start: 3; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4; &#125; .g &#123; grid-column-start: 5; grid-column-end: 6; grid-row-start: 3; grid-row-end: 4; &#125; .h &#123; grid-column-start: 7; grid-column-end: 8; grid-row-start: 3; grid-row-end: 4; &#125; .i &#123; grid-column-start: 1; grid-column-end: 2; grid-row-start: 5; grid-row-end: 6; &#125; .j &#123; grid-column-start: 3; grid-column-end: 4; grid-row-start: 5; grid-row-end: 6; &#125; /*简写方式*/ .a &#123; grid-column: 1 / 2; grid-row: 1 / 2; &#125; .b &#123; grid-column: 3 / 4; grid-row: 1 / 2; &#125; .c &#123; grid-column: 5 / 6; grid-row: 1 / 2; &#125; .d &#123; grid-column: 7 / 8; grid-row: 1 / 2; &#125; .e &#123; grid-column: 1 / 2; grid-row: 3 / 4; &#125; .f &#123; grid-column: 3 / 4; grid-row: 3 / 4; &#125; .g &#123; grid-column: 5 / 6; grid-row: 3 / 4; &#125; .h &#123; grid-column: 7 / 8; grid-row: 3 / 4; &#125; .i &#123; grid-column: 1 / 2; grid-row: 5 / 6; &#125; .j &#123; grid-column: 3 / 4; grid-row: 5 / 6; &#125; /*覆盖样式，将a和f的位置对调*/ .a &#123; grid-column-start: 3; grid-column-end: 4; grid-row-start: 3; grid-row-end: 4; background: red; &#125; .f &#123; grid-column-start: 1; grid-column-end: 2; grid-row-start: 1; grid-row-end: 2; background: orange; &#125;&lt;/style&gt; 参考文献1、CSS Grid 布局：什么是网格布局2、CSS Grid 布局：浏览器开启 CSS Grid Layout3、CSS Grid 布局：网格单元格布局4、CSS Grid 布局：合并单元格布局","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"flex布局使用小结","date":"2019-08-14T13:32:51.000Z","path":"2019/08/14/flex布局使用小结/","text":"布局的传统解决方案，基于盒状模型，依赖 display 属性+position 属性+float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。Flex 是 Flexible-Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局，行内元素也可以使用 Flex 布局，不管是什么布局，Flex 往往都可以几行命令搞定，Flex 布局将成为未来布局的首选方案。 采用 Flex 布局的元素，称为 Flex 容器（flex-container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex-item），简称”项目”。设为 flex 的容器可以设置以下六种属性 flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content。注意，Webkit 内核的浏览器，必须加上-webkit 前缀，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。1、flex-direction 属性，决定主轴的方向（即项目的排列方向）flex-direction: row | row-reverse | column | column-reverse; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2、flex-wrap 属性，默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。flex-wrap: nowrap | wrap | wrap-reverse; nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 3、flex-flow 属性，flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。flex-flow: flex-direction || flex-wrap; 4、justify-content 属性，定义了项目在主轴上的对齐方式。justify-content: flex-start | flex-end | center | space-between | space-around; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5、align-items 属性，定义项目在交叉轴上如何对齐。align-items: flex-start | flex-end | center | baseline | stretch; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。 6、align-content 属性，定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。align-content: flex-start | flex-end | center | space-between | space-around | stretch; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 设为 flex 的容器，它的所有子元素自动成为容器成员，称为 Flex 项目（flex-item），简称”项目”。项目也是可以设置以下六种属性 order、flex-grow、flex-shrink、flex-basis、flex、align-self。1、order 属性，定义项目的排列顺序。数值越小，排列越靠前，默认为 0。order: integer; 2、flex-grow 属性，定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。flex-grow: number; 3、flex-shrink 属性，定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。注意，负值对该属性无效。flex-shrink: number; 4、flex-basis 属性，定义了在分配多余空间之前，项目占据的主轴空间（main-size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间。flex-basis: length | auto; 5、flex 属性，flex 属性是 flex-grow,flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto，其中后两个属性可选。该属性有两个快捷值：auto(1 1 auto)和 none(0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] 6、align-self 属性，允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。该属性可以取 6 个值，除了 auto，其他都与 align-items 属性完全一致。align-self: auto | flex-start | flex-end | center | baseline | stretch; 以下示例是参照阮一峰老师教程的实例，我只是做了补充，把 flex-basis 也补上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;flex-box-demo&lt;/title&gt; &lt;style type=\"text/css\"&gt; .first-face &#123; display: flex; justify-content: center; align-items: center; &#125; .second-face &#123; display: flex; justify-content: space-between; &#125; .second-face .pip:nth-of-type(2) &#123; align-self: flex-end; &#125; .third-face &#123; display: flex; justify-content: space-between; &#125; .third-face .pip:nth-of-type(2) &#123; align-self: center; &#125; .third-face .pip:nth-of-type(3) &#123; align-self: flex-end; &#125; .fourth-face, .sixth-face &#123; display: flex; justify-content: space-between; &#125; .fourth-face .column, .sixth-face .column &#123; display: flex; flex-direction: column; justify-content: space-between; &#125; .fifth-face &#123; display: flex; justify-content: space-between; &#125; .fifth-face .column &#123; display: flex; flex-direction: column; justify-content: space-between; &#125; .fifth-face .column:nth-of-type(2) &#123; justify-content: center; &#125; /* OTHER STYLES */ * &#123; box-sizing: border-box; &#125; html, body &#123; height: 100%; &#125; body &#123; display: flex; align-items: center; justify-content: center; vertical-align: center; flex-wrap: wrap; align-content: center; font-family: 'Open Sans', sans-serif; background: linear-gradient(top, #222, #333); &#125; [class$='face'] &#123; margin: 16px; padding: 4px; background-color: #e7e7e7; width: 104px; height: 104px; object-fit: contain; box-shadow: inset 0 5px white, inset 0 -5px #bbb, inset 5px 0 #d7d7d7, inset -5px 0 #d7d7d7; border-radius: 10%; &#125; .pip &#123; display: block; width: 24px; height: 24px; border-radius: 50%; margin: 4px; background-color: #333; box-shadow: inset 0 3px #111, inset 0 -3px #555; &#125; /*补充flex-basis写法*/ #fourth-basic &#123; flex-wrap: wrap; align-content: space-between; &#125; #fourth-basic .column &#123; flex-direction: row; /*覆写原来的样式column*/ flex-basis: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"first-face\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"second-face\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"third-face\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"fourth-face\"&gt; &lt;div class=\"column\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"fourth-basic\" class=\"fourth-face\"&gt; &lt;div class=\"column\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"fifth-face\"&gt; &lt;div class=\"column\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"sixth-face\"&gt; &lt;div class=\"column\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;span class=\"pip\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 参考文献1、Flex 布局教程：语法篇2、Flex 布局教程：实例篇","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"table-cell常用应用","date":"2019-07-03T12:19:05.000Z","path":"2019/07/03/table-cell常用应用/","text":"display:table-cell 属性指让标签元素以表格单元格的形式呈现，类似于 td 标签。目前 IE8+以及其他现代浏览器都是支持此属性的。我们都知道，单元格有一些比较特别的属性，例如元素的垂直居中对齐，关联伸缩等。table-cell 同样会被其他一些 CSS 属性破坏，例如 float, position:absolute，所以，在使用 display:table-cell 与 float:left 或是 position:absolute 属性尽量不用同用。设置了 display:table-cell 的元素对宽度高度敏感，对 margin 值无反应，响应 padding 属性，基本上就是活脱脱的一个 td 标签元素了。 垂直居中的内容1234567891011121314151617&lt;style type=\"text/css\"&gt; .parent &#123; display: table; width: 200px; height: 200px; text-align: center; border: 1px solid #ccc; &#125; .children &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt;&lt;!-- Dom结构 --&gt;&lt;div class=\"parent\"&gt; &lt;span class=\"children\"&gt; 垂直居中的内容 &lt;/span&gt;&lt;/div&gt; 元素两端对齐，正常可以用 float 实现，但用 float 会有弊端，需要清除浮动。12345678910111213141516171819202122232425262728293031323334353637383940&lt;style type=\"text/css\"&gt; * &#123; box-sizing: border-box; &#125; .content &#123; display: table; border: 1px solid #06c; padding: 15px 15px; max-width: 1000px; margin: 10px auto; min-width: 320px; width: 100%; &#125; .box &#123; width: 100px; height: 100px; border: 1px solid #ccc; text-align: center; display: inline-block; font-size: 40px; line-height: 100px; &#125; .right &#123; text-align: right; display: table-cell; &#125; .left &#123; text-align: left; display: table-cell; &#125;&lt;/style&gt;&lt;!-- Dom结构 --&gt;&lt;div class=\"content\"&gt; &lt;div class=\"left\"&gt; &lt;div class=\"box\"&gt;B&lt;/div&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"box\"&gt;A&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 一行平分显示几个模块，一般会用 float 来做，或者把每个 li 设置成 display:inline-block;来做，并且都要设置给他们设置一个宽度，而且最痛苦的是 5 个 li 如果你设置 width:20%;他们一定会掉下来，如果 li 都设置成 display:table-cell；就不会出现这种情况，即使不设置宽度他们也会在一行显示，你在加多一行他也不会掉下来，依旧会在一样显示。123456789101112131415161718192021222324252627282930313233343536373839&lt;style type=\"text/css\"&gt; * &#123; box-sizing: border-box; &#125; .content &#123; display: table; border: 1px solid #06c; padding: 15px 15px; max-width: 1000px; margin: 10px auto; min-width: 320px; width: 100%; &#125; .content ul &#123; display: table; width: 100%; padding: 0; border-right: 1px solid #ccc; &#125; .content ul li &#123; display: table-cell; border: 1px solid #ccc; text-align: center; height: 100px; border-right: none; line-height: 100px; &#125;&lt;/style&gt;&lt;!-- Dom结构 --&gt;&lt;div class=\"content\"&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 图片垂直居中，有时候我们需要让图片垂直水平都居中于某个元素，用常规写法比较复杂，但用 table-cell 则相对简单。1234567891011121314151617181920212223242526272829&lt;style type=\"text/css\"&gt; * &#123; box-sizing: border-box; &#125; .content &#123; display: table; border: 1px solid #06c; padding: 15px 15px; max-width: 1000px; margin: 10px auto; min-width: 320px; width: 100%; &#125; .img-box &#123; height: 150px; width: 100px; border: 1px solid red; display: table-cell; vertical-align: middle; text-align: center; background-color: #4679bd; &#125;&lt;/style&gt;&lt;!-- Dom结构 --&gt;&lt;div class=\"content\"&gt; &lt;div class=\"img-box\"&gt; &lt;img src=\"1.png\" /&gt; &lt;/div&gt;&lt;/div&gt; 两 box 实现等高对齐，不对右侧的 box 设置 display:table-cell，只对左侧，所以就会出现左侧跟随右侧高度变化而变化，如果要实现不管两个 box 哪个高度产生变化另一个就跟随，只需要把右侧的 box 也设置成 display:table－cell 就可以实现了。12345678910111213141516171819202122232425262728293031323334353637383940&lt;style type=\"text/css\"&gt; * &#123; box-sizing: border-box; &#125; .content &#123; display: table; border: 1px solid #06c; padding: 15px 15px; max-width: 1000px; margin: 10px auto; min-width: 320px; width: 100%; &#125; .img-box &#123; height: 50px; width: 100px; border: 1px solid red; display: table-cell; vertical-align: middle; text-align: center; background-color: #4679bd; &#125; .text-box &#123; margin-left: 20px; border: 1px solid #ddd; padding: 10px; display: table-cell; /*注意会导致外边距失效*/ &#125;&lt;/style&gt;&lt;!-- Dom结构 --&gt;&lt;div class=\"content\"&gt; &lt;div class=\"img-box\"&gt; &lt;img src=\"1.png\" /&gt; &lt;/div&gt; &lt;div class=\"text-box\"&gt; &lt;span&gt; 王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。 &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 弹性、响应式布局，只要改变浏览器宽度就会发现他们其实都是会随高度变化自动变化高度的。12345678910111213141516171819202122232425262728293031323334353637&lt;style type=\"text/css\"&gt; * &#123; box-sizing: border-box; &#125; .content &#123; display: table; border: 1px solid #06c; padding: 15px 15px; max-width: 1000px; margin: 10px auto; min-width: 320px; width: 100%; &#125; .left-box &#123; float: left; margin-right: 10px; padding-top: 5px; &#125; .right-box &#123; display: table-cell; padding: 10px; border: 1px solid #ccc; margin-right: 10px; vertical-align: top; &#125;&lt;/style&gt;&lt;!-- Dom结构 --&gt;&lt;div class=\"content\"&gt; &lt;div class=\"img-box\"&gt; &lt;img src=\"1.png\" /&gt; &lt;/div&gt; &lt;div class=\"right-box\"&gt; &lt;span &gt;王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。王尼玛和陈尼玛都是年轻有为的骚年，有一天他们相遇了，然后发现都对对方一见钟情后，所以就愉快的生活在了一起。。。。。&lt;/span &gt; &lt;/div&gt;&lt;/div&gt; 参考文献1、我所知道的几种 display:table-cell 的应用2、CSS——布局布局神器 display:table-cell","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"react基础小结","date":"2019-06-27T01:32:12.000Z","path":"2019/06/27/react基础小结/","text":"React 是一个 Facebook 和 Instagram 用来创建用户界面的 JavaScript 库，用于构建“可预期的”和“声明式的”Web 用户界面。该框架的推出主要为了开发随着时间数据不断变化的大规模应用程序，具体文档可以参考官网。 React 具有以下特点： 1.声明式设计 −React 采用声明范式，可以轻松描述应用。 2.高效 −React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。 3.灵活 −React 可以与已知的库或框架很好地配合。 4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。 5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。 6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 1、构建与初始化 方式一：如果你只是想简单尝试下 React，可以使用stackblitz。在这里，我必须安利一下这个在线编辑器，你不需要安装任何东西，目前支持 angular、react、ionic，迟点应该也会支持 vue。支持 github 帐号登录，可以 fork 和 share，一个专门为 Web 构建的更聪明、更快的包管理器。 方式二：可以使用官网推荐用 create-react-app 的方式，是开始构建新的 React 单页面应用的最佳途径。它可以帮你配置开发环境，以便你可以使用最新的 JavaScript 特性，还能提供很棒的开发体验，并为生产环境优化你的应用。 12345// 在终端下全局安装官网推荐的create-react-appnpm install -g create-react-appcreate-react-app my-appcd my-appnpm start 方式三： 可以使用像 webpack 或 Browserify 这样的构建工具，以便于编写模块代码并将其压缩，优化加载时间，这里推荐使用webpack方式。 2、React 元素 react 是 React 库的入口点。如果你通过 script 标签加载 React，这些高阶 API 可用于 React 全局。如果你使用 ES6，你可以使用 import React from ‘react’ 。如果你使用 ES5，你可以使用 var React = require(‘react’) 创建 React 元素有 3 种方式，注意：官网认为 createFactor 方法过时了，推荐你使用 JSX 或直接使用 React.createElement()来替代它。JSX 可以看做 JavaScript 的语法拓展（eXtension），看起来有点像 XML，让我们可以在 JavaScript 中编写类似 HTML 的代码。使用 React，可以进行 JSX 语法到 JavaScript 的转换。判断一个元素是 HTML 元素还是 React 组件的原则是第一个字母是否大写，如果为大写，则认为是 React 组件，否则认为是 HTML 元素。如果我们自定义的组件首字母写成小写，那会得不到我们想要的结果。在 JSX 中可以通过 onClick 这样的方式来给一个元素添加事件处理函数，在 HTML 我们还可以用 onclick（onclick 和 onClick 是不同的）来添加事件 第一种是 React.createElement(type,[props],[…children]) 123456789101112131415161718192021var listItemElement1 = React.createElement( 'li', &#123; className: 'item-1', key: 'item-1' &#125;, 'Item-1');var listItemElement2 = React.createElement( 'li', &#123; className: 'item-2', key: 'item-2' &#125;, 'Item-2');var listItemElement3 = React.createElement( 'li', &#123; className: 'item-3', key: 'item-3' &#125;, 'Item-3');var reactFragment = [listItemElement1, listItemElement2, listItemElement3];var listOfItems = React.createElement( 'ul', &#123; className: 'list-of-items' &#125;, reactFragment); 第二种是通过创建工厂函数 React.createFactory(type)，React.DOM.li(…) 是 React.createELement(‘li’, …) 的一个包装写法，但被官网认为是过时的，有可能最终会被遗弃。 12345678910111213141516171819var createListItemElement = React.createFactory('li');var listItemElement1 = React.DOM.li( &#123; className: 'item-1', key: 'item-1' &#125;, 'Item-1');var listItemElement2 = React.DOM.li( &#123; className: 'item-2', key: 'item-2' &#125;, 'Item-2');var listItemElement3 = React.DOM.li( &#123; className: 'item-3', key: 'item-3' &#125;, 'Item-3');var reactFragment = [listItemElement1, listItemElement2, listItemElement3];var listOfItems = React.createElement( 'ul', &#123; className: 'list-of-items' &#125;, reactFragment); 第三种是使用 JSX 创建 React 元素，编写 React 的时候，JSX 并不是必须的。每一个 JSX 元素都只是 React.createElement(component, props, …children) 的语法糖。因此，任何时候你用 JSX 语法写的代码也可以用普通的 JavaScript 语法写出来。 12345678910111213141516var listOfItems =&lt;ul className=\"list-of-items\"&gt; &lt;li className=\"item-1\"&gt;Item 1&lt;/li&gt; &lt;li className=\"item-2\"&gt;Item 2&lt;/li&gt; &lt;li className=\"item-3\"&gt;Item 3&lt;/li&gt;&lt;/ul&gt;;&lt;!-- 官网例子jsx写法 --&gt;class Hello extends React.Component &#123; render() &#123; return&lt;div&gt;Hello &#123;this.props.toWhat&#125;&lt;/div&gt;; &#125; &#125;&lt;!-- 编译转成不使用JSX的代码 --&gt;class Hello extends React.Component &#123; render() &#123; returnReact.createElement('div', null, `Hello $&#123;this.props.toWhat&#125;`); &#125; &#125;ReactDOM.render( React.createElement(Hello, &#123;toWhat: 'World'&#125;, null),document.getElementById('root') ); 渲染 React 元素 12//格式：ReactDOM.render(ReactElement, DOMElement, callback);ReactDOM.render(listOfItems, document.getElementById('example')); 3、React 组件 可以通过三种方式创建 React 组件，注意，组件类的第一个字母必须大写，否则会报错，比如 HelloMessage 不能写成 helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。 第一种无状态函数式组件，无状态函数式组件形式上表现为只带有一个 render 方法的组件类，通过函数形式或者 ES6 arrow function 的形式创建，并且该组件是无 state 状态的。只要有可能，尽量使用无状态组件。能用 React.Component 创建的组件的就尽量不用 React.createClass 形式创建组件。 1234function HelloComponent(props) &#123; return&lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;; &#125; ReactDOM.render( &lt;HelloComponent name=\"world\" /&gt;,document.getElementById('example') ) 第二种 React.createClass，它是 react 刚开始推荐的创建组件的方式，是用 ES5 的写法实现 12345678910111213141516var InputControlES5 = React.createClass(&#123; propTypes:&#123;//定义传入props中的属性各种类型要求，可以接受任意值，字符串、对象、函数等等。initialValue: React.PropTypes.string.isRequired &#125;, defaultProps: &#123;//用来设置组件属性的默认值 initialValue: 'Hello World' &#125;, getInitialState:function() &#123;//用于定义初始状态，也就是一个对象，这个对象可以通过 this.state属性读取。 return &#123; text: this.props.initialValue || 'placeholder' &#125;; &#125;,handleChange: function(event) &#123; this.setState(&#123;//事件的回调函数，当用户交互导致状态变化，this.setState方法就修改状态值，每次修改以后，自动调用this.render方法，再次渲染组件。 text:event.target.value &#125;); &#125;, render: function() &#123; return (&lt;div&gt; Type something: &lt;input onChange=\"&#123;this.handleChange&#125;\" value=\"&#123;this.state.text&#125;\" /&gt;&lt;/div&gt;); &#125; &#125;); ReactDOM.render(&lt;InputControlES5 /&gt;, document.getElementById('example') ) 第三种是 React.Component，它是以 ES6 的形式来创建 react 的组件的，是 React 目前极为推荐的创建有状态组件的方式，最终会取代 React.createClass 形式；相对于 React.createClass 可以更好实现代码复用。将上面 React.createClass 的形式改为 React.Component 形式如下： 12345678910111213class InputControlES6 extends React.Component &#123; constructor(props) &#123;super(props); //调用super，是为了正确获取到this this.state = &#123; text:props.initialValue || 'placeholder' &#125;; this.handleChange =this.handleChange.bind(this); // ES6 类中函数必须手动绑定 &#125; handleChange(event)&#123; this.setState(&#123; text: event.target.value &#125;); &#125; render() &#123; return (&lt;div&gt; Type something: &lt;input onChange=\"&#123;this.handleChange&#125;\" value=\"&#123;this.state.text&#125;\" /&gt;&lt;/div&gt;); &#125; &#125; InputControlES6.propTypes = &#123; initialValue:React.PropTypes.string.isRequired &#125;; InputControlES6.defaultProps = &#123;initialValue: 'Hello Wrold' &#125;; ReactDOM.render(&lt;InputControlES6 /&gt;, document.getElementById('example') ) React.createClass 与 React.Component 区别 React.createClass 创建的组件，其每一个成员函数的 this 都有 React 自动绑定，任何时候，直接使用 this.method 即可，函数中的 this 会被正确设置 React.Component 创建的组件，其成员函数不会自动绑定 this，需要开发者手动绑定，否则将它作为事件处理函数被调用时不能通过 this 获取当前组件实例对象。 React.Component 有三种手动绑定方法：1、在构造函数中完成绑定2、调用时使用 method.bind(this)来完成绑定3、使用 arrow function 来绑定 组件属性类型 propTypes 及其默认 props 属性 defaultProps 配置不同。 组件初始状态 state 配置不同。React.createClass 创建的组件，其状态 state 是通过 getInitState 方法方法来配置组件的相关状态。React.Component 创建的组件，其状态 state 是在 construct 中像初始化组件属性一样声明。 Mixins 的支持不同。React.createClass 在创建组件时可以使用 mixins 属性，以数组的形式来混合类的集合。React.Component 不支持 Mixins,React 开发者社区提供了一个全新的方式来取代 Mixins，那就是 Higher-Order Components(高阶组件) 1234567891011121314151617181920212223242526272829303132&lt;!-- React.createClass --&gt;const Contacts = React.createClass(&#123; handleClick() &#123; console.log(this); &lt;!-- React组件实例 --&gt; &#125;, render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt; ); &#125;&#125;);&lt;!-- React.Component --&gt;class Contacts extends React.Component &#123; constructor(props) &#123; super(props); &#125; handleClick() &#123; console.log(this); // null &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt; ); &#125;&#125;&lt;!-- React.Component绑定this方法 --&gt;constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); //构造函数中绑定&#125;&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/div&gt; //使用bind来绑定&lt;div onClick=&#123;()=&gt;this.handleClick()&#125;&gt;&lt;/div&gt; //使用arrow function来绑定 4、React 组件生命周期##组件的生命周期分成三个状态： 挂载(Mounting): 这个阶段发生在组件被创建并被插入到 DOM 时 更新(Updating): 这个阶段发生在组件被重新渲染成虚拟 DOM 并决定实际 DOM 是否需要更新时 卸载(Unmounting): 这个阶段发生在组件从 DOM 中被删除时 ##组件挂载阶段 ###ES5(React.createClass) getInitialState() componentWillMount() render() componentDidMount() ###ES6(React.Component) constructor() componentWillMount() render() componentDidMount() ###组件更新阶段 componentWillReceiveProps() shouldComponentUpdate() componentWillUpdate() render() componentDidUpdate() ###组件卸载阶段 componentWillUnmount() 12345678var Hello = React.createClass(&#123; getInitialState: function () &#123; return &#123; opacity:1.0 &#125;; &#125;, componentDidMount: function () &#123; this.timer = setInterval(function ()&#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) &#123; opacity= 1.0; &#125; this.setState(&#123; opacity: opacity &#125;); &#125;.bind(this), 100); &#125;, render:function () &#123; return (&lt;div style=\"&#123;&#123;opacity:\" this.state.opacity&#125;&#125;&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;); &#125; &#125;); ReactDOM.render(&lt;Hello name=\"world\" /&gt;, document.body ); 5、受控与非受控组件 React 通过 props 和 state 来区分组件的属性和状态。其中，props(属性)用来表示组件外部传入的属性，组件内部不能改变。而 state(状态)通常表示组件内部的状态，状态是可以并且应该改变的。React 通过 props 和 state 的值来渲染组件，组件渲染完毕之后，通过响应用户操作或者异步网络请求等操作更新组件的状态来重新渲染组件。 受控组件将表单数据统一存放在 state 中，交由 React 管理，我们就可以根据用户的输入及时作出响应：1、验证输入正确性（输入格式、类型等），并作出反馈。 2、根据输入设置其它组件的状态，譬如输入不规范时，提交按钮处于不可用状态。 1234567891011121314class ControlledForm extends React.Component &#123; constructor(props) &#123;super(props); this.state = &#123; username: '' &#125; this.handleSubmit =this.handleSubmit.bind(this); this.updateUsername =this.updateUsername.bind(this); &#125; updateUsername(e) &#123; this.setState(&#123; username:e.target.value, &#125;) &#125; handleSubmit() &#123;&#125; render () &#123; return (&lt;form onSubmit=\"&#123;this.handleSubmit&#125;\"&gt; &lt;input type=\"text\" value=\"&#123;this.state.username&#125;\" onChange=\"&#123;this.updateUsername&#125;\" /&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;) &#125; &#125; ReactDOM.render(&lt;ControlledForm /&gt;, document.getElementById('react-root')) 非受控组件和传统的表单数据管理一样，由 DOM 存放表单数据，可以使用 React 提供的 refs 来获得 DOM 元素的引用。在需要的时候（譬如表单提交的时候）一次性获取表单的值。 12345678910class UnControlledForm extends React.Component &#123; constructor(props) &#123;super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125;handleSubmit(e) &#123; e.preventDefault(); console.log(\"Value: \", this.input.value) &#125;render () &#123; return (&lt;form onSubmit=\"&#123;this.handleSubmit&#125;\"&gt; &lt;input type='text' ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;) &#125; &#125; ReactDOM.render(&lt;UnControlledForm /&gt;,document.getElementById('react-root')); 参考文献1、阮一峰 React 入门实例教程2、React 从入门到放弃 – 笔记、教程、Demo","tags":[{"name":"框架","slug":"框架","permalink":"https://liwenxin-jam.github.io/tags/框架/"}]},{"title":"背景图自适应小技巧","date":"2019-05-16T09:33:48.000Z","path":"2019/05/16/背景图自适应小技巧/","text":"此文是基于素材比例可能有多种大小不等的比例，例如有些图片是宽大于高，有些是高大于宽。将图片作为背景图，并设为黑底。把图片作为背景居中显示，目的是为了在父容器的宽高下等比例缩放，保证图片不变形。如果是宽大于高，会显示上下黑边。如果是高大于宽，会显示左右黑边。 背景图自适应12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; html, body &#123; width: 100%; height: 100%; padding: 0; margin: 0; &#125; .container &#123; width: 500px; height: 500px; margin: 0 auto; &#125; .bg &#123; width: 100%; height: 100%; background-image: url(test1.jpg); /* background-image: url(test2.jpg); */ background-color: black; background-origin: content; background-position: 50% 50%; background-size: contain; background-repeat: no-repeat; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"bg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"Swiper缩略图控制&互相控制","date":"2019-04-13T13:56:51.000Z","path":"2019/04/13/Swiper缩略图控制&互相控制/","text":"此文是基于swiper 官网来写，目的只是做个总结，需求是上边是大图显示，下边是缩略图图显示。默认下边不划动，当缩略图图一行不够显示的时候才滚动。引用的是 V3 版本的文件，官网有个类似的效果是引用 V4 版本的，仅供参考。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./css/swiper-3.4.2.min.css\" /&gt; &lt;style type=\"text/css\"&gt; html, body &#123; position: relative; height: 100%; &#125; body &#123; background: #000; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14px; color: #000; margin: 0; padding: 0; &#125; .container &#123; width: 300px; margin: 0 auto; &#125; .swiper-slide &#123; background-size: cover; background-position: center; &#125; .gallery-top-box &#123; width: 100%; margin: 0 auto; &#125; .gallery-thumbs-box &#123; width: 100%; margin: 0 auto; &#125; .swiper-container &#123; width: 100%; height: 200px; margin-left: auto; margin-right: auto; &#125; .gallery-thumbs &#123; height: 60px; box-sizing: border-box; padding: 10px 0; &#125; .gallery-thumbs .swiper-slide &#123; height: 100%; opacity: 0.4; &#125; .gallery-thumbs .swiper-slide-active &#123; opacity: 1; &#125; .gallery-thumbs .swiper-wrapper &#123; transform: none !important; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;!-- Swiper --&gt; &lt;div class=\"gallery-top-box\"&gt; &lt;div class=\"swiper-container gallery-top\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature1.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature2.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature3.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature4.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature5.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature6.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature7.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature8.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature9.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature10.jpg)\" &gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- Add Arrows --&gt; &lt;div class=\"swiper-button-next swiper-button-white\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-prev swiper-button-white\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"gallery-thumbs-box\"&gt; &lt;div class=\"swiper-container gallery-thumbs\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature1.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature2.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature3.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature4.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature5.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature6.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature7.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature8.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature9.jpg)\" &gt;&lt;/div&gt; &lt;div class=\"swiper-slide\" style=\"background-image:url(img/nature10.jpg)\" &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Swiper JS --&gt; &lt;script src=\"./js/swiper-3.4.2.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var leftScreenVal, moveLeftVal; var galleryTop = new Swiper('.gallery-top', &#123; nextButton: '.swiper-button-next', prevButton: '.swiper-button-prev', observer: true, observeParents: true, autoplay: 5000, onSlidePrevEnd: function (swiper) &#123; // 这里因为居中显示的时候，按照我屏幕默认距离屏幕左边570像素，所以是以570为基准，然后再算每一个图片宽度155，有几张 leftScreenVal = document .getElementsByClassName('swiper-slide-active')[1] .getBoundingClientRect().left; if (leftScreenVal &lt; 570) &#123; moveLeftVal = document.getElementsByClassName( 'swiper-slide-active' )[1].offsetLeft; moveLeftVal = 155 - moveLeftVal; document.querySelector( '.gallery-thumbs &gt; .swiper-wrapper' ).style.left = moveLeftVal + 'px'; &#125; &#125;, onSlideNextEnd: function (swiper) &#123; // 这里因为居中显示的时候，按照我屏幕默认距离屏幕左边570像素，所以是以570为基准，然后再算每一个图片宽度155，有几张 var leftScreenVal = document .getElementsByClassName('swiper-slide-active')[1] .getBoundingClientRect().left; if (leftScreenVal &gt;= 880) &#123; // 这里880是因为我基准570加上下边一行默认只显示两张155宽度的缩略图 moveLeftVal = document.getElementsByClassName( 'swiper-slide-active' )[1].offsetLeft; moveLeftVal = 0 - moveLeftVal; document.querySelector( '.gallery-thumbs &gt; .swiper-wrapper' ).style.left = moveLeftVal + 'px'; &#125; &#125;, &#125;); var galleryThumbs = new Swiper('.gallery-thumbs', &#123; centeredSlides: true, slidesPerView: 2, touchRatio: 0.2, slideToClickedSlide: true, observer: true, observeParents: true, spaceBetween: 10, &#125;); galleryTop.params.control = galleryThumbs; galleryThumbs.params.control = galleryTop; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如果有需要源文件可以从以下源码地址拉取","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"less小结","date":"2019-03-10T00:49:36.000Z","path":"2019/03/10/less小结/","text":"less是预编译css语言，是css的超集。此文只是个人的一些总结归纳，仅供参考。如果想深入了解可以细看官网。 1、注释 .less后缀的文件并不能直接在浏览器上识别，所以需要借助第三方工具编译，我用的是koala。12// 单行注释， 不会附加在编译后的文件上/* 多行注释 会附加在编译后的文件上 */ 2、变量1234567891011121314151617181920212223242526272829// 定义less变量使用的是@符号，稍微注意下// 定义sass变量使用的是$符号，稍微注意下// 1.变量名可以由字母、数字、_和-组成// 2.less变量可以使用类似@tagName: section;注意在用于选择器部件或者是字符串拼接的时候，必须使用使用@&#123;tagName&#125;才会生效，作为属性的时候可以直接@tagName// 3.less在使用变量的时候有作用域的，优先选择最靠近的less变量使用。存在使用less变量的过程中会有懒加载的情况。@color: blue;@font-size: 20px;h1 &#123; color: @color; font-size: @font-size;&#125;@tagName: section;@height: height;@&#123;tagName&#125; &#123; @&#123;height&#125;: 100%;&#125;@changedColor: green;div &#123; ul &#123; li&#123; color: @changedColor; // 那么此时就是这个最靠近了，less找的就会是这个变量对应的颜色值 @changedColor: pink; &#125; // 虽然你放在了下面，less会发挥懒加载机制，优先找最靠近的变量 @changedColor: #f00; &#125;&#125; 3、嵌套12345678910111213141516171819202122232425262728293031323334353637// 可以直接嵌套区分上下层级关系，也可以利用父选择器引用，采用&amp;可以引用完整的父选择器@pink: pink;@black: black;.container &#123; padding: 20px; background-color: @pink; &gt; div &#123; width: 100px; &#125; .aside &#123; width: 200px; &#125; button &#123; margin: 10px; color: @pink; &#125; div &#123; padding: 15px 10px; color: @black; // 在这个div的后面加多一个after伪类，并添加以下内容 &amp;:after &#123; display: block; content: '英文名是jam!'; color: #909090; font-weight: bold; font-size: 50px; font-family: \"Microsoft YaHei\"; border: 1px solid @pink; &#125; &amp;-msg&#123; color: blue; &#125; &amp; &gt; &amp; &#123; font-size: 50px; &#125; &#125;&#125; 4、继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 单继承与多继承.baseClass &#123; color: #f00;&#125;.baseClass2 &#123; font-weight: 500;&#125;// 方式一，多重继承的，用逗号隔开就行了.myClass:extend(.baseClass, .baseClass2) &#123; // .myClass类拥有的属性 background-color: yellow; color: green;&#125;// 方式二，多重继承的，用逗号隔开就行了.myClass2 &#123; // &amp;代表当前.myClass2这个类 &amp;:extend(.baseClass, .baseClass2); // .myClass2类拥有的属性 font-size: 50px;&#125;// less不支持继承泛型的子类*.button &#123; font-size: 12px;&#125;// less要继承就继承泛型，比如*.button，不支持继承div.button，特别注意下.myClass &#123; // &amp;:extend(div.button); // 这样写是会有问题的，继承不过来 &amp;:extend(*.button);&#125;// less不支持多匹配相似度继承[name=xx] &#123; border: 1px solid red;&#125;[name=\"xx\"] &#123; border: 1px solid green;&#125;[name='xx'] &#123; border: 1px solid blue;&#125;.myClass &#123; &amp;:extend([name=\"xx\"]); // 这样写不太好，它会把每个相似的都继承过来，稍微注意下&#125;// 在实现less深度继承的时候外层结构顶级随意，里层对应的.className必须保持一致，深度继承语法为.myClass&#123;&amp;:extend(.className)&#125;;，当如果不写all参数的时候只会继承最顶层的样式，如果写成.myClass&#123;&amp;:extend(.className all)&#125;;则把子类也一起继承过来了.base &#123; color: #f00; .base2 &#123; font-size: 20px; &#125;&#125;.myClass &#123; // &amp;:extend(.base); &amp;:extend(.base all); text-decoration: line-through;&#125;// 媒体查询与继承：// 1.在相同的的媒体查询范围内嵌套和继承都是没问题的// 2.在媒体查询外部的css代码的类或标签的选择器是可以继承媒体查询内部的，而且继承的时候是可以继承所有匹配相同的选择器的@media screen &#123; h1 &#123; font-size: 50px; &#125; @media (min-width: 500px) &#123; h2 &#123; color: #f00; &#125; @media (max-width: 1500px) &#123; h1 &#123; font-family: \"SimSun\"; &#125; strong &#123; font-weight: normal; font-style: normal; &#125; .myClass &#123; // 只能继承媒体查询内部同级标签，比如strong &amp;:extend(strong); // 继承不了不是媒体查询内部同级标签h1，h2 // &amp;:extend(strong, h2, h1); &#125; &#125; &#125;&#125;// 在媒体查询外部的css代码的类或标签的选择器是可以继承媒体查询内部的，而且继承的时候是可以继承所有匹配相同的选择器的.testClass:extend(h1) &#123; background-color: blue;&#125; 5、函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// less本身自带有很多内置函数，我就不一一介绍，有兴趣的可以看看官网的API，在这里我主要想说一下mixin// 如果mixin函数传入的形势参数都设置了默认值，那么我们在调用less函数的时候直接调用就行了，可以不用传入任何参数。如果less函数传了第一个参数，第二个没有传，可以指定形参名称绕过第一个参数来// 参数后面加...，表示在调用less函数的时候可以传入无数个实际参数@color: #000;@font-size: 80px;.myClass (@color, @font-size...) &#123; color: @color; font-size: @font-size;&#125;// 调用less函数，注意调用的时候一定要在某个选择器里面去调用less函数h1 &#123; .myClass (@font-size: @font-size, 1, 2, 3);&#125;//mixin内置两个特殊的对象 @arguments 和 @reset 。@arguments代表mixin的所有入参,而@reset代表mixin的...入参数组。.xx-border (...) &#123; border: @arguments;&#125;.xx-test(@type;@rest...)&#123; height: @type * 12px; border: @rest;&#125;.myClass &#123; .xx-border (100px, solid, pink); .xx-test(2;1px;solid;red); &#125;// mixin函数的形势参数可以使用逗号和分号隔开，个人习惯问题，无所谓！.xx-test (@width: 1px, @type, @color: red) &#123; border: @arguments;&#125;.myClass &#123; .xx-test (@type: solid);&#125;// mixin的重载可定义多个同名mixin，调用时只要参数数量匹配则会执行相应的mixin。.base (@font-size) &#123; font-size: @font-size;&#125;.base (@font-weight, @color) &#123; font-weight: @font-weight; color: @color;&#125;.base (@border...) &#123; border: @arguments;&#125;.test-Class &#123; .base(20px); .base(bold, black); .base (1px, solid, red);&#125;// mixin支持标签参数的模式匹配.common (aaa; @type; @color) &#123; border: 1px @type; @color;&#125;.common (bbb; @type; @color) &#123; border: 1px solid blue;&#125;.common (@type; @color) &#123; border: 1px @type; @color;&#125;.myClass &#123; .common (aaa, solid, red); .common (bbb, solid, blue); .common (solid, green); .common (bbb, solid); // 这里虽然使用了标签，但参数不够，会把标签当成是一个值&#125;// less函数命名空间.nameSpace &#123; .package &#123; .a () &#123; a: a; &#125; .b () &#123; b: b; &#125; &#125;&#125;.myClass &#123; .nameSpace.package.a(); .nameSpace.package.b();&#125;// 作为结构体内部的变量是不会被外部访问到的，先拆包，调用就有反应// 规则体变量访问不到会报错 start@color: blue;@struct : &#123; font-size: 20px; @color: #f00; &amp; &gt; .book &#123; margin: 10px; &#125; .name () &#123; border: 1px solid red; color: @color; &#125; &#125;;.myClass &#123; // 如果使用了规则体，内部的子函数只能够通过拆包的方式拿到，不能使用命名空间的方式去拿 // 使用的@color是距离less子函数就接近的那个颜色值 @struct(); .name(); @color: green; // 作为结构体内部的变量是不会被外部访问到的&#125;// = ---&gt; javascript的==，不是赋值，逗号表示或的意思// default函数用于条件控制当中，充当else或switch语句中default的角色。// .func (@size) when (@size &gt; 20pt) and (@size &lt; 40pt) , (true) &#123;.func (@size) when (@size &gt; 20pt) and (@size &lt; 40pt) &#123; .red when (@size = 30pt) &#123; font-size: @size; color: #f00; &#125; .blue &#123; font-size: @size; color: blue; &#125;&#125;// 加了when (default())之后这个函数需要前者条件不符合的情况下才会执行 .func (@size) when (default()) &#123; .yellow &#123; font-size: @size; &#125;&#125;.selector &#123; .func (35pt);&#125; 12345678// mixin函数的递归不能够对选择器做递归循环，只有使用到了的变量才会发生变化，执行循环多次.generate-columns(@n, @i: 1) when (@i =&lt; @n) &#123; .column-@&#123;i&#125; &#123; width: (@i * 100% / @n); &#125; .generate-columns(@n, (@i + 1));&#125;.generate-columns(4);","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"CSS画各种基本图形","date":"2019-02-05T08:55:21.000Z","path":"2019/02/05/CSS画各种基本图形/","text":"此文主要是为了加深自己对CSS3的一些理解，在此主要列举一下一些多边形如何来画，以及如何调整。长方形和正方形大家都明白，这里就列举了。 1、相关圆形12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 单个实心圆，主要注意border-radius即可 --&gt;.single-round&#123; width: 100px; height: 100px; background-color: red; border-radius: 50%;&#125;&lt;div class=\"single-round\"&gt; &lt;/div&gt;&lt;!-- 双圆，方式一分别画大小圆 --&gt;.round-box&#123; width: 100px; height: 100px; position: relative;&#125;.round-bigRound &#123; width: 100px; height: 100px; background:black; border-radius: 50%;&#125;.round-smallRound&#123; width: 80px; height: 80px; position:absolute; left: 10px; top: 10px; border-radius: 50%; background:#cc313d;&#125;&lt;div class=\"round-box\"&gt; &lt;div class=\"round-bigRound\"&gt;&lt;/div&gt; &lt;div class=\"round-smallRound\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 双圆，方式二，只画一个圆利用box-shadow的inset属性内部阴影实现外边圆 --&gt;.round-boxshadow&#123; width: 100px; height: 100px; background:#cc313d; border-radius: 50%; box-shadow: inset 0 0 0 15px rgba(200,200,200, 0.6);&#125;&lt;div class=\"round-boxshadow\"&gt;&lt;/div&gt;&lt;!-- 椭圆，水平半径和垂直半径分别是宽高的一半 --&gt;.ellipse&#123; width: 100px; height: 50px; background-color: #999; text-align: center; border-radius: 50px/25px;&#125;&lt;div class=\"ellipse\"&gt;&lt;/div&gt; 2、相关三角形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!-- 向上三角形 --&gt;.triangle-up&#123; width: 0px; height: 0px; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red;&#125;&lt;div class=\"triangle-up\"&gt;&lt;/div&gt;&lt;!-- 向下三角形 --&gt;.triangle-down&#123; width: 0px; height: 0px; border-top: 100px solid red; border-left: 50px solid transparent; border-right: 50px solid transparent;&#125;&lt;div class=\"triangle-down\"&gt;&lt;/div&gt;&lt;!-- 向左三角形 --&gt;.triangle-left&#123; width: 0px; height: 0px; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent;&#125;&lt;div class=\"triangle-left\"&gt;&lt;/div&gt;&lt;!-- 向右三角形 --&gt;.triangle-right&#123; width: 0px; height: 0px; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent;&#125;&lt;div class=\"triangle-right\"&gt;&lt;/div&gt;&lt;!-- 左上角三角形，常见置顶标志 --&gt;.triangle-topleft&#123; width: 0px; height: 0px; border-top: 100px solid red; border-right: 100px solid transparent;&#125;&lt;div class=\"triangle-topleft\"&gt;&lt;/div&gt;&lt;!-- 右上角三角形 --&gt;.triangle-topright &#123; width: 0px; height: 0px; border-top: 100 solid red; border-left: 100 solid transparent;&#125;&lt;div class=\"triangle-topright\"&gt;&lt;/div&gt;&lt;!-- 左底角三角形 --&gt;.triangle-bottomleft &#123; width: 0px; height: 0px; border-bottom: 100px solid red; border-right: 100px solid transparent;&#125;&lt;div class=\"triangle-bottomleft\"&gt;&lt;/div&gt;&lt;!-- 右底角三角形 --&gt;.triangle-bottomright &#123; width: 0px; height: 0px; border-bottom: 100px solid red; border-left: 100px solid transparent;&#125;&lt;div class=\"triangle-bottomright\"&gt;&lt;/div&gt;&lt;!-- 提示对话框 --&gt;.talkbubble&#123; width: 200px; height: 100px; background-color: red; position: relative; left: 100px; border-radius: 10px; padding: 5px 10px;&#125;.talkbubble:before&#123; width: 0; height: 0; right: 100%; top: 30px; position: absolute; content: \"\"; border-top: 15px solid transparent; border-right: 30px solid red; border-bottom: 15px solid transparent;&#125;&lt;div class=\"talkbubble\"&gt; 测试文本测试文本测试文本测试文本测试文本&lt;/div&gt; 3、相关多边形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!-- 平行四边形，利用transform：skew 向x轴偏移 --&gt;.parallelogram &#123; width: 100px; height: 50px; margin-left: 30px; transform: skew(-30deg); background-color: red;&#125;&lt;div class=\"parallelogram\"&gt;&lt;/div&gt;&lt;!-- 梯形，类似各个朝向的三角形，只是把中间宽度撑开 --&gt;.trapezoid &#123; border-bottom: 100px solid red; border-left: 50px solid transparent; border-right: 50px solid transparent; width: 100px; height: 0px;&#125;&lt;div class=\"trapezoid\"&gt;&lt;/div&gt;&lt;!-- 五角星 --&gt;.star-five &#123; width: 0; height: 0; color: red; margin: 50px; position: relative; display: block; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 35px solid red; transform:rotate(35deg);&#125;.star-five:before &#123; width: 0; height: 0; border-left: 15px solid transparent; border-right: 15px solid transparent; border-bottom: 40px solid red; position: absolute; top: -25px; left: -35px; color: white; display: block; content: \"\"; transform:rotate(-35deg);&#125;.star-five:after &#123; width: 0; height: 0; display: block; position: absolute; color: red; top: 3px; left: -55px; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 35px solid red; content: \"\"; transform:rotate(-70deg);&#125;&lt;div class=\"star-five\"&gt;&lt;/div&gt;&lt;!-- 五边形 --&gt;.pentagon &#123; width: 54px; position: relative; border-width: 50px 18px 0; border-style: solid; border-color: red transparent; margin: 50px;&#125;.pentagon:before &#123; content: \"\"; position: absolute; width: 0; height: 0; top: -85px; left: -18px; border-width: 0 45px 35px; border-style: solid; border-color: transparent transparent red;&#125;&lt;div class=\"pentagon\"&gt;&lt;/div&gt;&lt;!-- 六边形 --&gt;.hexagon &#123; width: 100px; height: 55px; background-color: red; position: relative; margin: 50px;&#125;.hexagon:before &#123; content: \"\"; position: absolute; top: -25px; left: 0; width: 0; height: ; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 25px solid red;&#125;.hexagon:after &#123; content: \"\"; left: 0; width: 0; height: 0; bottom: -25px; position: absolute; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 25px solid red;&#125;&lt;div class=\"hexagon\"&gt;&lt;/div&gt;","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"webpack小结","date":"2019-01-05T03:25:11.000Z","path":"2019/01/05/webpack小结/","text":"此文主要是为了举例 webpack 的一些简单使用说明，它是基于 nodejs 环境。如果想更深入了解可以看webpack 中文网站 1、初始化12345// 以下命令都是在终端下执行npm install webpack -g // 全局安装webpack环境webpack --version // 查看是否有安装npm init -y // 初始化项目文件夹，增加package.json文件npm install webpack -D // 局部安装， -D等价于 --save-dev 2、编写入口文件 entry.js123&lt;!-- 在项目根目录下分别新增index.html和entry.js --&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script src=\"bundle.js\"&gt;&lt;/script&gt; 12345// entry.jslet oApp = document.getElementById('app');oApp.innerHTML = '&lt;h3&gt;welcome Webpack&lt;/h3&gt;';// 终端下执行webpack entry.js bundle.js 3、loader 加载器12345678910111213141516171819202122// webpack默认只支持javascript文件，其它文件需要用加载器(loader)// loader类似一种转化器， 它可以把一个东西，转成另一个// 没有转化的情况下会提示 You may need an appropriate loader to handle this file type.// 例如css文件: style-loader 和 css-loadernpm install style-loader css-loader -D // 安装loader依赖包// entry.js文件内容let oApp = document.getElementById('app');// 注意: 在webpack中，多个loader加载用！隔开， 引入文件需要带上后缀，如果有配置resolve，可以省略后缀，例如./stylerequire('style-loader!css-loader!./style.css'); // webpack1.0可以省略-loader, 2.0不允许oApp.innerHTML = '&lt;h3&gt;welcome Webpack&lt;/h3&gt;';// 根目录下新增style.css文件body&#123; background:#399; color: #fff; font-size: 40px; text-shadow: 2px 2px 5px #000;&#125;// 终端下执行webpack entry.js bundle.js 4、配置 webpack.config.js 文件12345678910111213141516171819202122232425262728293031323334353637// 根目录下新增webpack.config.js// 如果就不用webpack.config.js,自己定义名字config.js// 终端运行需要指定文件: webpack --config config.js// webpack.config.jsmodule.exports = &#123; entry: './entry.js', // 入口文件 output: &#123; filename: 'bundle.js', // 出口 &#125;, devtool: 'source-map', // 直接生成source-map，作用跟webpack -d一样 module: &#123; loaders: [ &#123; test: /\\.css$/, loader: 'style-loader!css-loader', &#125;, ], &#125;, resolve: &#123; // \"extensions\": ['', '.js', '.css', '.json', '.jsx'] // 可以省略后缀名，注意这是webpack1.0 extensions: ['.js', '.css', '.json', '.jsx'], // 注意这是webpack2.0，不允许加上'', &#125;,&#125;;// entry.jslet oApp = document.getElementById('app');require('./style.css');oApp.innerHTML = '&lt;h3&gt;welcome Webpack&lt;/h3&gt;';// 终端下执行查看效果，这里因为配置出入口文件名，可以省略webpack;// 注意以下命令模式的区别webpack; // 开发环境下编译(打包)webpack - p; // 生产环境下编译(压缩)webpack - w; // 监听文件改动,自动编译(速度快)webpack - d; // 开启(生成)source maps(用来调试)webpack - wpd; // 同时开启多个模式 5、babel 使用转化 ES6 语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 安装相关依赖npm install babel-loader babel-core babel-preset-es2015 -D// 导出模块: export default &#123;&#125;// 引入模块: import 名字 from 模块名// 项目根目录新增module.js// module.jsexport default &#123; a: 1, b: 2&#125;// entry.jsimport modB from './module'let oApp = document.getElementById('app');require('./style.css');oApp.innerHTML = '&lt;h3&gt;welcome Webpack&lt;/h3&gt;' + (modB.a + modB.b);// webpack.config.jsmodule.exports = &#123; entry: './entry.js', // 入口文件 output: &#123; filename: 'bundle.js' // 出口 &#125;, devtool: 'source-map', // 直接生成srouce-map module: &#123; loaders: [&#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', // webpack2.0不能省略-loader exclude: /node_modules/, //排除那些目录 options: &#123; // webpack2.0写法 'presets': ['es2015'] &#125; &#125;] &#125; // babel: &#123; //webpack1.0写法 // \"presets\": ['es2015'] // &#125;&#125;;// 配置babel预设，可以直接在webpack.config.js配置，也可以新增.babelrc文件配置touch .babelrc // 在项目根目录新增一个.babelrc文件// .babelrc文件内容&#123; \"presets\":['es2015']&#125;// 终端下执行webpack查看效果webpack 6、webpack-dev-server 热加载服务12345678910111213141516171819202122232425262728293031323334353637383940// 安装热加载服务依赖npm install webpack-dev-server -g// 第一种方式开启服务，注意参数webpack-dev-server --port 8088 端口号webpack-dev-server --inline 改变完代码以后，自动刷新浏览器webpack-dev-server --hot 热重载(局部更改)// 终端下执行webpack-dev-server --inline --port 8088// 第二种方式，修改webpack.config.js配置文件module.exports = &#123; entry: './entry.js', // 入口文件 output: &#123; filename: 'bundle.js' // 出口 &#125;, devtool: 'source-map', // 直接生成srouce-map devServer: &#123; port: 8088, inline: true // 注意：不写hot: true，否则浏览器无法自动更新；也不要写colors:true，progress:true等，webpack2.x已不支持这些 &#125;, module: &#123; loaders: [&#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ // 排除那些目录 &#125;] &#125;&#125;;// 终端下执行webpack-dev-server// 第三种方式，修改package.json配置文件\"scripts\": &#123; \"dev\": \"webpack-dev-server --inline --port 8088\"&#125;// 终端下执行npm run dev 7、react 配置1234// 安装react预设和热加载npm install babel-preset-react react-hot-loader -D// 安装react环境npm install react react-dom -D 1234567&lt;!-- 新增list.js作为一个组件list.js --&gt;import React from 'react' class List extends React.Component &#123; render() &#123; return&lt;div&gt;我是React-List组件&lt;/div&gt;&#125; &#125; export &#123; List as default &#125; 1234567891011121314151617181920212223242526272829//&lt;!-- .babelrc --&gt;&#123; \"presets\":[['es2015'],['react']]&#125;//webpack.config.jsmodule.exports = &#123; entry: './entry.js', //入口文件 output: &#123; filename: 'bundle.js' //出口 &#125;, devtool: 'source-map', //直接生成srouce-map devServer: &#123; port: 8088, inline: true &#125;, module: &#123; loaders: [&#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.js$/, loader: 'react-hot-loader!babel-loader', // 注意react-hot-loader需要用旧版本1.3.0才可以 exclude: /node_modules/ // 排除那些目录 &#125;] &#125;, resolve: &#123; \"extensions\": ['.js', '.css', '.json', '.jsx'] // 可以省略后缀名 &#125;&#125;;","tags":[{"name":"工具","slug":"工具","permalink":"https://liwenxin-jam.github.io/tags/工具/"}]},{"title":"nodejs相关包使用小结","date":"2018-12-31T03:09:57.000Z","path":"2018/12/31/nodejs相关包使用小结/","text":"此文主要是为了举例 nodejs 的一些相关包用法总结，没有 nodejs 环境可以先到官网下载安装。nodejs 实质就是写 js 文件，根据一些包快速开发。这里只是列举其中一小部用法，详细的还需要各位去看看官网的 API，这里只是提供给大家做个了解。 1、http 模块12345678910111213141516171819// http模块可以创建服务器应用实例，也能发送http请求const http = require('http');// request请求 respone响应var server = http.createServer(function (req, res) &#123; // console.log(req.url); switch (req.url) &#123; case '/1.html': // statements_1 break; default: // statements_def break; &#125; res.write('abc'); // 反馈内容 res.end(); // 请求结束&#125;);// 监听--端口--数字server.listen(8081); 2、fs 模块12345678910111213141516// fs模块用于对系统文件及目录进行读写操作const fs = require('fs');// readFile(文件名，回调函数) 读文件fs.readFile('./data/a.txt', function (err, data) &#123; if (err) &#123; console.log('读取失败'); &#125; else &#123; console.log(data.toString()); &#125;&#125;);// writeFile(文件名，内容，回调函数) 写文件fs.writeFile('./data/b.txt', 'asfasfd2123asdafsd', function (err) &#123; console.log(err);&#125;); 3、querystring 模块1234567891011&lt;!-- querystring从字面上的意思就是查询字符串,一般是对http请求所带的数据进行解析form.html get请求 --&gt;&lt;body&gt; &lt;form action=\"http://localhost:8081\" method=\"get\"&gt; 用户：&lt;input type=\"text\" name=\"user\" value=\"\" /&gt; &lt;br /&gt; 密码：&lt;input type=\"password\" name=\"pass\" value=\"\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt; 123456789101112131415161718192021// server.jsconst http = require('http');const querystring = require('querystring');http .createServer(function (req, res) &#123; // req获取前台的数据 console.log(req.url); var GET = &#123;&#125;; var url = req.url; if (req.url.indexOf('?') != -1) &#123; var arr = req.url.split('?'); url = arr[0]; GET = querystring.parse(arr[1]); &#125; console.log(url, GET); res.write('aaa'); res.end(); &#125;) .listen(8081); 12345678&lt;!-- form.html post请求 --&gt;&lt;body&gt; &lt;form action=\"http://localhost:8081\" method=\"post\"&gt; 用户：&lt;input type=\"text\" name=\"user\" value=\"\" /&gt; &lt;br /&gt; 密码：&lt;input type=\"password\" name=\"pass\" value=\"\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt; 1234567891011121314151617// server.jsconst http = require('http');http .createServer(function (req, res) &#123; var str = ''; // 接收数据 // data 有一段数据多次到达，当数据量大自动帮切段 var i = 0; req.on('data', function (data) &#123; console.log(`第$&#123;i++&#125;次收到数据`); str += data; &#125;); // data 数据全部到达（一次） req.on('end', function (data) &#123; console.log(str); &#125;); &#125;) .listen(8081); 4、url 模块1234567891011121314151617// 用于URL解析、处理等操作const http = require('http');const urlLib = require('url');http .createServer(function (req, res) &#123; // req获取前台的数据 console.log(req.url); var obj = urlLib.parse(req.url, true); // 为true时将使用查询模块分析查询字符串，默认为false var url = obj.pathname; var GET = obj.query; console.log(url, GET); res.write('aaa'); res.end(); &#125;) .listen(8081); 5、express 模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const express = require('express');const expressStatic = require('express-static');var server = express();server.get('/', function () &#123; console.log('有get请求');&#125;);server.post('/', function () &#123; console.log('有post请求');&#125;);server.use('/', function () &#123; console.log('有use');&#125;);server.use('/a.html', function (req, res) &#123; res.send('abc'); res.end();&#125;);server.use('/b.html', function (req, res) &#123; res.send('123'); res.end();&#125;);var users = &#123; xx: '123456', cc: '789012',&#125;;server.listen(8081);server.get('/login', function (req, res) &#123; // var user = req.query; var user = req.query['user']; var pass = req.query['pass']; if (users[user] == null) &#123; res.send(&#123; ok: false, msg: '此用户不存在' &#125;); &#125; else &#123; if (users[user] != pass) &#123; res.send(&#123; ok: false, msg: '密码错误' &#125;); &#125; else &#123; res.send(&#123; ok: true, msg: '成功' &#125;); &#125; &#125;&#125;);server.use(expressStatic('./www'));// express_router路由const express = require('express');var server = express();//目录 /user/var routerUser = express.Router();routerUser.get('/1.html', function (req, res) &#123; res.send('user111');&#125;);routerUser.get('/2.html', function (req, res) &#123; res.send('user222');&#125;);server.use('/user', routerUser);// 目录2 /article/var articleRouter = express.Router();articleRouter.get('/1001.html', function (req, res) &#123; res.send('adfasdfasdfaf');&#125;);server.use('/article', articleRouter);server.listen(8081); 6、body-parser 模块 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据 123456789101112131415161718const express = require('express');const bodyParser = require('body-parser');var server = express();server.listen(8081);// 在这里帮你包装了req.body，form表单提交get用req.query。提交post方式用req.body// 有两个参数 extended 拓展 limit 限制server.use(bodyParser.urlencoded(&#123;&#125;));// server.use(bodyParser.urlencoded(&#123;// extended: true, //拓展模式// limit: 2*1024*1024 //默认100KB，限制成2MB// &#125;));server.use('/', function (req, res) &#123; console.log(req.body);&#125;); 7、cookie-parser 和 cookie-session 模块 解析 Cookie 的工具，通过 req.cookies 可以取到传过来的 cookie，并把它们转成对象。 1234567891011121314151617181920212223242526272829303132333435363738394041const express = require('express');const cookieParser = require('cookie-parser');const cookieSession = require('cookie-session');var server = express();// cookie// server.use(cookieParser(sdfasdfasdfasd)); //签名密钥server.use(cookieParser());server.use( cookieSession(&#123; name: 'sess', keys: ['aaa', 'bbb', 'ccc'], //加密数组，越多越难破解 maxAge: 2 * 3600 * 1000, &#125;));server.use('/aaa/a.html', function (req, res) &#123; // res.cookie('test', 'xxlai'); //可以带参数 // res.cookie('test', 'xxlai', &#123;path: '/aaa', maxAge: 30*24*3600*1000&#125;); // 某个路径下才可以访问cookie，过期时间30天 req.secret = 'sdfasdfasdfasd'; // 加密，签名密钥 res.cookie('test', 'xxlai', &#123; signed: true &#125;); // 签名不能加密，但可以防止篡改值 // console.log(req.cookies); console.log('签名cookies:', req.signedCookies); console.log('无签名cookies:', req.cookies); if (req.session['count'] == null) &#123; req.session['count'] = 1; &#125; else &#123; req.session['count']++; &#125; console.log(req.session['count']); // delete req.session['count']; //删除 res.send('ok');&#125;);server.listen(8081); 8、ejs 和 jade 模板引擎123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 我的名字叫：&lt;%= name %&gt; &lt;% for(var i=0; i&lt;json.arr.length; i++) &#123; %&gt; &lt;div&gt;用户名： &lt;%= json.arr[i].user %&gt; 密码: &lt;% json.arr[i].pass %&gt;&lt;/div&gt; &lt;% &#125; %&gt; &lt;% var str = \"&lt;div&gt;&lt;/div&gt;\" %&gt; &lt;%- str %&gt; &lt;% include ../a.txt %&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// ejs.jsconst ejs = require('ejs');// 可以传参渲染模板，=代表是转义输出，-代表不转义输出ejs.renderFile('./views/1.ejs', &#123;name: 'xxlai'&#125;, function(err, data)&#123; if(err) console.log('编辑失败', err); else console.log(data);&#125;);// test.jadedoctypehtml head meta(charset=\"utf-8\") title jade测试页面 body// jade.jsconst jade = require('jade');const fs = require('fs');// var str = jade.render('html'); //生成 &lt;html&gt;&lt;/html&gt;// 1、jade模板引擎以每行缩进作为层级关系// 2、属性放在（）里，逗号分隔// 3、内容空一格，直接往后堆// 4、.点代表原样输出 类似style.// 5、数据传递模板用#&#123;name&#125;,style和css特殊，可省略 ， span #&#123;a&#125;等价于 span=a// 6、|开头的代表不是标签，原样输出// 7、-开头的跟|类似，代表的也不是标签，表示这是代码，不输出。可做for循环使用。 可以只写一个-代表接下来的都是代码。不转义，有点区别=// 8、加!代表不需要转义 div!=contentvar str = jade.renderFile('./views/1.jade', &#123;pretty: true, name: 'xxlai', a: 12, b: 5, json: &#123;width: '200px', height: '200px', background: 'red'&#125;, arr: ['aaa', 'bbb', 'ccc'], content: '&lt;h2&gt;title&lt;/h2&gt;&lt;p&gt;asdlkfjalsadfaf&lt;/p&gt;'&#125;); // pretty格式化排版console.log(str);fs.writeFile('./build/output.html', str, function(err)&#123; if(err) console.log('写入失败'); else console.log('写入成功');&#125;) 9、multer 和 path 模块 作为中间件进行数据处理，例如对附件上传下载。 123456789101112&lt;!-- upload.html --&gt;&lt;body&gt; &lt;!-- 注意enctype有3种值，这里是用multipart --&gt; &lt;form action=\"http://localhost:8080/\" method=\"post\" enctype=\"multipart/form-data\" &gt; 文件：&lt;input type=\"file\" name=\"f1\" /&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"上传\" /&gt; &lt;/form&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526// upload.jsconst express = require('express');const bodyParser = require('body-parser');const multer = require('multer');const fs = require('fs');const pathLib = require('path');var objMulter = multer(&#123; dest: './www/upload/' &#125;);var server = express();// 错误// server.use(bodyParser.urlencoded(&#123;extended: false&#125;));server.use(objMulter.any());server.post('/', function (req, res) &#123; // 1.获取原始文件扩展名 // 2.重命名临时文件 var newName = req.files[0].path + pathLib.parse(req.files[0].originalname).ext; fs.rename(req.files[0].path, newName, function (err) &#123; if (err) res.send('上传失败'); else res.send('成功'); &#125;);&#125;);server.listen(8080); 10、consolidate 模块 consolidate 模块可以说是一个各种模板引擎的结合体。它包括了我们之前的 jade 和 ejs。通过配置就可以使用多种模板引擎。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const express = require('express');const static = require('express-static');const cookieParser = require('cookie-parser');const cookieSession = require('cookie-session');const bodyParser = require('body-parser');const multer = require('multer');const consolidate = require('consolidate');var server = express();server.listen(8080);// 1.解析cookieserver.use(cookieParser('sdfasl43kjoifguokn4lkhoifo4k3'));// 2.使用sessionvar arr = [];for (var i = 0; i &lt; 100000; i++) &#123; arr.push('keys_' + Math.random());&#125;server.use( cookieSession(&#123; name: 'zns_sess_id', keys: arr, maxAge: 20 * 3600 * 1000 &#125;));// 3.post数据server.use(bodyParser.urlencoded(&#123; extended: false &#125;));server.use(multer(&#123; dest: './www/upload' &#125;).any());// 4、配置模板引擎// 输出什么东西server.set('view engine', 'html');// 模板文件放在哪儿server.set('views', './views');// 哪种模板引擎server.set('html', consolidate.ejs);// 用户请求// server.use('/', function (req, res, next)&#123;// console.log(req.query, req.body, req.files, req.cookies, req.session);// &#125;);// 接收用户请求server.use('/index', function (req, res) &#123; res.render('1.ejs', &#123; name: 'xxlai' &#125;);&#125;);// 4.static数据server.use(static('./www')); 11、mysql 模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const express=require('express');consot mysql = require('mysql');var server=express();server.listen(8080);// 连接数据库// createConection(哪台服务器， 用户名， 密码， 库)var db = mysql.createConection(&#123; host: 'localhost', port: '3306' user: 'test', password: '123456', database: 'jeecg'&#125;);// 连接池 可以限制连接数，不用一直保持连接//createPool(哪台服务器， 用户名， 密码， 库)// var db = mysql.createPool(&#123;// host: 'localhost',// port: '3306'// user: 'test',// password: '123456',// database: 'jeecg'// &#125;);console.log(db);// 2、查询// query(干什么， 回调函数)db.query('select * from user_table;', (err, data) =&gt; &#123; if(err) console.log('出错了', err); else console.log('成功了', data);&#125;);// 接收用户请求，链式操作，next()走下一个步骤server.get('/', (req, res, next)=&gt;&#123; // 查询banner的东西 db.query(\"SELECT * FROM banner_table\", (err, data)=&gt;&#123; if(err)&#123; res.status(500).send('database error').end(); &#125;else&#123; res.banners=data; next(); &#125; &#125;);&#125;);server.get('/', (req, res, next)=&gt;&#123; // 查询文章列表 db.query('SELECT ID,title,summery FROM article_table', (err, data)=&gt;&#123; if(err)&#123; res.status(500).send('database error').end(); &#125;else&#123; res.articles=data; next(); &#125; &#125;);&#125;);server.get('/', (req, res)=&gt;&#123; res.render('index.ejs', &#123;banners: res.banners, articles: res.articles&#125;);&#125;);server.get('/article', (req, res)=&gt;&#123; res.render('conText.ejs', &#123;&#125;);&#125;); 12、package 管理 如果你觉得你有比较包可以提供给其它人使用，可以上传到这里。你只需要注册个帐户即可，可以发布和删除。 注意有版本号区别。 123456789101112131415161718192021// 平常自己写模块化管理，需要注意引入问题，需要添加\"./\"，对外输出东西必须加给exports// require 1.如果有\"./\" 从当前目录找 2.如果没有\"./\" 先从系统模块，再从node_modules找// 如果对npm命令不太熟悉，可以打npm help查看相关指令// 常用命令：// npm install 名字 安装// npm uninstall 名字 卸载// 1.注册、登录用户 npm adduser npm login// 2.检查 npm whoami// 3.建立package npm init// 4.发布 npm publish *再次发布——加版本号，每次发布需要修改版本号以作区分// 5.删除发布 npm --force unpulish // 删除当前版本号，根据package.json里指定 npm unpublish 名字 --force // 删除整个包，慎重","tags":[{"name":"后端","slug":"后端","permalink":"https://liwenxin-jam.github.io/tags/后端/"}]},{"title":"vuex实践","date":"2018-11-22T13:24:32.000Z","path":"2018/11/22/vuex实践/","text":"此文主要为了举例说明 vue2.0 配合使用 vuex，具体文档可以参考vuex 官网 1、初始化12345mkdir vue-vuex-democd vue-vuex-demovue init webpack-simple vuex-test-demonpm installnpm install vuex -D 2、新建相关文件夹和文件 项目根目录 src 下新增 store 文件夹 sotre 文件夹下新增 index.js、getters.js、actions.js、mutations.js、types.js 等文件 注意 index.js 不是固定的，可以是其它名字，只是 import store 文件夹内容的时候默认会去找 index.js 3、编写 store 相关内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// types.js内容export const INCREMENT = 'INCREMENT';export const DECREMENT = 'DECREMENT';// actions.js内容import * as types from './types';export default &#123; increment: (&#123; commit &#125;) =&gt; &#123; commit(types.INCREMENT); &#125;, decrement: (&#123; commit &#125;) =&gt; &#123; commit(types.DECREMENT); &#125;, clickOdd: (&#123; commit, state &#125;) =&gt; &#123; if (state.mutations.count % 2 == 0) &#123; commit(types.INCREMENT); &#125; &#125;, clickAsync: (&#123; commit &#125;) =&gt; &#123; new Promise((resolve) =&gt; &#123; setTimeout(function () &#123; commit(types.INCREMENT); &#125;, 1000); &#125;); &#125;,&#125;;// getter.jsexport default &#123; count: (state) =&gt; &#123; return state.count; &#125;, getOdd: (state) =&gt; &#123; return state.count % 2 == 0 ? '偶数' : '奇数'; &#125;,&#125;;// mutations.jsimport &#123; INCREMENT, DECREMENT &#125; from './types';import getters from './getters';const state = &#123; count: 20,&#125;;const mutations = &#123; [INCREMENT](state) &#123; state.count++; &#125;, [DECREMENT](state) &#123; state.count--; &#125;,&#125;;export default &#123; state, mutations, getters,&#125;;// index.jsimport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);import mutations from './mutations';import actions from './actions';export default new Vuex.Store(&#123; modules: &#123; mutations, &#125;, actions,&#125;); 4、引入 store 在入口文件 main.js 引入 store，注意这里默认找的是 index.js，可以命名其它然后指定引用。 1234567import store from './store/';new Vue(&#123; store, el: '#app', render: (h) =&gt; h(App),&#125;); 5、使用 vuex 在你需要用的 vue 文件引入，例如在 App.vue。 1234567891011121314151617181920&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h3&gt;welcome vuex-demo&lt;/h3&gt; &lt;input type=\"button\" value=\"增加\" @click=\"increment\" /&gt; &lt;input type=\"button\" value=\"减少\" @click=\"decrement\" /&gt; &lt;input type=\"button\" value=\"偶数才能点击+\" @click=\"clickOdd\" /&gt; &lt;input type=\"button\" value=\"点击异步\" @click=\"clickAsync\" /&gt; &lt;div&gt;现在数字为: &#123;&#123;count&#125;&#125;, 它现在是 &#123;&#123;getOdd&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapGetters, mapActions &#125; from 'vuex'; export default &#123; computed: mapGetters(['count', 'getOdd']), methods: mapActions(['increment', 'decrement', 'clickOdd', 'clickAsync']), &#125;;&lt;/script&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://liwenxin-jam.github.io/tags/框架/"}]},{"title":"vue2.0自定义组件","date":"2018-10-24T01:24:09.000Z","path":"2018/10/24/vue2.0自定义组件/","text":"此文主要为了举例说明 vue2.0 怎么创建自定义组件，例子用了最简单的一个 loading 加于证明。 1、初始化1234mkdir vue-component-democd vue-component-demovue init webpack-simple global-component-demonpm install 2、新建相关文件夹和文件 项目根目录 src 下新增 components 文件夹 components 文件夹下新增 loading 组件文件夹 loading 组件文件夹下新增 index.js 和 Loading.vue 注意 index.js 不是固定的，可以是其它名字，只是 import loading 文件夹内容的时候默认会去找 index.js 3、编写 loading 组件相关内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!-- Loading.vue内容 --&gt;&lt;template&gt; &lt;div class=\"loader\"&gt; &lt;div class=\"loader-inner ball-spin-fade-loader\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .loader &#123; width: 80px; height: 80px; margin: 50px auto; &#125; @keyframes ball-spin-fade-loader &#123; 50% &#123; opacity: 0.3; -webkit-transform: scale(0.4); transform: scale(0.4); &#125; 100% &#123; opacity: 1; -webkit-transform: scale(1); transform: scale(1); &#125; &#125; .ball-spin-fade-loader &#123; position: relative; &#125; .ball-spin-fade-loader &gt; div:nth-child(1) &#123; top: 25px; left: 0; -webkit-animation: ball-spin-fade-loader 1s 0s infinite linear; animation: ball-spin-fade-loader 1s 0s infinite linear; &#125; .ball-spin-fade-loader &gt; div:nth-child(2) &#123; top: 17.04545px; left: 17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.12s infinite linear; animation: ball-spin-fade-loader 1s 0.12s infinite linear; &#125; .ball-spin-fade-loader &gt; div:nth-child(3) &#123; top: 0; left: 25px; -webkit-animation: ball-spin-fade-loader 1s 0.24s infinite linear; animation: ball-spin-fade-loader 1s 0.24s infinite linear; &#125; .ball-spin-fade-loader &gt; div:nth-child(4) &#123; top: -17.04545px; left: 17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.36s infinite linear; animation: ball-spin-fade-loader 1s 0.36s infinite linear; &#125; .ball-spin-fade-loader &gt; div:nth-child(5) &#123; top: -25px; left: 0; -webkit-animation: ball-spin-fade-loader 1s 0.48s infinite linear; animation: ball-spin-fade-loader 1s 0.48s infinite linear; &#125; .ball-spin-fade-loader &gt; div:nth-child(6) &#123; top: -17.04545px; left: -17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.6s infinite linear; animation: ball-spin-fade-loader 1s 0.6s infinite linear; &#125; .ball-spin-fade-loader &gt; div:nth-child(7) &#123; top: 0; left: -25px; -webkit-animation: ball-spin-fade-loader 1s 0.72s infinite linear; animation: ball-spin-fade-loader 1s 0.72s infinite linear; &#125; .ball-spin-fade-loader &gt; div:nth-child(8) &#123; top: 17.04545px; left: -17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.84s infinite linear; animation: ball-spin-fade-loader 1s 0.84s infinite linear; &#125; .ball-spin-fade-loader &gt; div &#123; background-color: #399; width: 15px; height: 15px; border-radius: 100%; margin: 2px; -webkit-animation-fill-mode: both; animation-fill-mode: both; position: absolute; &#125;&lt;/style&gt;//index.js内容 import LoadingComponent from './Loading.vue' const Loading = &#123;install: function(Vue)&#123; Vue.component('Loading', LoadingComponent) &#125; &#125; exportdefault Loading 4、引入全局组件 在入口文件 main.js 引入 Loading，注意这里默认找的是 index.js，可以命名其它然后指定引用。 12import Loading from './components/loading';Vue.use(Loading); 5、使用 Loading 在你需要用的模板 template 地方里直接写，它是一个全局组件，具体是否出现隐藏，通过 vuex 或者局部 data 去控制。 1&lt;Loading&gt;&lt;/Loading&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://liwenxin-jam.github.io/tags/框架/"}]},{"title":"Vue1.0与2.0的区别","date":"2018-09-17T15:01:48.000Z","path":"2018/09/17/Vue1.0与2.0的区别/","text":"本文的意义在于总结一些因为版本的更迭导致比较常见的地方引起错误，具体说明可以参考vue 官网 1、组件模板写法变更 vue2.0 不在支持片段代码，例如以下 123456789101112131415161718192021&lt;!-- 下边的组件写法在vue1.0可以正常执行，但vue2.0会给出警告，必须给他一个根节点，也就是唯一父级[Vue warn]: Component template should contain exactly one root element: --&gt;&lt;script&gt; Vue.component('my-aaa', &#123; template: '&lt;h3&gt;我是组件&lt;/h3&gt;&lt;strong&gt;我是加粗标签&lt;/strong&gt;', &#125;);&lt;/script&gt;&lt;!-- 推荐此种方式写组件，必须有根元素，包裹住所有的代码 --&gt;&lt;script&gt; Vue.component('my-aaa', &#123; template: '#aaa', &#125;);&lt;/script&gt;&lt;body&gt; &lt;template id=\"aaa\"&gt; &lt;div&gt; &lt;h3&gt;我是组件&lt;/h3&gt; &lt;strong&gt;我是加粗标签&lt;/strong&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt; 2、组件定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 使用组件必须注册[Vue warn]: Unknown custom element: &lt;my-aaa&gt; - did you register the component correctly? For recursive components, make sure to provide the \"name\" option. --&gt;&lt;script&gt; var Home = &#123; //这是2.0组件 template: '#aaa', &#125;; //Vue.extend() Vue.component('my-aaa', Home); //注册方式1&lt;/script&gt;&lt;body&gt; &lt;template id=\"aaa\"&gt; &lt;div&gt; &lt;h3&gt;我是组件&lt;/h3&gt; &lt;strong&gt;我是加粗标签&lt;/strong&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=\"box\"&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- 第二种方式 --&gt;&lt;script&gt; var Home = &#123; //这是2.0组件 template: '#aaa', &#125;; //Vue.extend() window.onload = function () &#123; new Vue(&#123; el: '#box', components: &#123; //注册方式2 aaa: Home, &#125;, &#125;); &#125;;&lt;/script&gt;&lt;body&gt; &lt;template id=\"aaa\"&gt; &lt;div&gt; &lt;h3&gt;我是组件&lt;/h3&gt; &lt;strong&gt;我是加粗标签&lt;/strong&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=\"box\"&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt; &lt;/div&gt;&lt;/body&gt; 3、生命周期vue1.0 生命周期:init createdbeforeCompilecompiledready √ -&gt; mountedbeforeDestroy destroyedvue2.0 生命周期:beforeCreate 组件实例刚刚被创建,属性都没有created 实例已经创建完成，属性已经绑定beforeMount 模板编译之前mounted 模板编译之后，代替之前 ready _beforeUpdate 组件更新之前updated 组件更新完毕 _beforeDestroy 组件销毁前destroyed 组件销毁后 1234567891011121314151617181920212223242526272829&lt;script&gt; new Vue(&#123; el: '#box', beforeCreate() &#123; console.log('组件实例刚刚被创建'); &#125;, created() &#123; console.log('实例已经创建完成'); &#125;, beforeMount() &#123; console.log('模板编译之前'); &#125;, mounted() &#123; console.log('模板编译完成'); &#125;, beforeUpdate() &#123; console.log('组件更新之前'); &#125;, updated() &#123; console.log('组件更新完毕'); &#125;, beforeDestroy() &#123; console.log('组件销毁之前'); &#125;, destroyed() &#123; console.log('组件销毁之后'); &#125;, &#125;);&lt;/script&gt; 4、重复数据循环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!-- [Vue warn]: Duplicate value found in v-for=\"val in list\": \"background\". Use track-by=\"$index\" if you are expecting duplicate values.vue1.0循环重复数据会受限制，vue2.0正常 --&gt;&lt;script&gt; window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; list: ['width', 'height', 'border'], &#125;, methods: &#123; add() &#123; this.list.push('background'); &#125;, &#125;, &#125;); &#125;;&lt;/script&gt;&lt;div id=\"box\"&gt; &lt;input type=\"button\" value=\"添加\" @click=\"add\" /&gt; &lt;ul&gt; &lt;li v-for=\"val in list\"&gt; &lt;!-- vue1.0循环需要添加 track-by=\"$index\" --&gt; &#123;&#123;val&#125;&#125; &lt;/li&gt; &lt;!-- [Vue warn]: Property or method \"$key\" is not defined on the instance but referenced during render. Make sure to declare reactive data properties in the data option. --&gt; &lt;li v-for=\"val in list\"&gt; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125; &lt;!-- vue2.0去掉了隐式一些变量 $index $key --&gt; &lt;/li&gt; &lt;li v-for=\"(index,val) in list\"&gt; &lt;!-- vue1.0循环写法v-for=\"(index,val) in array\" --&gt; &#123;&#123;val&#125;&#125; &#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;li v-for=\"(val,index) in list\"&gt; &lt;!-- vue2.0循环写法 v-for=\"(index,val) in --&gt;array\" &#123;&#123;val&#125;&#125; &#123;&#123;index&#125;&#125; &lt;!-- 倾向于js原生forEach，先写val再写index --&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!-- 提高循环性能 track-by=\"id\" 变成 :key=\"index\" --&gt;&lt;script&gt; window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; list: &#123; a: 'apple', b: 'banana', c: 'cell', &#125;, &#125;, &#125;); &#125;;&lt;/script&gt;&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li v-for=\"(val,key) in list\" :key=\"index\"&gt;&#123;&#123;val&#125;&#125; &#123;&#123;key&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 5、自定义键盘指令123456789101112131415161718&lt;script&gt; window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123;&#125;, methods: &#123; change() &#123; alert('改变了'); &#125;, &#125;, &#125;); //Vue.directive('on').keyCodes.ctrl=17; //vue1.0写法 Vue.config.keyCodes.ctrl = 17; //vue2.0写法 &#125;;&lt;/script&gt;&lt;div id=\"box\"&gt; &lt;input type=\"text\" @keyup.ctrl=\"change\" /&gt;&lt;/div&gt; 6、filter 过滤器 vue1.0 系统就自带很多过滤，例如 currency/json 等等。到了 vue2.0，作者删除全部内置过滤器，保留了自定义过滤器，但自定义过滤器传参格式有点区别。 1234567891011121314151617&lt;script&gt; Vue.filter('toDou', function (n, a, b) &#123; alert(a + ',' + b); return n &lt; 10 ? '0' + n : '' + n; &#125;); window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; msg: 9, &#125;, &#125;); &#125;;&lt;/script&gt;&lt;div id=\"box\"&gt; &#123;&#123;msg | toDou '12' '5'&#125;&#125; //vue1.0写法 &#123;&#123;msg | toDou('12','5')&#125;&#125; //vue2.0写法&lt;/div&gt; 7、组件通信 子级获取父级的数据，通过 props 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;!-- vue1.0写法，子组件可以更改父组件信息，可以是同步sync --&gt;&lt;script&gt; window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; a: '我是父组件数据', &#125;, components: &#123; 'child-com': &#123; props: ['msg'], template: '#child', methods: &#123; change() &#123; this.msg = '被更改了'; &#125;, &#125;, &#125;, &#125;, &#125;); &#125;;&lt;/script&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;span&gt;我是子组件&lt;/span&gt; &lt;input type=\"button\" value=\"按钮\" @click=\"change\" /&gt; &lt;strong&gt;&#123;&#123;msg&#125;&#125;&lt;/strong&gt; &lt;/div&gt;&lt;/template&gt;&lt;div id=\"box\"&gt; 父级: -&gt;&#123;&#123;a&#125;&#125; &lt;br /&gt; &lt;child-com :msg.sync=\"a\"&gt;&lt;/child-com&gt; &lt;!-- 需要同步更改父级需要加上.sync --&gt;&lt;/div&gt;&lt;!-- [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"msg\" vue2.0写法跟vue1.0有点区别，不然会报以上警告。 不允许直接给父级的数据，做赋值操作处理方式 a). 父组件每次传一个对象给子组件, 对象之间引用，推荐 b). 只是不报错, mounted中转//方式a --&gt;&lt;script&gt; window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; giveData: &#123; a: '我是父组件数据', &#125;, &#125;, components: &#123; 'child-com': &#123; props: ['msg'], template: '#child', methods: &#123; change() &#123; this.msg.a = '被改了'; &#125;, &#125;, &#125;, &#125;, &#125;); &#125;;&lt;/script&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;span&gt;我是子组件&lt;/span&gt; &lt;input type=\"button\" value=\"按钮\" @click=\"change\" /&gt; &lt;strong&gt;&#123;&#123;msg.a&#125;&#125;&lt;/strong&gt; &lt;/div&gt;&lt;/template&gt;&lt;div id=\"box\"&gt; 父级: -&gt;&#123;&#123;giveData.a&#125;&#125; &lt;br /&gt; &lt;child-com :msg=\"giveData\"&gt;&lt;/child-com&gt;&lt;/div&gt;&lt;!-- 方式b --&gt;&lt;script&gt; window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; a: '我是父组件数据', &#125;, components: &#123; 'child-com': &#123; data() &#123; return &#123; b: '', &#125;; &#125;, props: ['msg'], template: '#child', mounted() &#123; this.b = this.msg; &#125;, methods: &#123; change() &#123; this.b = '被改了'; &#125;, &#125;, &#125;, &#125;, &#125;); &#125;;&lt;/script&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;span&gt;我是子组件&lt;/span&gt; &lt;input type=\"button\" value=\"按钮\" @click=\"change\" /&gt; &lt;strong&gt;&#123;&#123;b&#125;&#125;&lt;/strong&gt; &lt;/div&gt;&lt;/template&gt;&lt;div id=\"box\"&gt; 父级: -&gt;&#123;&#123;a&#125;&#125; &lt;br /&gt; &lt;child-com :msg.sync=\"a\"&gt;&lt;/child-com&gt;&lt;/div&gt;&lt;!-- 注意如果是父子级可以通过以上方式处理。如果是同级组件之间想传递数据，也就是单一事件管理，通过vm.$emit()传递，vm.$on()接收。类似vuex实现原理。格式参考：var Event=new Vue();Event.$emit(事件名称, 数据)Event.$on(事件名称,function(data)&#123; //data&#125;.bind(this));具体实现 --&gt;&lt;script&gt; //准备一个空的实例对象 var Event = new Vue(); var A = &#123; template: ` &lt;div&gt; &lt;span&gt;我是A组件&lt;/span&gt; -&gt; &#123;&#123;a&#125;&#125; &lt;input type=\"button\" value=\"把A数据给C\" @click=\"send\"&gt; &lt;/div&gt; `, methods: &#123; send() &#123; Event.$emit('a-msg', this.a); &#125;, &#125;, data() &#123; return &#123; a: '我是a数据', &#125;; &#125;, &#125;; var B = &#123; template: ` &lt;div&gt; &lt;span&gt;我是B组件&lt;/span&gt; -&gt; &#123;&#123;a&#125;&#125; &lt;input type=\"button\" value=\"把B数据给C\"&gt; &lt;/div&gt; `, data() &#123; return &#123; a: '我是b数据', &#125;; &#125;, &#125;; var C = &#123; template: ` &lt;div&gt; &lt;h3&gt;我是C组件&lt;/h3&gt; &lt;span&gt;接收过来的A的数据为: &#123;&#123;a&#125;&#125;&lt;/span&gt; &lt;/div&gt; `, data() &#123; return &#123; a: '', b: '', &#125;; &#125;, mounted() &#123; //var _this=this; Event.$on( 'a-msg', function (a) &#123; this.a = a; &#125;.bind(this) ); &#125;, &#125;; window.onload = function () &#123; new Vue(&#123; el: '#box', components: &#123; 'com-a': A, 'com-b': B, 'com-c': C, &#125;, &#125;); &#125;;&lt;/script&gt;&lt;div id=\"box\"&gt; &lt;com-a&gt;&lt;/com-a&gt; &lt;com-b&gt;&lt;/com-b&gt; &lt;com-c&gt;&lt;/com-c&gt;&lt;/div&gt; 8、动画 动画如果有结合 animate,相关配置参数和效果查看可以参考animate 官网 vue1.0 写法，transition 是属性 1&lt;p transition=\"fade\"&gt;&lt;/p&gt; 处理好 fade 相关样式就可以实现动画效果.fade-transition{}.fade-enter{}.fade-leave{} vue2.0 写法，transition 变成了组件，需要把要做动画的包起来，一般是包 router-view 1&lt;transition name=\"fade\"&gt; 运动东西(元素，属性、路由....) &lt;/transition&gt; class 定义:.fade-enter-active,.fade-leave-active{transition:1s all ease;}.fade-enter{} //初始状态.fade-enter-active{} //变化成什么样 -&gt; 当元素出来(显示).fade-leave{}.fade-leave-active{} //变成成什么样 -&gt; 当元素离开(消失) 动画可以配合 animate.css 使用，把 fade 和 name 去掉。给 transition 加 enter-active-class=”zoomInleft” leave-active-class=”zoomOutRight”,给运动的元素本身加 class=”animated”。 123456&lt;transition enter-active-class=\"animated zoomInLeft\" leave-active-class=\"animated zoomOutRight\"&gt; &lt;p v-show=\"show\"&gt;&lt;/p&gt;&lt;/transition&gt; 多个元素运动需要使用 transition-group，并且把每个运动元素加个：key=”index”: 1234&lt;transition-group enter-active-class=\"\" leave-active-class=\"\"&gt; &lt;p :key=\"\"&gt;&lt;/p&gt; &lt;p :key=\"\"&gt;&lt;/p&gt;&lt;/transition-group&gt; 9、vue-routervue1.0 写法： 1&lt;a v-link=\"&#123;path:'/home'&#125;\"&gt;我是主页&lt;/a&gt; router.rediect //重定向 2.0 废弃了subRoutes //路由嵌套用 subRoutes，配置跟父级一样是 json vue2.0 写法： 12&lt;router-link to=\"/home\"&gt;我是主页&lt;/router-link&gt;&lt;!-- 它会自动解析成a v-link形式 --&gt; const routes = [ //配置路由{path:’/home’,component:Home}，{path:’*’,redirect:’/home’} //重定向…一个个 json];children //路由嵌套用 children，配置跟父级一样是 json 路由实例方法:router.push({path:’home’}); //直接添加一个路由,表现切换路由，本质往历史记录里面添加一个router.replace({path:’news’}) //替换路由，不会往历史记录里面添加 带有参数的路由配置 12345&lt;ul&gt; &lt;li&gt;&lt;router-link to=\"/user/strive/age/10\"&gt;Strive&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/user/blue/age/80\"&gt;Blue&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/user/eric/age/70\"&gt;Eric&lt;/router-link&gt;&lt;/li&gt;&lt;/ul&gt; 配置路由 123456789const routes = [ &#123; path: '/home', component: Home &#125;, &#123; path: '/user', component: User, children: [&#123; path: ':username/age/:age', component: UserDetail &#125;], &#125;, &#123; path: '*', redirect: '/home' &#125;, //找不到的页面全部重定向到home,相当于404];","tags":[{"name":"框架","slug":"框架","permalink":"https://liwenxin-jam.github.io/tags/框架/"}]},{"title":"Vue1.0学习小结2","date":"2018-08-05T02:18:13.000Z","path":"2018/08/05/Vue1.0学习小结2/","text":"vue 是一个 mvvm 框架(库)，它和 angular 类似，但相对比较容易上手、小巧。具体详情可以查阅vue 官网 1.生命周期 用 Vue 框架，熟悉它的生命周期可以让开发更好的进行。这里借助一个图片说明一下生命周期的钩子函数。 123456789101112131415161718192021222324252627282930&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; msg: 'well', &#125;, created: function () &#123; alert('实例已经创建'); &#125;, beforeCompile: function () &#123; alert('编译之前'); &#125;, compiled: function () &#123; alert('编译之后'); &#125;, ready: function () &#123; alert('插入到文档中'); &#125;, beforeDestroy: function () &#123; alert('销毁之前'); &#125;, destroyed: function () &#123; alert('销毁之后'); &#125;, &#125;); /*点击页面销毁vue对象*/ document.onclick = function () &#123; vm.$destroy(); &#125;;&lt;/script&gt; 2.计算属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- computed里面可以放置一些业务逻辑代码，一定记得return --&gt;&lt;div id=\"box\"&gt; a =&gt; &#123;&#123;a&#125;&#125; &lt;br /&gt; b =&gt; &#123;&#123;b&#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; a: 1, &#125;, computed: &#123; b: function () &#123; //业务逻辑代码 return this.a + 1; &#125;, &#125;, &#125;); document.onclick = function () &#123; vm.a = 101; &#125;;&lt;/script&gt;&lt;!-- computed里的属性默认也可以接收对象，有set和get方法 --&gt;&lt;div id=\"box\"&gt; a =&gt; &#123;&#123;a&#125;&#125; &lt;br /&gt; b =&gt; &#123;&#123;b&#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; a: 1, &#125;, computed: &#123; b: &#123; get: function () &#123; return this.a + 2; &#125;, set: function (val) &#123; this.a = val; &#125;, &#125;, &#125;, &#125;); document.onclick = function () &#123; vm.b = 10; &#125;;&lt;/script&gt; 3.自定义方法和属性123456789101112var vm = new Vue(&#123; aa: 11, //自定义属性, show: function () &#123; alert(1); &#125;, data: &#123; a: 1, &#125;,&#125;).$mount('#box');vm.$options.show();console.log(vm.$options.aa);console.log(vm.$log()); //可以相当于查看vm.$data 4.数据监听 可以在数据发生变化的时候监测处理，类似 angular1 的脏处理 a、vm.$watch(name,fnCb); //浅度监听针对基本值类型 b、vm.$watch(name,fnCb,{deep:true}); //深度监视，可以处理 json 对象 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"box\"&gt; &#123;&#123;a&#125;&#125; &lt;br /&gt; &#123;&#123;b&#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; a: 111, b: 2, &#125;, &#125;); vm.$watch('a', function () &#123; alert('发生变化了'); this.b = this.a + 100; &#125;);&lt;/script&gt;&lt;!-- 深度监听，添加deep=true --&gt;&lt;div id=\"box\"&gt; &#123;&#123;json | json&#125;&#125; &lt;br /&gt; &#123;&#123;b&#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; json: &#123; name: 'strive', age: 16 &#125;, b: 2, &#125;, &#125;); vm.$watch( 'json', function () &#123; alert('发生变化了'); &#125;, &#123; deep: true &#125; ); document.onclick = function () &#123; vm.json.name = 'aaa'; &#125;;&lt;/script&gt; 5.动画 vue 动画有格式参考，例如想加 fade 动画效果，可以有 fade-transition/fade-enter/fade-leave 等，不过如果想弄点好看点，建议配合 animate.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;style&gt; .fade-transition &#123; transition: 1s all ease; &#125; .fade-enter &#123; opacity: 0; &#125; .fade-leave &#123; opacity: 0; transform: translateX(200px); &#125;&lt;/style&gt;&lt;div id=\"box\"&gt; &lt;input type=\"button\" value=\"按钮\" @click=\"toggle\" /&gt; &lt;div id=\"div1\" v-show=\"bSign\" transition=\"fade\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#box', data: &#123; bSign: true, &#125;, methods: &#123; toggle() &#123; this.bSign = !this.bSign; &#125;, &#125;, &#125;);&lt;/script&gt;&lt;!-- 引进animate.css --&gt;&lt;div id=\"box\"&gt; &lt;input type=\"button\" value=\"按钮\" @click=\"toggle\" /&gt; &lt;div id=\"div1\" class=\"animated\" v-show=\"bSign\" transition=\"bounce\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#box', data: &#123; bSign: true, &#125;, methods: &#123; toggle() &#123; this.bSign = !this.bSign; &#125;, &#125;, transitions: &#123; //定义所有动画名称 bounce: &#123; enterClass: 'zoomInLeft', leaveClass: 'zoomOutRight', &#125;, &#125;, &#125;);&lt;/script&gt; 6.组件 使用组件的方式有多种，还可以嵌套（父子级）。如果想了解组件之间的关系，可以安装 vue-devtools 插件，它可以从 chrome 商店直接下载安装。不过要注意的一点就是，需要翻墙才能下载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240&lt;!-- 全局组件， extend方式 --&gt;&lt;div id=\"box\"&gt; &lt;aaa&gt;&lt;/aaa&gt;&lt;/div&gt;&lt;script&gt; var Aaa = Vue.extend(&#123; template: '&lt;h3&gt;我是标题3&lt;/h3&gt;', &#125;); Vue.component('aaa', Aaa); //注册组件&lt;/script&gt;&lt;!-- 局部组件，extend方式 --&gt;&lt;div id=\"box\"&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt;&lt;/div&gt;&lt;script&gt; var Aaa = Vue.extend(&#123; template: '&lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;', data() &#123; return &#123; msg: 'ddddd', &#125;; &#125;, &#125;); var vm = new Vue(&#123; el: '#box', components: &#123; //局部组件 'my-aaa': Aaa, &#125;, &#125;);&lt;/script&gt;&lt;!-- 局部组件，components方式 --&gt;&lt;div id=\"box\"&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', components: &#123; 'my-aaa': &#123; data() &#123; return &#123; msg: 'welcome vue', &#125;; &#125;, methods: &#123; change() &#123; this.msg = 'changed'; &#125;, &#125;, template: '&lt;h2 @click=\"change\"&gt;标题2-&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;', &#125;, &#125;, &#125;);&lt;/script&gt;&lt;!-- 全局组件，components方式 --&gt;&lt;div id=\"box\"&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-aaa', &#123; template: '&lt;strong&gt;好&lt;/strong&gt;', &#125;); var vm = new Vue(&#123; el: '#box', &#125;);&lt;/script&gt;&lt;!-- 模板方式，使用script，类似backbone --&gt;&lt;div id=\"box\"&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt;&lt;/div&gt;&lt;script type=\"x-template\" id=\"aaa\"&gt; &lt;h2 @click=\"change\"&gt;标题2-&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', components: &#123; 'my-aaa': &#123; data() &#123; return &#123; msg: 'welcome vue', &#125;; &#125;, methods: &#123; change() &#123; this.msg = 'changed'; &#125;, &#125;, template: '#aaa', &#125;, &#125;, &#125;);&lt;/script&gt;&lt;!-- 模板方式，使用template --&gt;&lt;div id=\"box\"&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt;&lt;/div&gt;&lt;template id=\"aaa\"&gt; &lt;h1&gt;标题1&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=\"val in arr\"&gt;&#123;&#123;val&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', components: &#123; 'my-aaa': &#123; data() &#123; return &#123; msg: 'welcome vue', arr: ['apple', 'banana', 'orange'], &#125;; &#125;, methods: &#123; change() &#123; this.msg = 'changed'; &#125;, &#125;, template: '#aaa', &#125;, &#125;, &#125;);&lt;/script&gt;&lt;!-- 动态切换组件，利用is特性 --&gt;&lt;div id=\"box\"&gt; &lt;input type=\"button\" @click=\"a='aaa'\" value=\"aaa组件\" /&gt; &lt;input type=\"button\" @click=\"a='bbb'\" value=\"bbb组件\" /&gt; &lt;component :is=\"a\"&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; a: 'aaa', &#125;, components: &#123; aaa: &#123; template: '&lt;h2&gt;我是aaa组件&lt;/h2&gt;', &#125;, bbb: &#123; template: '&lt;h2&gt;我是bbb组件&lt;/h2&gt;', &#125;, &#125;, &#125;);&lt;/script&gt;&lt;!-- 嵌套组件（父子组件）子级获取父级数据用props，props可以用数组方式忽略类型 --&gt;&lt;template id=\"aaa\"&gt; &lt;bbb :mmm=\"msg2\" :my-msg=\"msg\"&gt;&lt;/bbb&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; a: 'aaa', &#125;, components: &#123; aaa: &#123; data() &#123; return &#123; msg: 111, msg2: '我是父组件的数据', &#125;; &#125;, template: '#aaa', components: &#123; bbb: &#123; props: ['mmm', 'myMsg'], //第一种方式，建议 // props:&#123; //第二种方式，如果有-，要写成驼峰式写法 // 'm':String, // 'myMsg':Number // &#125;, template: '&lt;h3&gt;我是bbb组件-&gt;&#123;&#123;mmm&#125;&#125; &lt;br&gt; &#123;&#123;myMsg&#125;&#125;&lt;/h3&gt;', &#125;, &#125;, &#125;, &#125;, &#125;);&lt;/script&gt;&lt;!-- 父级获取子级数据用子级主动推送数据用vm.$emit(事件名,数据) 父级用@的方式写事件接收 ，推荐此外可以用vm.$dispatch(事件名,数据) 子级向父级发送数据 vm.$broadcast(事件名,数据) 父级向子级广播数据。 配合event使用。在vue2.0里面已经废除。 --&gt;&lt;template id=\"aaa\"&gt; &lt;span&gt;我是父级 -&gt; &#123;&#123;msg&#125;&#125;&lt;/span&gt; &lt;bbb @child-msg=\"get\"&gt;&lt;/bbb&gt;&lt;/template&gt;&lt;template id=\"bbb\"&gt; &lt;h3&gt;子组件-&lt;/h3&gt; &lt;input type=\"button\" value=\"send\" @click=\"send\" /&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; a: 'aaa', &#125;, components: &#123; aaa: &#123; data() &#123; return &#123; msg: 111, msg2: '我是父组件的数据', &#125;; &#125;, template: '#aaa', methods: &#123; get(msg) &#123; // alert(msg); this.msg = msg; &#125;, &#125;, components: &#123; bbb: &#123; data() &#123; return &#123; a: '我是子组件的数据', &#125;; &#125;, template: '#bbb', methods: &#123; send() &#123; this.$emit('child-msg', this.a); &#125;, &#125;, &#125;, &#125;, &#125;, &#125;, &#125;);&lt;/script&gt; 7.slot 它的作用是作用: 占个位置，类似 ng 里面 transclude（指令），可以参考插件vue-infinite-loading 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!-- 单个slot --&gt;&lt;div id=\"box\"&gt; &lt;aaa&gt; &lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;/ul&gt; &lt;/aaa&gt; &lt;hr /&gt; &lt;aaa&gt; &lt;/aaa&gt;&lt;/div&gt;&lt;template id=\"aaa\"&gt; &lt;h1&gt;xxxx&lt;/h1&gt; &lt;slot&gt;这是默认的情况&lt;/slot&gt; &lt;p&gt;welcome vue&lt;/p&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; a: 'aaa', &#125;, components: &#123; aaa: &#123; template: '#aaa', &#125;, &#125;, &#125;);&lt;/script&gt;&lt;!-- 多个slot，用name区分 --&gt;&lt;div id=\"box\"&gt; &lt;aaa&gt; &lt;ul slot=\"ul-slot\"&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;/ul&gt; &lt;ol slot=\"ol-slot\"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ol&gt; &lt;/aaa&gt; &lt;hr /&gt; &lt;aaa&gt; &lt;/aaa&gt;&lt;/div&gt;&lt;template id=\"aaa\"&gt; &lt;h1&gt;xxxx&lt;/h1&gt; &lt;slot name=\"ol-slot\"&gt;这是默认的情况&lt;/slot&gt; &lt;p&gt;welcome vue&lt;/p&gt; &lt;slot name=\"ul-slot\"&gt;这是默认的情况2&lt;/slot&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#box', data: &#123; a: 'aaa', &#125;, components: &#123; aaa: &#123; template: '#aaa', &#125;, &#125;, &#125;);&lt;/script&gt; 8. 路由 对于单页应用，官方提供了 vue-router 进行路由跳转的处理 12345678910111213141516171819202122232425262728//vue跳转链接格式 &lt;a v-link=\"&#123;path:'/home'&#125;\"&gt;主页&lt;/a&gt;//展示内容:&lt;router-view&gt;&lt;/router-view&gt;//1. 准备一个根组件var App=Vue.extend();//2. Home News组件都准备var Home=Vue.extend(&#123; template:'&lt;h3&gt;我是主页&lt;/h3&gt;'&#125;);var News=Vue.extend(&#123; template:'&lt;h3&gt;我是新闻&lt;/h3&gt;'&#125;);//3. 准备路由var router=new VueRouter();//4. 关联router.map(&#123; 'home':&#123; component:Home &#125;, 'news':&#123; component:News &#125;&#125;);//5. 启动路由router.start(App,'#box');//6.指定默认跳转:router.redirect(&#123;‘/’:'/home'&#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!-- 路由嵌套(多层路由)，用subRoutes --&gt;&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li&gt; &lt;a v-link=\"&#123;path:'/home'&#125;\"&gt;主页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a v-link=\"&#123;path:'/news'&#125;\"&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;template id=\"home\"&gt; &lt;h3&gt;我是主页&lt;/h3&gt; &lt;div&gt; &lt;a v-link=\"&#123;path:'/home/login'&#125;\"&gt;登录&lt;/a&gt; &lt;a v-link=\"&#123;path:'/home/reg'&#125;\"&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"news\"&gt; &lt;h3&gt;我是新闻&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; //1. 准备一个根组件 var App = Vue.extend(); //2. Home News组件都准备 var Home = Vue.extend(&#123; template: '#home', &#125;); var News = Vue.extend(&#123; template: '#news', &#125;); //3. 准备路由 var router = new VueRouter(); //4. 关联 router.map(&#123; home: &#123; component: Home, subRoutes: &#123; login: &#123; component: &#123; template: '&lt;strong&gt;我是登录信息&lt;/strong&gt;', &#125;, &#125;, reg: &#123; component: &#123; template: '&lt;strong&gt;我是注册信息&lt;/strong&gt;', &#125;, &#125;, &#125;, &#125;, news: &#123; component: News, &#125;, &#125;); //5. 启动路由 router.start(App, '#box'); //6. 跳转 router.redirect(&#123; '/': 'home', &#125;);&lt;/script&gt;&lt;!-- url的path路径为 detail/001?a=1&amp;b=1参数传递router格式为'/detail/:id'，注意有冒号。接收用$route.paramspath后面？问号后边参数接收$route.query --&gt;&lt;template id=\"detail\"&gt; &#123;&#123;$route.params | json&#125;&#125; &lt;br /&gt; &#123;&#123;$route.path&#125;&#125; &lt;br /&gt; &#123;&#123;$route.query | json&#125;&#125;&lt;/template&gt;&lt;script&gt; //注意下边subRoutes参数前面的冒号 router.map(&#123; home: &#123; component: Home, subRoutes: &#123; login: &#123; component: &#123; template: '&lt;strong&gt;我是登录信息&lt;/strong&gt;', &#125;, &#125;, reg: &#123; component: &#123; template: '&lt;strong&gt;我是注册信息&lt;/strong&gt;', &#125;, &#125;, &#125;, &#125;, news: &#123; component: News, subRoutes: &#123; '/detail/:id': &#123; component: Detail, &#125;, &#125;, &#125;, &#125;);&lt;/script&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://liwenxin-jam.github.io/tags/框架/"}]},{"title":"Vue1.0学习小结1","date":"2018-07-04T13:34:55.000Z","path":"2018/07/04/Vue1.0学习小结1/","text":"vue 是一个 mvvm 框架(库)，它和 angular 类似，但相对比较容易上手、小巧。具体详情可以查阅vue 官网 vue1.x123456789101112131415161718// vue雏形 el绑定元素，可以理解是angular的controll层，data放初始化数据。// vm实例是全局，可能通过类似vm.$el/vm.$data来获取它的属性// jswindow.onload = function () &#123; // 第一种方式，利用el来绑定 var vm = new Vue(&#123; el: '#box', data: &#123; msg: 'welcome vue', &#125;, &#125;); // 第二种方式，利用$mount来挂载 var vm = new Vue(&#123; data: &#123; msg: 'welcome vue', &#125;, &#125;).$mount('#box'); // 手动挂载 vm.$mount('#box');&#125;; 12//html&lt;div id=\"box\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; 1. 常用指令 1.1 v-model 一般表单元素(input) 双向绑定，可显示文本/数组/对象，但对象会直接显示成[object Object]。 123456789101112131415&lt;!-- 注意正常绑定模型是使用&#123;&#123;msg&#125;&#125;，如果接口返回过慢，可能会导致闪烁会先显示出大括号。为了避免这种情况可以用:1、属性v-text=\"msg\"等价于&#123;&#123;msg&#125;&#125;2、增加个自定义属性v-cloak，把显示区域设为display:none。其次它有&#123;&#123;*msg&#125;&#125;和&#123;&#123;&#123;msg&#125;&#125;&#125;的用法:(1)、如果是加多一个*号，使用&#123;&#123;*msg&#125;&#125;代表只绑定赋值一次，后来模型怎么变也不我的事(2)、如果在最外层包多一层大括号，代表html转意输出。 可以这么理解&#123;&#123;msg&#125;&#125;绑定的是像jQuery的text()，而&#123;&#123;&#123;msg&#125;&#125;&#125;绑定的是像jQuery的html()，属性v-html=\"msg\"等价于&#123;&#123;&#123;msg&#125;&#125;&#125; --&gt;&lt;input type=\"text\" v-model=\"msg\" /&gt;&lt;input type=\"text\" v-model=\"msg\" /&gt;&lt;br /&gt;&#123;&#123;msg&#125;&#125;&lt;br /&gt;&#123;&#123;*msg&#125;&#125;&lt;br /&gt;&#123;&#123;&#123;msg&#125;&#125;&#125; 1.2 v-for 主要用做循环数组和 JSON 对象，数组v-for=”name in arr”和对象v-for=”name in json”都有，对象v-for=”(k,v) in json”有。 123456789window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; arr: ['apple', 'banana', 'orange', 'pear'], json: &#123; a: 'apple', b: 'banana', c: 'orange' &#125;, &#125;, &#125;);&#125;; 12345678910111213&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li v-for=\"value in arr\"&gt;&#123;&#123;value&#125;&#125; &#123;&#123;$index&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;ul&gt; &lt;li v-for=\"value in json\"&gt;&#123;&#123;value&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;ul&gt; &lt;li v-for=\"(k,v) in json\"&gt;&#123;&#123;k&#125;&#125; &#123;&#123;v&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$key&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1.3 v-show=”true/false” 显示与隐藏，默认 dom 元素不写表示 true 123456789window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; //数据 a: true, &#125;, &#125;);&#125;; 123456789101112131415161718192021&lt;div id=\"box\"&gt; &lt;input type=\"button\" value=\"按钮\" v-on:click=\"a=false\" /&gt; &lt;div style=\"width:100px; height:100px; background: red\" v-show=\"a\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 注意这里如果用v-for有重复数据的话，需要使用track-by=\"$index\"，绑定不同的序号。例如 --&gt;&lt;ul&gt; &lt;li v-for=\"val in arr\" track-by=\"$index\"&gt;&#123;&#123;val&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 自定义指令，不推荐使用元素指令，如想实现类似建议用组件的方式来。注意必须以v-开头，可以带参数 --&gt;&lt;span v-red&gt; asdfasd &lt;/span&gt;Vue.directive('red',function()&#123; this.el.style.background='red'; &#125;);&lt;!-- 带参数 --&gt;&lt;span v-red=\"a\"&gt; asdfasd &lt;/span&gt;Vue.directive('red',function(color)&#123; this.el.style.background=color; &#125;);window.onload=function()&#123; var vm=new Vue(&#123; el:'#box', data:&#123; a:'blue' &#125; &#125;); &#125;;&lt;!-- 元素指令 --&gt;&lt;div id=\"box\"&gt; &lt;zns-red&gt;asdfasdf&lt;/zns-red&gt;&lt;/div&gt;Vue.elementDirective('zns-red',&#123; bind:function()&#123;this.el.style.background='red'; &#125; &#125;); 2. 事件 v-on:click=”函数” 这里的函数调用可以直接写函数名称，不需要写括号()； v-on 可以理解为像 jQuery 一样用 on 绑定事件类型，注意事件需要写在 methods 里面去定义： v-on:click/mouseout/mouseover/dblclick/mousedown….. 它可以简写为@click=””推荐 123456789101112131415window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; //数据 arr: ['apple', 'banana', 'orange', 'pear'], json: &#123; a: 'apple', b: 'banana', c: 'orange' &#125;, &#125;, methods: &#123; show: function () &#123; alert(1); &#125;, &#125;, &#125;);&#125;; 123&lt;div id=\"box\"&gt; &lt;input type=\"button\" value=\"按钮\" v-on:click=\"show()\" /&gt;&lt;/div&gt; 事件调用可以使用$event 参数，它可以当作当前 target 来使用，例如可以用它来阻止事件冒泡/默认行为等1、阻止冒泡: a). ev.cancelBubble=true;b). @click.stop 推荐2、阻止默认行为:a). ev.preventDefault(); b). @contextmenu.prevent 推荐3、键盘值事件 例如 a). @keyup.13 b). @keyup.enter 都是回车事件 方向键的上、下、左、右 @keyup/keydown.left @keyup/keydown.right @keyup/keydown.up @keyup/keydown.down 12345678910111213141516171819//冒泡事件window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123;&#125;, methods: &#123; show: function (ev) &#123; alert(1); ev.cancelBubble = true; &#125;, show1: function () &#123; alert(1); &#125;, show2: function () &#123; alert(2); &#125;, &#125;, &#125;);&#125;; 123456&lt;div id=\"box\"&gt; &lt;div @click=\"show2()\"&gt; &lt;input type=\"button\" value=\"按钮\" @click=\"show($event)\" /&gt; &lt;input type=\"button\" value=\"按钮\" @click.stop=\"show()\" /&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516//默认行为window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123;&#125;, methods: &#123; show: function (ev) &#123; alert(1); ev.preventDefault(); &#125;, show: function () &#123; alert(1); &#125;, &#125;, &#125;);&#125;; 123456&lt;div id=\"box\"&gt; &lt;input type=\"button\" value=\"按钮\" @contextmenu=\"show($event)\" /&gt; &lt;input type=\"button\" value=\"按钮\" @contextmenu.prevent=\"show()\" /&gt; &lt;input type=\"text\" @keyup.enter=\"show()\" /&gt; &lt;!-- 你按了回车键 --&gt;&lt;/div&gt; 3. 属性 vue 绑定属性用 v-bind: 例如 v-bind:src=”” ，其它 width/height/title….也是。它可以简写成:src=”” 推荐 1234567891011//两种方式显示图片，建议用它推荐的属性绑定方式window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; url: 'https://www.baidu.com/img/bd_logo1.png', w: '200px', t: '这是一张美丽的图片', &#125;, &#125;);&#125;; 12345&lt;div id=\"box\"&gt; ![](&#123;&#123;url&#125;&#125;) &lt;!-- 效果能出来，但是会报一个vue warning警告 --&gt; ![](url)&lt;/div&gt; 4. class 和 style class 和 style 也是属性，所以它们绑定的方式跟前面我们讲的绑定图片 src 类似，例如:class=””等价于 v-bind:class=”” 或者:style=””等价于 v-bind:style=”” 。:style 和:class 都可以接受数组和 JSON，不过需要注意的是复合样式，采用驼峰命名法。 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- head :class接受数组 --&gt;&lt;style&gt; .red &#123; color: red; &#125; .blue &#123; background: blue; &#125;&lt;/style&gt;&lt;script&gt; window.onload = function () &#123; new Vue(&#123; el: '#box', data: &#123; red: 'red', blue: 'blue', a: true, b: false, json: &#123; red: true, blue: true, &#125;, style: &#123; color: 'red', backgroundColor: 'gray', &#125;, &#125;, &#125;); &#125;;&lt;/script&gt;&lt;div id=\"box\"&gt; &lt;strong :class=\"[red,blue]\"&gt;文字...&lt;/strong&gt; &lt;strong :class=\"&#123;red:true,blue:true&#125;\"&gt;文字...&lt;/strong&gt; &lt;strong :class=\"&#123;red:a,blue:b&#125;\"&gt;文字...&lt;/strong&gt; &lt;strong :class=\"json\"&gt;文字...&lt;/strong&gt; &lt;strong :style=\"style\"&gt;文字...&lt;/strong&gt;&lt;/div&gt; 5. 过滤器 过滤模板数据，系统提供一些过滤器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- a、例如capitalize/lowercase/uppercase/currency/json。 格式参考：&#123;&#123;msg| filterA | filterB&#125;&#125;或&#123;&#123;msg| filterA 参数&#125;&#125;例如capitalize是首字母大写，lowercase是全部小写，uppercase是全部大写，currency是转换成钱单位显示，json是显示obj对象数据，而不是[object Object]b、debounce配合事件，延迟执行，单位是毫秒c、limitBy作用是限制显示几个，limitBy可以带参数，用法类似substring，注意序号是从0开始算。第一个参数代表要取几个，第二个参数代表从哪里开始，前边算或者结尾都可以。d、filterBy 过滤数据，有点类似搜索引擎做的事。filterBy ‘谁’过滤条件显示对应的数据e、orderBy 排序 orderBy 1/-1 1代表正序 -1代表倒序f、自定义过滤器，可以带参数 --&gt;&lt;div id=\"box\"&gt; &#123;&#123;'welcome' | uppercase&#125;&#125; &#123;&#123;'WELCOME' | lowercase&#125;&#125; &#123;&#123;'WELCOME' | lowercase | capitalize&#125;&#125; &#123;&#123;12 | currency&#125;&#125; &#123;&#123;12 | currency '￥'&#125;&#125; &#123;&#123;obj | json&#125;&#125;&lt;/div&gt;&lt;input type=\"text\" @keyup=\"show | debounce 2000\" /&gt;&lt;!-- 代表show事件延迟两秒执行 --&gt;&lt;!-- data数据为 arr:[1,2,3,4,5] --&gt;&lt;li v-for=\"val in arr | limitBy 2\"&gt; &lt;!-- 限制默认显示两个 --&gt; &#123;&#123;val&#125;&#125;&lt;/li&gt;&lt;li v-for=\"val in arr | limitBy 2 arr.length-2\"&gt; &lt;!-- 限制显示从后面倒数两位的两个 --&gt; &#123;&#123;val&#125;&#125;&lt;/li&gt;&lt;!-- data数据为arr:['width','height','background','orange'], a:'' --&gt;&lt;input type=\"text\" v-model=\"a\" /&gt;&lt;ul&gt; &lt;li v-for=\"val in arr | filterBy a\"&gt;&#123;&#123;val&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;li v-for=\"val in arr | orderBy -1\"&gt; &lt;!-- 倒序 --&gt; &#123;&#123;val&#125;&#125;&lt;/li&gt;&lt;!-- 自定义过滤器，不带参数 --&gt;&lt;div id=\"box\"&gt;&#123;&#123;a | toDou&#125;&#125;&lt;/div&gt;Vue.filter('toDou',function(input)&#123; return input&lt;10?'0'+input:''+input; &#125;);&lt;!-- 自定义过滤器，带参数 --&gt;&lt;div id=\"box\"&gt;&#123;&#123;a | toDou 1 2&#125;&#125;&lt;/div&gt;Vue.filter('toDou',function(input,a,b)&#123; alert(a+','+b); returninput&lt;10?'0'+input:''+input; &#125;);&lt;!-- 双向过滤 --&gt;&lt;div id=\"box\"&gt; &lt;input type=\"text\" v-model=\"msg | filterHtml\" /&gt; &lt;br /&gt; &#123;&#123;&#123;msg&#125;&#125;&#125;&lt;/div&gt;Vue.filter('filterHtml',&#123; read:function(input)&#123; //model-view returninput.replace(/&lt;[^&lt;]+&gt;/g,''); &#125;, write:function(val)&#123; //view -&gt; modelconsole.log(val); return val; &#125; &#125;); 6. 数据交互 数据交互请求需要用到 vue-resource ，this.$http 有几种方式方向，例如 get/post/jsonp 等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;script&gt; window.onload = function () &#123; new Vue(&#123; el: 'body', data: &#123;&#125;, methods: &#123; get: function () &#123; this.$http .get('get.php', &#123; a: 1, b: 2, &#125;) .then( function (res) &#123; alert(res.data); &#125;, function (res) &#123; alert(res.status); &#125; ); &#125;, post: function () &#123; this.$http .post( 'post.php', &#123; a: 1, b: 20, &#125;, &#123; emulateJSON: true, // post需要设置请求头 &#125; ) .then( function (res) &#123; alert(res.data); &#125;, function (res) &#123; alert(res.status); &#125; ); &#125;, getJSONP1: function () &#123; this.$http .jsonp('https://sug.so.360.cn/suggest', &#123; word: 'a', &#125;) .then( function (res) &#123; alert(res.data.s); &#125;, function (res) &#123; alert(res.status); &#125; ); &#125;, getJSONP2: function () &#123; this.$http .jsonp( 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su', &#123; wd: 'a', &#125;, &#123; jsonp: 'cb', // callback名字，默认名字就是\"callback\" &#125; ) .then( function (res) &#123; alert(res.data.s); &#125;, function (res) &#123; alert(res.status); &#125; ); &#125;, getPageData: function (n) &#123; this.$http(&#123; url: URL, data: &#123; act: 'get', page: n, &#125;, &#125;).then(function (res) &#123; console.log(res.data); &#125;); &#125;, &#125;, &#125;); &#125;;&lt;/script&gt;","tags":[{"name":"框架","slug":"框架","permalink":"https://liwenxin-jam.github.io/tags/框架/"}]},{"title":"ES6常用知识点学习小结","date":"2018-06-25T13:19:16.000Z","path":"2018/06/25/ES6常用知识点学习小结/","text":"ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准。因为当前版本的 ES6 是在 2015 年发布的，所以又称 ECMAScript 2015(简称 ES2015）。虽然浏览器在不断更新，但并不是所有用户的电脑浏览器都支持 ES6，所以在使用的过程中建议还是转成 es5，保证代码的可执行性。至于转换的方式大家可以用Babel或者Traceur转码器。 1. let 和 const 在 ES6 以前，Javascript 并不同有块级作用域的概念，有的是函数作用域，而 let 的出现就是为了打破局面，有点向后台语言发展的趋势。const 是代表常量，必须在定义的时候初始化，不可改变。下面我举例子说明。 12345678910111213141516171819202122232425262728window.onload = function () &#123; var aInput = document.getElementsByTagName('input'); // 传统解决办法 for (var i = 0; i &lt; aInput.length; i++) &#123; (function (i) &#123; // 函数闭包自执行来解决i索引的问题 aInput[i].onclick = function () &#123; alert(i); &#125;; &#125;)(i); &#125; // let变量的出现相当于给你加了一个封闭空间来极度简化了i值索引的问题 // let大家可以看成是匿名函数立即调用(IIFE） for (let i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; alert(i); &#125;; &#125;&#125;;// 对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错// 以前var的时候并不会报错，只是覆盖定义let a = 12;let a = 13; // Identifier 'a' has already been declared// const必须在初始化的时候同时赋初值，且不能更改const b; // Uncaught SyntaxError: Missing initializer in const declarationconst b = 14;b = 15; // Uncaught TypeError: Assignment to constant variable. 2. 字符串模板123456789101112131415161718// 传统字符串拼接var s1 = '快乐童年放飞希望^_^';var s2 = '国家主席^_^';var str = '2013年5月29日，中共中央总书记、' + s2 + '、中央军委主席习近平在' + '北京市少年宫参加“' + s1 + '”主题队日活动。这是习近平在和孩子们谈对环保的认识和' + '理解。新华社记者李学仁摄';document.write(str);// 字符模板的写法var s1 = '快乐童年放飞希望^_^';var s2 = '国家主席^_^';var str = `2013年5月29日，中共中央总书记、$&#123;s2&#125;、中央军委主席习近平在北京市少年宫参加“$&#123;s1&#125;”主题队日活动。这是习近平在和孩子们谈对环保的认识和理解。 新华社记者李学仁摄`;document.write(str); 3.解构赋值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 以前我们给变量赋值，只能直接指定值var a = 1;var b = 2;var c = 3;console.log(a, b, c); // 1 2 3// 现在用解构赋值的写法就变得简单了，只要模式匹配上了就行了，如下// 注意数组是有顺序的var [a, b, c] = [11, 22, 33];console.log(a, b, c); // 11 22 33var [b, a, c] = [11, 22, 33];console.log(a, b, c); // 22 11 33// 当然解构赋值还有嵌套比较复杂的写法，如下let [foo, [[bar], [baz]]] = [111, [[222], [333]]];console.log(foo, bar, baz); // 111 222 333let [head, ...foot] = [1, 2, 3, 4];console.log(head, foot); // 1 [2,3,4]// 如果解构不成功，变量的值就等于undefined，如下var [bar3, foo3] = [1000];console.log(bar3, foo3); // 1000 undefined// 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。// 这种情况下，解构依然可以成功let [x, y] = [10000, 20000, 30000];console.log(x, y); // 10000 20000// 默认值可以引用解构赋值的其他变量，但该变量必须已经声明let [a = 1, b = a] = [2, 3];console.log(a, b); // 2 3// 对象的解构也可以指定默认值var &#123; x, y = 5 &#125; = &#123; x: 1 &#125;;console.log(x, y); // 1 5// 对象的解构赋值解构不仅可以用于数组，还可以用于对象(json)// 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；// 而对象的属性没有次序，变量必须与属性同名，才能取到正确的值var &#123; a, b &#125; = &#123; a: 'apple', b: 'banana' &#125;;console.log(a, b); // apple bananavar &#123; b, a &#125; = &#123; a: 'apple', b: 'banana' &#125;;console.log(a, b); // apple banana// 如果变量名与属性名不一致，必须写成下面这样let obj = &#123; first: 'hello', last: 'world' &#125;;// first ---&gt; f，那么此时f就是first，而不是undefined了,有点类似别名的概念let &#123; first: f, last &#125; = obj;console.log(f, last); // hello world// 1.也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。// 真正被赋值的是后者，而不是前者// 2.v是匹配的模式，n才是变量。真正被赋值的是变量n，而不是模式v。// 注意，采用这种写法时，变量的声明和赋值是一体的// v ---&gt; n，那么此时n就是vue，而不是undefined了var &#123; v: n &#125; = &#123; v: 'vue', r: 'react' &#125;;console.log(n); // vueconsole.log(v); // Uncaught ReferenceError: v is not definedconsole.log(r); // Uncaught ReferenceError: r is not defined 4.复制数组12345678910111213141516171819202122232425262728293031323334353637383940// 数组的浅拷贝，引用之间的拷贝，没有实现数组的真正复制var arr1 = [1, 2, 3];var arr2 = arr1;arr2.push(4);console.log(arr1, arr2);// 复制数组深拷贝，传统做法var arr1 = [1, 2, 3];var arr2 = [];// 通过for循环遍历之后将arr1数组的每一项赋值给arr2数组的每一项， 就实现了数组的深拷贝，// 这时候我再去操作arr2的数组的时候，arr1就不会受影响了for (var i = 0; i &lt; arr1.length; i++) &#123; arr2[i] = arr1[i];&#125;// 数组尾部添加arr2.push(4);console.log(arr1, arr2);// ES6实现的数组的深拷贝方法1var arr1 = [1, 2, 3];var arr2 = Array.from(arr1);// 数组尾部添加arr2.push(100);console.log(arr1, arr2);// ES6实现的数组的深拷贝方法2var arr1 = [1, 2, 3];// 超引用拷贝数组var arr2 = [...arr1];// 数组尾部添加arr2.push(1000);console.log(arr1, arr2);function show(...args) &#123; // 此时这个形势参数就是一个数组，我们可以直接push东西进来，如下 args.push(5); console.log(args);&#125;// 调用show(1, 2, 3, 4); // 1,2,3,4,5 5. Map1234567891011121314151617181920212223242526272829303132333435363738394041var map = new Map();// 设置// map.set(name,value);map.set('a', 'apple');map.set('b', 'banana');// 获取// map.get(name);console.log(map.get('a') + ' ' + map.get('b'));// 删除之前map对象console.log(map);// 删除// map.delete(name);map.delete('a');// 删除之后map对象console.log(map);// 注意for..in是不能循环map对象的，不报错也无任何反应，稍微注意下for (var name in map) &#123; console.log(name);&#125;// 实体 map=map.entries()for (var name of map) &#123; // 循环出来的结果就是:a,apple b,banana 循环key,value console.log(name);&#125;// 循环出来的结果就是: a,apple b,banana 循环key,valuefor (var [key, value] of map.entries()) &#123; console.log(key, value);&#125;// 只循环keyfor (var key of map.keys()) &#123; console.log(key);&#125;// 只循环valuefor (var val of map.values()) &#123; console.log(val);&#125; 6. for-of 循环12345678910111213141516171819202122232425262728293031323334353637383940414243// for of一个arr对象var arr = ['红楼梦','西游记','三国演义','水浒传','金瓶梅'];// 只循环keyfor(var key of arr.keys())&#123;console.log(key);&#125;// 只循环value，注意数组是没有.values()for(var value of arr)&#123;console.log(value);&#125;// 循环key,valuefor(var [key,value] of arr.entries())&#123;console.log(key,value);&#125;// for in循环与for of循环的区别var arr = ['apple','banana','orange','pear'];for(var i in arr)&#123;// i打印出来的就是arr数组对应的索引// 0 1 2 3console.log(i);&#125;for(var i of arr)&#123;// i值打印出来的就是我们想要的数组具体的值// apple banana orange pearconsole.log(i);&#125;// for of不能循环jsonvar json = &#123;'a':'apple','b':'banana','c':'orange','d':'pear'&#125;;for(var name in json)&#123;// a b c dconsole.log(name);// appleconsole.log(json.a);// pearconsole.log(json['d']);&#125;// 注意for..of可以循环arr，但是不可以循环json,会报错，特别注意下for(var name of json)&#123;Uncaught TypeError: undefined is not a functionconsole.log(json);&#125; 7. 箭头函数12345678910111213141516171819202122232425// 箭头函数写法 function()&#123;&#125; 变为 ()=&gt;&#123;&#125;window.onload = () =&gt; &#123; var oBox = document.getElementById('box'); oBox.onclick = () =&gt; &#123; oBox.style.backgroundColor = '#ff0000'; &#125;;&#125;;// 注意this指向会有问题var json = &#123; a: 1, b: 2, showName: () =&gt; &#123; return this.a; &#125;,&#125;;// 因为使用了箭头函数this指向了object window 所以result：undefinedconsole.log(json.showName());// 如果使用了箭头函数的写法，那么注意arguments将不能继续使用了var show = () =&gt; &#123; console.log(arguments);&#125;;// Uncaught ReferenceError: arguments is not definedshow(1, 2, 3); 8. 对象的简洁语法12345678910111213141516171819202122232425262728293031// 传统对象_单体模式写法 key-value模式var person = &#123; name: 'jam', age: 28, showName: function () &#123; return this.name; &#125;, showAge: function () &#123; return this.age; &#125;,&#125;;// 调用console.log(person.showName()); // jamconsole.log(person.showAge()); // 28// ES6_单体模式写法 不需要写keyvar name = 'xiaokai';var age = 2;var person = &#123; name, age, showName() &#123; return this.name; &#125;, showAge() &#123; return this.age; &#125;,&#125;;// 调用console.log(person.showName()); // xiaokaiconsole.log(person.showAge()); // 2 9. class 和 extends123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// 传统面向对象写法function Person(name, age) &#123; // 类、构造函数 this.name = name; this.age = age;&#125;Person.prototype.showName = function () &#123; return this.name;&#125;;Person.prototype.showAge = function () &#123; return this.age;&#125;;var p1 = new Person('allen', 28);var p2 = new Person('xiaoxiaoyou', 101);console.log(p1.showName()); // allenconsole.log(p2.showAge()); // 101console.log(p1.showName == p2.showName); // trueconsole.log(p1.constructor == Person); // true// ES6面向对象写法class Person &#123; // 构造器 constructor(name, age) &#123; this.name = name; this.age = age; &#125; showName() &#123; return this.name; &#125; showAge() &#123; return this.age; &#125;&#125;var p1 = new Person('aaa', 18);var p2 = new Person('bbb', 20);console.log(p1.name); // aaaconsole.log(p1.showName()); // aaaconsole.log(p2.showAge()); // 20console.log(p1.showAge == p2.showAge); // trueconsole.log(p1.constructor == Person); // true// 面向对象class给默认值class Person &#123; // 构造器 constructor(name = 'default', age = 0) &#123; this.name = name; this.age = age; &#125; showName() &#123; return this.name; &#125; showAge() &#123; return this.age; &#125;&#125;var p1 = new Person();console.log(p1.name); // 构造器里面给的默认值 defaultconsole.log(p1.age); // 构造器里面给的默认值 0//传统写法原型继承function Person(name, age) &#123; // 类、构造函数 this.name = name; this.age = age;&#125;Person.prototype.showName = function () &#123; return this.name;&#125;;Person.prototype.showAge = function () &#123; return this.age;&#125;;// 工人类function Worker(name, age) &#123; // 属性继承过来 Person.apply(this, arguments);&#125;// 原型继承Worker.prototype = new Person();var p1 = new Person('allen', 28);var w1 = new Person('worker', 1000);console.log(w1.showName()); // 确实继承过来了 result：worker//ES6中面向对象实现类继承class Person &#123; // 构造器 constructor(name, age) &#123; this.name = name; this.age = age; &#125; showName() &#123; return this.name; &#125; showAge() &#123; return this.age; &#125;&#125;class Worker extends Person &#123; constructor(name, age, job = '拖地的') &#123; // 继承超父类的属性 super(name, age); this.job = job; &#125; showJob() &#123; return this.job; &#125;&#125;var p1 = new Person('aaa', 18);var w1 = new Person('www', 36);var w2 = new Worker('wwwwwwww', 90);console.log(w1.showName()); // wwwconsole.log(w2.showJob()); // 默认给的值 ‘拖地的’ 10. 模块化-export 和 import 下边的演示文件 mod 代表是导出模块 js, index 代表的是引入模块的 js ,mod 文件跟 index 文件一一对应关系 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// mod.js// 第一种模块导出的书写方式(一个个的导出)// 导出普通值export let a = 12;export let b = 5;// 导出jsonexport let json = &#123; a, b,&#125;;// 导出函数export let show = function () &#123; return 'welcome';&#125;;// 导出类export class Person &#123; constructor() &#123; this.name = 'jam'; &#125; showName() &#123; return this.name; &#125;&#125;// index.js// 导出模块如果用default了，引入的时候直接用，若没有用default，引入的时候可以用&#123;&#125;的形式// 导入模块的方式import &#123; a, b, json, show, Person &#125; from './mod.js';console.log(a); // 12console.log(b); // 5console.log(json.a); // 12console.log(json.b); // 5console.log(show()); // welcomeconsole.log(new Person().showName()); // jam// mod1.js// 第二种模块导出的书写方式let a = 12;let b = 5;let c = 10;export &#123; a, b, c as cc, // as是别名，使用的时候只能用别名，特别注意下&#125;;// index1.js// 导入模块的方式import &#123; a, b, cc, // cc是导出的，as别名&#125; from './mod1.js';console.log(a); // 12console.log(b); // 5console.log(cc); // 10// mod2.js// 第三种模块导出的书写方式 ---&gt; default// default方式的优点，import无需知道变量名，就可以直接使用，如下// 每个模块只允许一个默认出口var name = 'jam';var age = '28';export default &#123; name, age, default() &#123; console.log('welcome to es6 module of default...'); &#125;, getName() &#123; return 'bb'; &#125;, getAge() &#123; return 2; &#125;,&#125;;// index2.js// 导入模块的方式import mainAttr from './mod2.js';var str = ' ';// 直接调用console.log(`我的英文名是:$&#123;mainAttr.name&#125;我的年龄是$&#123;mainAttr.age&#125;`);mainAttr.default(); // welcome to es6 module of default...console.log(mainAttr.getName()); // bbconsole.log(mainAttr.getAge()); // 2// mod3.jsvar name = 'jam';var age = '28';export function getName() &#123; return name;&#125;export function getAge() &#123; return age;&#125;// index3.js// 导入模块的方式import * as fn from './mod3.js';// 直接调用console.log(fn.getName()); // jam 11. Promise12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// Promise对象 ---&gt; 用来传递异步操作过来的数据的// Pending(等待、处理中) ---&gt; Resolve(完成，fullFilled) ---&gt; Reject(拒绝，失败)var p1 = new Promise(function (resolve, reject) &#123; resolve(1); // 成功了 // reject(2); // 失败了&#125;);// 接收成功和失败的数据，通过then来传递// then也是返回一个promise对象，会继续往下传递数据,传递给下一个thenp1.then( function (value) &#123; // resolve console.log(value); return value + 1; // 1 alert(`成功了：$&#123;value&#125;`); &#125;, function (value) &#123; // reject alert(`失败了：$&#123;value&#125;`); &#125;).then(function (value) &#123; console.log(value); // 2&#125;);// catch捕获异常错误var p1 = new Promise(function (resolve, reject) &#123; resolve('成功了');&#125;);p1.then(function (value) &#123; console.log(value); // throw是用来抛错误的 throw '发生了点小意外';&#125;).catch(function (e) &#123; // catch用来捕获这个错误的 ---&gt; 追踪 console.log(e);&#125;);// all ---&gt; 全部，用于将多个promise对象，组合，包装成// Promise.all([p1,p2,p3,...]); 所有的promise对象，都正确，才走成功// 否则，只要有一个错误，就走失败var p1 = Promise.resolve(1);var p2 = Promise.reject(0);Promise.all([true, p1, p2]).then( function (obj) &#123; console.log(`成功了：$&#123;obj&#125;`); &#125;, function (obj) &#123; console.log(`失败了：$&#123;obj&#125;`); &#125;);// race ---&gt; 返回的也是一个promise对象// 最先执行的的promise结果，哪个最快我用哪个var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 50, 'one');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 100, 'two');&#125;);Promise.race([p1, p2]).then(function (val) &#123; console.log(val);&#125;);// resolve ---&gt; 生成一个成功的promise对象// 语法规则：Promise.resolve(val); // 普通值// Promise.resolve(arr); // 数组之类// Promise.resolve(promise); // 传递另一个promise对象// 传递普通值Promise.resolve('success').then( function (val) &#123; // 注意resolve，走得是这里 console.log(val); // success &#125;, function (err) &#123; console.log('err:' + err); &#125;);// 传递数组Promise.resolve([1, 2, 3]).then( function (val) &#123; // 注意resolve，走得是这里 console.log(val); // [1,2,3] &#125;, function (err) &#123; console.log(err); &#125;);// 传递一个promise对象var p1 = Promise.resolve(520);var p2 = Promise.resolve(p1);p2.then(function (val) &#123; // 从p1那边传递过来的 console.log(val); // 520&#125;); 12. Generator、yield123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// Generator ---&gt; 生成器就是一个函数// 特点：// 1.函数名前面带一个*，和普通函数做区分// 2.内部使用yield语句// 调用方式，如下var res = show();// value指的是generator函数内容yield定义的值，done:false表示还没遍历完// 直接找到返回值return了，那么此时done才会为true// console.log(res.next());&#123;value:'值1',done:false&#125;function* show() &#123; yield 'Hello'; yield 'World'; yield 'ES6'; return 'xx';&#125;var res = show();console.log(res.next()); // &#123;value: \"Hello\", done: false&#125;console.log(res.next()); // &#123;value: \"World\", done: false&#125;console.log(res.next()); // &#123;value: \"ES6\", done: false&#125;console.log(res.next()); // &#123;value: \"allen\", done: true&#125;// 已经找到return返回值了，继续下去就没有意义了// console.log(res.next()); // &#123;value: \"undefined\", done: true&#125;// yield本身没有返回值，或者可以说每次给你返回的是undefinedfunction* show() &#123; var a = yield 'Hello'; return a;&#125;var res = show();console.log(res.next()); // &#123;value: \"Hello\", done: false&#125;console.log(res.next()); // &#123;value: \"undefined\", done: true&#125;// next方法是可以带参数的,死循环的generator函数function* fn() &#123; for (var i = 0; true; i++) &#123; // 如果里面传了一个值，那么它会把这个参数赋给最近的一个yield var a = yield i; if (a) i = -1; &#125;&#125;var d = fn();console.log(d.next()); // &#123;value: 0, done: false&#125;console.log(d.next()); // &#123;value: 1, done: false&#125;console.log(d.next()); // &#123;value: 2, done: false&#125;// 如果里面传了一个值，那么它会把这个参数赋最近的一个yieldconsole.log(d.next(true)); // &#123;value: 0, done: false&#125;console.log(d.next()); // &#123;value: 1, done: false&#125;console.log(d.next()); // &#123;value: 2, done: false&#125;console.log(d.next()); // &#123;value: 3, done: false&#125;// for..0f循环generator函数function* fn() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;//for..0f循环generator函数，可以取值for (let val of fn()) &#123; document.write(val); // 12345&#125;// 对象里使用generator函数的特殊写法，注意下var json = &#123; *show() &#123; yield 'a'; yield 'b'; return 'c'; &#125;,&#125;;var res = json.show();console.log(res.next()); // &#123;value: \"a\", done: false&#125;console.log(res.next()); // &#123;value: \"b\", done: false&#125;console.log(res.next()); // &#123;value: \"c\", done: true&#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"Mac下安装mysql完整步骤","date":"2018-05-12T13:54:40.000Z","path":"2018/05/12/Mac下安装mysql完整步骤/","text":"MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL 是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。想了解更清楚的可以查阅百度百科。 1. 官网下载 download 官网下载链接，注意选 GPL，非商业版。可以看到当前版本最新为 5.7.18，建议下载 dmg 格式。 &gt; 2.安装 mysql 下载完成后，点击安装，一路确认，等待安装成功。注意安装完成，会给你一个临时密码，请保留相关的文本。例如：A temporary password is generated for root@localhost: yiNqY=P5VnjL。进入系统偏好设置，最下边一行，找到 mysql 打开，点击”Start MySQL Server”，启动 mysql。 3.重置密码 如果真的是不记得初始密码，建议参考下面这篇文章重置初始密码。重置密码链接 4.终端下使用 mysql 命令 在 iterm 下使用以下两条指令，注意此方式只会保证当前终端窗口可以使用 mysql，如果关闭终端或者重启电脑会失效，提示没有 mysql 命令。 12alias mysql=/usr/local/mysql/bin/mysqlalias mysqladmin=/usr/local/mysql/bin/mysqladmin 如果想永久性在终端上使用 mysql 命令，建议参考下面这篇文章初始化.bash_profile 文件。MySQL 命令链接 5.创建 test 用户和授权库操作权限121. GRANT USAGE ON *.* TO 'test'@'localhost' IDENTIFIED BY '123456' WITH GRANT OPTION;2. grant all privileges on 库名.* to test@localhost identified by '123456' 6.修改 root 用户初始密码 UPDATE mysql.user SET authentication_string=PASSWORD(‘abc123’) WHERE User=’root’;","tags":[{"name":"后端","slug":"后端","permalink":"https://liwenxin-jam.github.io/tags/后端/"}]},{"title":"Git操作指南","date":"2018-04-27T08:28:23.000Z","path":"2018/04/27/Git操作指南/","text":"Git 是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。想了解更清楚的可以查阅百度百科。在说明操作指南前，我先给大家说明几个专业术词。 12341. Workspace：工作区2. Index / Stage：暂存区3. Repository：仓库区（或本地仓库）4. Remote：远程仓库 1. 初始化仓库1234567mkdir learngit // 创建一个文件夹cd learngit // 切换当前目录pwd // 显示当前目录完整路径git init // 初始化目录，在当前目录新建一个Git代码库git init [project-name] // 新建一个目录，将其初始化为Git代码库git clone [url] // 下载一个项目和它的整个代码历史ls -ah // 显示当前目录所有文件，包括隐藏文件 2. 配置 Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 注意– 代表的是两个-，请勿写错，下文全部如此 1234git config --list // 显示当前的Git配置git config -e [--global] // 编辑Git配置文件git config [--global] user.name \"[name]\" // 设置提交代码时的用户信息git config [--global] user.email \"[email address]\" 3. 增加/删除文件1234567git add [file1] [file2] ... // 添加指定文件到暂存区git add [dir] // 添加指定目录到暂存区，包括子目录git add . // 添加当前目录的所有文件到暂存区git add -p // 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交git rm [file1] [file2] ... // 删除工作区文件，并且将这次删除放入暂存区git rm --cached [file] // 停止追踪指定文件，但该文件会保留在工作区git mv [file-original] [file-renamed] // 改名文件，并且将这个改名放入暂存区 4. 代码提交 修改文件内容后 git status 会提示 use “git add” and/or “git commit -a”注意先 add 后 commit，不可以直接 commit 1234567891011cd.&gt;readme.txt // 创建一个空文件git add readme.txt // 把文件添加到git仓库git status // 查看当前仓库文件改动状态git diff // 是工作区(work dict)和暂存区(stage)的比较git diff --cached // 是暂存区(stage)和分支(master)的比较git commit -m [message] // 提交暂存区到仓库区，加上改动说明git commit [file1] [file2] ... -m [message] // 提交暂存区的指定文件到仓库区git commit -a // 提交工作区自上次commit之后的变化，直接到仓库区git commit -v // 提交时显示所有diff信息git commit --amend -m [message] // 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend [file1] [file2] ... // 重做上一次commit，并包括指定文件的新变化 5. 分支1234567891011121314151617git branch // 列出所有本地分支git branch -r // 列出所有远程分支git branch -a // 列出所有本地分支和远程分支git branch [branch-name] // 新建一个分支，但依然停留在当前分支git checkout -b [branch] // 新建一个分支，并切换到该分支git branch [branch] [commit] // 新建一个分支，指向指定commitgit branch --track [branch] [remote-branch] // 新建一个分支，与指定的远程分支建立追踪关系git checkout [branch-name] // 切换到指定分支，同时重置缓存区和工作区，如果工作区有修改没有提交,需要先commit或stashgit checkout -- file // 命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令git checkout branch --force // 切换branch,同时重置缓存区和工作区git checkout - // 切换到上一个分支git branch --set-upstream [branch] [remote-branch] // 建立追踪关系，在现有分支与指定的远程分支之间git merge [branch] // 合并指定分支到当前分支git cherry-pick [commit] // 选择一个commit，合并进当前分支git branch -d [branch-name] // 删除分支git push origin --delete [branch-name] // 删除远程分支git branch -dr [remote/branch] // 删除远程分支 6. 查看信息123456789101112131415161718192021git status // 显示有变更的文件git log // 显示当前分支的版本历史git log --stat // 显示commit历史，以及每次commit发生变更的文件git log -S [keyword] // 搜索提交历史，根据关键词git log [tag] HEAD --pretty=format:%s // 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --grep feature // 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件git log --follow [file] // 显示某个文件的版本历史，包括文件改名git whatchanged [file] // 显示某个文件的版本历史，包括文件改名git log -p [file] // 显示指定文件相关的每一次diffgit log -5 --pretty --oneline // 显示过去5次提交git shortlog -sn // 显示所有提交过的用户，按提交次数排序git blame [file] // 显示指定文件是什么人在什么时间修改过git diff // 显示暂存区和工作区的差异git diff --cached [file] // 显示暂存区和上一个commit的差异git diff HEAD // 显示工作区与当前分支最新commit之间的差异git diff [first-branch]...[second-branch] // 显示两次提交之间的差异git diff --shortstat \"@&#123;0 day ago&#125;\" // 显示今天你写了多少行代码git show [commit] // 显示某次提交的元数据和内容变化git show --name-only [commit] // 显示某次提交发生变化的文件git show [commit]:[filename] // 显示某次提交时，某个文件的内容git reflog // 显示当前分支的最近几次提交 7. 远程同步12345678git fetch [remote] // 下载远程仓库的所有变动git remote -v // 显示所有远程仓库git remote show [remote] // 显示某个远程仓库的信息git remote add [shortname] [url] // 增加一个新的远程仓库，并命名git pull [remote] [branch] // 取回远程仓库的变化，并与本地分支合并git push [remote] [branch] // 上传本地指定分支到远程仓库git push [remote] --force // 强行推送当前分支到远程仓库，即使有冲突git push [remote] --all // 推送所有分支到远程仓库 8. 撤销1234567891011git checkout [file] // 恢复暂存区的指定文件到工作区git checkout [commit] [file] // 恢复某个commit的指定文件到暂存区和工作区git checkout . // 恢复暂存区的所有文件到工作区git reset [file] // 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset --hard // 重置暂存区与工作区，与上一次commit保持一致git reset [commit] // 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset --hard [commit] // 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --keep [commit] // 重置当前HEAD为指定commit，但保持暂存区和工作区不变git revert [commit] // 新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支git stash // 暂时将未提交的变化移除，稍后再移入git stash pop 9. 解决冲突 多人合作的实际开发中，当我们合并分支或者合并文件，突然产生冲突。解决冲突的方法为： 1231. 使用任意的文本编辑工具编辑有冲突的文件，去除冲突标记（就是&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ======= &lt;&lt;&lt;&lt;&lt;&lt;这样的东西），并把文本冲突解决掉。2. 然后使用git add 有冲突的文件，这时文件的冲突标记就变成了修改标记了（在windows下安装TortoiseGit就能看到文件图标的变化了）。3. 将所有有冲突的文件解决完后，使用git commit -a -m \"Xxx\"提交就算完成整个合并过程了。 注意，当本地修改文件无法使用 git pull 拉取远程仓库代码，需要自己手动缓存自己本地的操作。具体操作如下：12341. git stash // 这样本地的所有修改就都被暂时存储起来 。可以用git stash list可以看到保存的信息：git stash暂存修改 。其中stash@&#123;0&#125;就是刚才保存的标记。2. git pull // 暂存了本地修改之后，就可以pull了。3. git stash pop stash@&#123;0&#125; // 还原暂存的内容，系统提示如下类似的信息：Auto-merging c/environ.c CONFLICT (content): Merge conflict in c/environ.c 意思就是系统自动合并修改的内容，但是其中有冲突，需要解决其中的冲突。4. 解决文件中冲突的的部分参照前者方法 参考引自阮一峰的常用 Git 命令清单","tags":[{"name":"工作","slug":"工作","permalink":"https://liwenxin-jam.github.io/tags/工作/"}]},{"title":"Mockjs使用小结","date":"2018-03-27T12:09:51.000Z","path":"2018/03/27/Mockjs使用小结/","text":"在项目开发中，由于前后端通常要一起开工，作为前端的我们许多工作需要在后台返回的基础上进行，因此，大部分时间，编写完成的代码看不到实在的效果，这就导致在后台完成工作之前前端无法进行很好的调试。因此，项目的进度在一定程度上来说使前后台的串行工作，而不是并行。然而 mock.js 可以帮我们很好地解决这个问题。Mockjs 官网 mock 使用教程数据模板定义‘name|rule’: value name 为属性名, rule 为规则, value 为值，属性名和生成规则之间用|分隔，生成规则的格式有 7 种： ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value //.dmin-dmax 小数点后保留的位数范围 ‘name|min-max.dcount’: value //小数点后保留 dcount 位 ‘name|count.dmin-dmax’: value ‘name|+step’: value //从 value 递增/减 属性值可以包含占位符(如@name)，属性值指定了最终值的初始值和数据类型.属性值是字符串 String ‘name|min-max’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数大于等于 min，小于等于 max。 ‘name|count’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数等于 count。属性值是数字 Number ‘name|+1’: 100 属性值自动加 1，初始值为 100 ‘name|1-100’: 100 生成一个大于等于 1、小于等于 100 的整数，属性值 100 只用来确定类型。 ‘name|1-100.1-10’: 100 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。 属性值是布尔型 Boolean ‘name|1’: value 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2。 ‘name|min-max’: value 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。 属性值是对象 Object ‘name|min-max’: {} 从属性值 {} 中随机选取 min 到 max 个属性。 ‘name|count’: {} 从属性值 {} 中随机选取 count 个属性。 属性值是数组 Array ‘name|1’: [{}, {} …] 从属性值 [{}, {} …] 中随机选取 1 个元素，作为最终值。 ‘name|min-max’: [{}, {} …] 通过重复数组中的元素值 [{}, {} …] 生成一个新数组，重复次数大于等于 min，小于等于 max。 ‘name|count’: [{}, {} …] 通过重复数组中的元素值 [{}, {} …] 生成一个新数组，重复次数为 count。 属性值是数组 Function ‘name’: function(){} 执行函数 function(){}，取其返回值作为最终的属性值，上下文为 ‘name’ 所在的对象。 数据占位符定义占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为： @占位符 @占位符(参数 [, 参数]) 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板 中的属性。 占位符 会优先引用 数据模板 中的属性 常用方法1.Mock.mock( rurl?, rtype?, template|function(options) )根据数据模板生成模拟数据。 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 //domain/list.json/、’/domian/list.json’。 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。 function(options)：可选。表示用于生成响应数据的函数。 options：指向本次请求的 Ajax 选项集。 2.Mock.mockjax(library) 覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。3.Mock.Random Mock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 。4.Mock.tpl(input, options, helpers, partials) 基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;mockjs-demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;script src=\"require.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; require.config(&#123; paths: &#123; jquery: 'node_modules/jquery/dist/jquery.min', mockjs: 'node_modules/mockjs/dist/mock-min', &#125;, &#125;); // 使用 Mock require(['mockjs', 'jquery'], function (Mock, $) &#123; Mock.mock('http://123.com', &#123; // 'name': \"MarcoHan\", name: &#123; first: '@FIRST', middle: '@FIRST', last: '@LAST', full: '@first @middle @last', &#125;, 'age|1-100': 100, color: '@COLOR', // @占位符实际引用的是Mock.Random里面的方法，具体查看API // 'color': Mock.Random.color(), // 属性 list 的值是一个数组，其中含有 1 到 10 个元素 'list|1-10': [ &#123; // 属性 id 是一个自增数，起始值为 1，每次增 1 'id|+1': 1, &#125;, ], &#125;); // 输出结果 // console.log(JSON.stringify(data, null, 4)) $.ajax(&#123; url: 'http://123.com', &#125;).done(function (data, status, xhr) &#123; console.dir(data); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 参考文献1、利用 mock 生成假数据","tags":[{"name":"工具","slug":"工具","permalink":"https://liwenxin-jam.github.io/tags/工具/"}]},{"title":"Seajs使用小结","date":"2018-02-13T11:29:41.000Z","path":"2018/02/13/Seajs使用小结/","text":"在 SeaJS 中，所有 JavaScript 文件都应该用模块的形式来书写，并且一个文件只包含一个模块。如果没有 SeaJS 库文件可以github 官网绍下载。 html 文件内容，首先引入 sea.js 文件，然后通过 seajs.use 加载 main.js 文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;seajs-demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Seajs Demo&lt;/h1&gt; &lt;h2 id=\"test\"&gt;Hello World!&lt;/h2&gt; &lt;script src=\"seajs-module/sea.js\"&gt;&lt;/script&gt; &lt;script&gt; // 正常引入一个模块要写他的相对路径，但我们可以给它取个别名，用别名来替代相对路径引入 // main中引用changeText模块就可以直接写成这样了var changeText = require('changeText') // 用来进行配置的方法。 seajs.config(&#123; // Sea.js 的基础路径，也可以不指定默认seajs的地址 // 注意：一般请不要配置 base 路径，把 sea.js 放在合适的路径往往更简单一致。 base: 'file:///Users/username/Desktop/github-uploadDemo/seajs-demo/seajs-module', // 别名配置 alias: &#123; // 'changeText':'../static/changeText.js', //可直接用下者 changeText: './changeText', //require引入路径则是相对于当前的js文件所在目录 // 在seajs中直接以文件名开头的路径是相对于base路径 // base路径即seajs的根目录 jquery: 'jquery/jquery.min', // seajs.use()调用模块文件的路径默认是seajs的父级文件的目录 // ../代表上一级找到seajs-demo再依次查找下去 // 'main': './static/main.js' // ./代表根目录的当前目录下查找 main: '../seajs-demo/static/main', // 'log': './static/log' log: 'staticBase/log', &#125;, // 路径配置，当目录比较深，或需要跨目录调用模块时，可以使用paths来简化书写。 paths: &#123; staticBase: './static', &#125;, // 预加载项，在老浏览器中，提前加载好ES5和json模块 preload: [ Function.prototype.bind ? '' : 'es5-safe', this.JSON ? '' : 'json', ], // 文件编码 charset: 'utf-8', // 调试模式，值为true时，加载器不会删除动态插入的script标签。插件也可以根据debug配置，来决策log等信息的输出。 debug: true, &#125;); seajs.use('./static/main.js'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 入口函数 main.js 文件内容，标准格式为 define(function(require, exports, module){})123456789101112131415161718192021222324252627282930313233343536373839404142434445464748define(function (require, exports, module) &#123; // var changeText = require('./changeText.js'); // var changeText = require('changeText'); // js原生方式 // var helloDom = document.getElementById('test'); // helloDom.innerHTML = 'Hello Jam'; // helloDom.innerHTML = changeText.text; // jq方式 // var $ = require('jquery'); // $('#test').text(changeText.init()); // 在define(function ()&#123; &#125;), require引入路径则是相对于当前的js文件所在目录 var changeText = require('changeText'); var $ = require('jquery'); var showText = function () &#123; $('#test').text(changeText.init()); &#125;; exports.showText = showText;&#125;);// 单一模式// seajs.use是立即执行，注意./ ../都是相对项目的根目录的区别// seajs.use('./static/log');// seajs.use('../seajs-demo/static/log');// seajs.use(['log'])// 回调方式// seajs.use()调用模块文件的路径默认是seajs的父级文件的目录；// seajs.use(['main','jquery'],function(main,$) &#123;// $('#test').after('&lt;button id=\"show\"&gt;showText&lt;/button&gt;');// $('#show').on('click',function() &#123;// main.showText()// &#125;)// &#125;);// require.async 该方法可用来异步加载模块，并在加载完成后执行回调函数。define(function (require, exports, module) &#123; // 加载多个模块 require.async(['./log', 'jquery'], function (log, $) &#123; console.log('111111'); // do something $('#test').after('&lt;button id=\"show\"&gt;showText&lt;/button&gt;'); $('#show').on('click', function () &#123; log.showText(); &#125;); &#125;);&#125;); 自定义模块方法，包括 chageText.js 和 log.js，注意模块引入和导出123456789101112131415161718192021222324252627282930313233// chageText.jsdefine(function (require, exports, module) &#123; // var textContent = 'Hello Jam, Weclome to Seajs!'; // exports.text = textContent; // 自定义初始化方法 var init = function () &#123; var textContent = [ 'Hello World!', 'Hello Jam', 'Weclome to Seajs', \"It's working Day\", ]; var index = Math.floor(Math.random() * textContent.length); return textContent[index]; &#125;; // 另外一种方式导出 module.exports = &#123; init: init, &#125;;&#125;);// log.jsdefine(function (require, exports, module) &#123; console.log('Hello World!'); var changeText = require('changeText'); var $ = require('jquery'); var showText = function () &#123; $('#test').text(changeText.init()); &#125;; exports.showText = showText;&#125;); 第三方文件引用，下载一个 jquery 源文件，按如下修改，使其模块化，能被外部调用。其它第三方库文件也可以操作。123define(function (require, exports, module) &#123; // jquery 源码&#125;); 参考文献1、Seajs 使用实例入门介绍","tags":[{"name":"工具","slug":"工具","permalink":"https://liwenxin-jam.github.io/tags/工具/"}]},{"title":"gulp实现js、css、img合并和压缩","date":"2018-01-06T14:15:39.000Z","path":"2018/01/06/gulp实现js、css、img合并和压缩/","text":"人都是喜欢偷懒的，而偷懒也是进步的源泉。没有人喜欢做机械化的工作，都想着一键生成或搞掂。之前写过一篇关于借助 gulp 实现图片压缩功能和合并雪碧图，而这篇主要讲的是 gulp 实现 js、css、img 合并和压缩。 因为是基于 gulp，肯定是需要安装 gulp 环境，至于是安装的全局环境还是局部依赖，就看个人喜好。1234// 如果你之前有全局安装过一个版本的 gulp，请执行一下 npm rm --global gulp 来避免和 gulp-cli 冲突npm install --global gulp-cli// 基于项目局部安装依赖，需要先基于npm init -y初始化npm install --save-dev gulp 实现此功能需要安装的 gulp 工具有如下，需要各位自行下载依赖，分别有 gulp-htmlmin、gulp-imagemin、imagemin-pngcrush、gulp-minify-css、gulp-jshint、gulp-uglify、gulp-concat、gulp-rename、gulp-notify、jshint、del 等。在根目录创建一个 gulpfile.js 文件，文件内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// npm install gulp-htmlmin gulp-imagemin imagemin-pngcrush gulp-minify-css gulp-jshint gulp-uglify gulp-concat gulp-rename gulp-notify jshint@2.x gulp del --save-dev // 安装依赖方式// 引入 gulpvar gulp = require('gulp');// 引入组件var htmlmin = require('gulp-htmlmin'), // html压缩 imagemin = require('gulp-imagemin'), // 图片压缩 pngcrush = require('imagemin-pngcrush'), minifycss = require('gulp-minify-css'), // css压缩 jshint = require('gulp-jshint'), // js检测 uglify = require('gulp-uglify'), // js压缩 concat = require('gulp-concat'), // 文件合并 rename = require('gulp-rename'), // 文件更名 notify = require('gulp-notify'), // 提示信息 del = require('del'); // 删除文件夹// 删除文件及文件夹，在执行打包的时候，一般都需要先清理目标文件夹，以保证每次打包时，都是最新的文件。gulp.task('clean', function (cb) &#123; del( [ // 这里我们使用一个通配模式来匹配 `mobile` 文件夹中的所有东西 'dest/**/*', // 我们不希望删掉这个文件，所以我们取反这个匹配模式 '!dest/images/share-weixin.png', ], cb );&#125;);// 压缩htmlgulp.task('html', function () &#123; return gulp .src('src/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true &#125;)) .pipe(gulp.dest('./dest')) .pipe(notify(&#123; message: 'html task ok' &#125;));&#125;);// 压缩图片gulp.task('img', function () &#123; return gulp .src('src/images/*') .pipe( imagemin(&#123; progressive: true, svgoPlugins: [&#123; removeViewBox: false &#125;], use: [pngcrush()], &#125;) ) .pipe(gulp.dest('./dest/images/')) .pipe(notify(&#123; message: 'img task ok' &#125;));&#125;);// 合并、压缩、重命名cssgulp.task('css', function () &#123; return gulp .src('src/css/*.css') .pipe(concat('main.css')) .pipe(gulp.dest('dest/css')) .pipe(rename(&#123; suffix: '.min' &#125;)) .pipe(minifycss()) .pipe(gulp.dest('dest/css')) .pipe(notify(&#123; message: 'css task ok' &#125;));&#125;);// 检查jsgulp.task('lint', function () &#123; return gulp .src('src/js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default')) .pipe(notify(&#123; message: 'lint task ok' &#125;));&#125;);// 合并、压缩js文件gulp.task('js', function () &#123; return gulp .src('src/js/*.js') .pipe(concat('main.js')) .pipe(gulp.dest('dest/js')) .pipe(rename(&#123; suffix: '.min' &#125;)) .pipe(uglify()) .pipe(gulp.dest('dest/js')) .pipe(notify(&#123; message: 'js task ok' &#125;));&#125;);// 默认任务gulp.task('default', function () &#123; gulp.run('clean', 'img', 'css', 'lint', 'js', 'html'); // 监听html文件变化 gulp.watch('src/*.html', function () &#123; gulp.run('html'); &#125;); // 监听css文件变化 gulp.watch('src/css/*.css', ['css']); // 监听js文件变化 gulp.watch('src/js/*.js', ['lint', 'js']); // 监听images文件变化 gulp.watch('src/images/*', ['img']);&#125;); 调用测试123gulp // 省略task名称，默认会去查找default任务gulp clean // 清理打包文件夹gulp default // 有监听各种文件夹内容变化 参考文献1、gulp 实现 js、css,img 合并和压缩","tags":[{"name":"工具","slug":"工具","permalink":"https://liwenxin-jam.github.io/tags/工具/"}]},{"title":"require.js和r.js使用小结","date":"2017-12-25T13:34:12.000Z","path":"2017/12/25/require.js和r.js使用小结/","text":"这是一个基于 require.js 和 r.js 实现图片异步加载模块和合并打包 js 的测试项目。一开始会先给大家介绍一下 require.js 的简单用法，其次再会对比有没有 almond.js 库来实现 r.js 打包合并 js 文件。经过测试，大家会发现引用了 almond.js 打包合并文件，打包出来的文件会小比较多。 最早的时候，所有 Javascript 代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。使用 require.js 可以实现 js 文件的异步加载，避免网页失去响应；其次是管理模块之间的依赖性，便于代码的编写和维护。123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;requirejs-demo&lt;/title&gt; &lt;!-- async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。 --&gt; &lt;script src=\"js/require.js\" defer async=\"true\" data-main=\"js/main\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Hello World!&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 模块的加载行为可以进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的 paths 属性指定各个模块的加载路径。路径默认与 main.js 在同一个目录（js 子目录。如果这些模块在其他目录，比如 js/lib 目录，则有两种写法。一种是逐一指定路径，例如”jquery”: “lib/jquery.min”,直接改变基目录（baseUrl）;某个模块在另一台主机上，也可以直接指定它的网址;如果加载多个模块，就会发出多次 HTTP 请求，会影响网页的加载速度。因此，require.js 提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少 HTTP 请求数。比如 jQuery）符合 AMD 规范，更多的库并不符合。underscore 和 backbone 这两个库，都没有采用 AMD 规范编写。如果要加载它们的话，必须先定义它们的特征。123456789101112131415161718192021222324252627282930// main.jsconsole.log('加载main.js成功！');require.config(&#123; baseUrl: 'js/lib', paths: &#123; // \"jquery\": \"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min\", // \"jquery\": \"jquery.min\", // \"underscore\": \"underscore.min\", // \"backbone\": \"backbone.min\" domReady: 'domReady', text: '../../node_modules/text/text', math: '../math', myLib: '../myLib', &#125;, shim: &#123; // 每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。 // 'underscore': &#123; // exports: '_' // &#125;, // 'backbone': &#123; // deps: ['underscore', 'jquery'], // exports: 'Backbone' // &#125;, // 'jQuery.scroll': &#123; // deps: ['jquery'], // exports: 'jQuery.fn.scroll' // &#125; &#125;,&#125;); 第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。12345678910111213141516171819202122232425262728293031// 模块加载格式require(['moduleA', 'moduleB', 'moduleC'], function ( moduleA, moduleB, moduleC) &#123; // some code here&#125;);require(['math'], function (math) &#123; console.log(math.add(1, 1));&#125;);// require.js还提供一系列插件，实现一些特定的功能。// domready插件，可以让回调函数在页面DOM结构加载完成后再运行。// text和image插件，则是允许require.js加载文本和图片文件。npm install requirejs/text// 类似的插件还有json和mdown，用于加载json文件和markdown文件。// 插件下载地址： https://github.com/requirejs/requirejs/wiki/Plugins// 第一种方式require(['domReady', 'math'], function (domReady, math) &#123; domReady(function () &#123; // This function is called once the DOM is ready. // It will be safe to query the DOM and manipulate // DOM nodes in this function. console.log(math.add(1, 1)); &#125;);&#125;);// 第二种方式require(['domready!', 'math'], function (doc, math) &#123; console.log(math.add(1, 1));&#125;); 如果这个模块不依赖其他模块，那么 define()函数的第一个参数可以不是一个数组，但你可以告诉它是一个空数组。 12345678910// myLib.jsdefine(function () &#123; var doSomething = function () &#123; console.log('Weclome to Requirejs!'); &#125;; return &#123; doSomething: doSomething, &#125;;&#125;); 如果这个模块还依赖其他模块，那么 define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。123456789101112131415161718192021// math.js// define(function()&#123;// var add = function(x, y)&#123;// return x + y;// &#125;;// return &#123;// add: add// &#125;;// &#125;);define(['myLib', 'text!../../review.txt'], function (myLib, review) &#123; console.log(review); myLib.doSomething(); var add = function (x, y) &#123; // myLib.doSomething(); return x + y; &#125;; return &#123; add: add, &#125;;&#125;); r.js 打包，下面将会有两种情况的打包，前者是没有引入 almond 的情况下，后者是引入 almond 的情况。123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;almond-demo&lt;/title&gt; &lt;!-- &lt;script src=\"js/require.js\" data-main=\"js/main-built.js\"&gt;&lt;/script&gt; --&gt; &lt;script src=\"js/require.js\" data-main=\"js/main-almond-built.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello World! &lt;/body&gt;&lt;/html&gt; 配置打包命令，可以不配置，但在终端命令行需要手打的指令会比较长，建议还是配置好点。 1234567// build.js(&#123; baseUrl: 'js', name: 'main', optimize: 'none', out: 'js/main-built.js',&#125;); 入口文件，它依赖两个自定义库文件 cookie 和 util123456789// main.jsrequirejs.config(&#123; baseUrl: 'js',&#125;);require(['cookie', 'util'], function (Cookie, Util) &#123; Cookie.say('hello'); Util.say('hello');&#125;); cookie 文件12345678// cookie.jsdefine([], function () &#123; return &#123; say: function (msg) &#123; console.log('cookie:' + msg); &#125;, &#125;;&#125;); util 文件12345678// util.jsdefine([], function () &#123; return &#123; say: function (msg) &#123; console.log('util:' + msg); &#125;, &#125;;&#125;); 执行打包语句12// 这种情况下的打包文件会相对比起用almond方式打包的文件相对会较大node r.js -o build.js 引入 almond.js 库打包，注意 wrap 属性，如果没有 wrap 属性，相当于暴露了公共 API。例如在浏览器调试那里输入 var cookie = require(‘cookie’);12345678// build-almond.js(&#123; baseUrl: 'js', name: 'almond', include: 'main', out: 'js/main-almond-built.js', wrap: true, //如果需要调试某个模块可以去掉当前属性&#125;); 执行打包语句12// node r.js -o baseUrl=js name=almond include=main out=js/main-almond-built.js wrap=true optimize=nonenode r.js -o build-almond.js 参考文献1、Javascript 模块化编程（三）：require.js 的用法2、requirejs：杏仁的优化(almond)","tags":[{"name":"工具","slug":"工具","permalink":"https://liwenxin-jam.github.io/tags/工具/"}]},{"title":"gulp图片压缩与合并","date":"2017-11-15T13:35:37.000Z","path":"2017/11/15/gulp图片压缩与合并/","text":"人都是喜欢偷懒的，而偷懒也是进步的源泉。没有人喜欢做机械化的工作，都想着一键生成或搞掂。例如以前我们如果压缩图片一般会用 tinypng 在线压缩，而合并雪碧图需要用到 PS 来手动合成，本文是借助 gulp 实现图片压缩功能和合并雪碧图。 因为是基于 gulp，肯定是需要安装 gulp 环境，至于是安装的全局环境还是局部依赖，就看个人喜好。1234// 如果你之前有全局安装过一个版本的 gulp，请执行一下 npm rm --global gulp 来避免和 gulp-cli 冲突npm install --global gulp-cli// 基于项目局部安装依赖，需要先基于npm init -y初始化npm install --save-dev gulp 首先给大家介绍图片压缩功能，需要各位自行下载依赖，分别有 gulp-imagemin、imagemin-pngcrush、gulp del、gulp-notify 等等。在根目录创建一个 gulpfile.js 文件，文件内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142// npm install --D gulp del //安装依赖方式var gulp = require('gulp'), imagemin = require('gulp-imagemin'), // 图片压缩 pngcrush = require('imagemin-pngcrush'), del = require('del'), // 删除文件夹 notify = require('gulp-notify'); // 提示信息// 压缩图片gulp.task('img', function () &#123; return gulp .src('images/*') .pipe( imagemin(&#123; progressive: true, svgoPlugins: [&#123; removeViewBox: false &#125;], use: [pngcrush()], &#125;) ) .pipe(gulp.dest('./dist/images/')) .pipe(notify(&#123; message: 'img task ok' &#125;));&#125;);// 删除文件及文件夹，在执行打包的时候，一般都需要先清理目标文件夹，以保证每次打包时，都是最新的文件。gulp.task('clean', function (cb) &#123; del( [ // 这里我们使用一个通配模式来匹配 `mobile` 文件夹中的所有东西 'dist/**/*', // 我们不希望删掉这个文件，所以我们取反这个匹配模式 '!dist/images/share-weixin.png', ], cb );&#125;);// 默认任务gulp.task('default', function () &#123; gulp.run('clean', 'img'); // 前者是监听路径，后者是task任务名称 gulp.watch('images/*.png', ['img']);&#125;); 调用测试1234gulp // 省略task名称，默认会去查找default任务gulp cleangulp imggulp default // 有监听图片文件夹内容变化 图片合并雪碧图有两种方式，一种是用 spritesmith 插件，另外一种是 gulp-css-spriter 插件。注释 1:Algorithm 有四个可选值分别为 top-down、left-right、diagonal、alt-diagonal、binary-tree。注释 2cssTemplate 是生成 css 的模板文件可以是字符串也可以是函数。如果是字符串则是对于相对的模板地址。1234567891011121314151617var gulp = require('gulp'), spritesmith = require('gulp.spritesmith');// spritesmith插件方式gulp.task('spritesmith1', function () &#123; return gulp .src('images/*.png') // 需要合并的图片地址 .pipe( spritesmith(&#123; imgName: 'images/sprite.png', // 保存合并后图片的地址 cssName: 'css/sprite.css', // 保存合并后对于css样式的地址 padding: 5, // 合并时两个图片的间距 algorithm: 'binary-tree', // 注释1 cssTemplate: 'css/spritesmithTemplateStr.css', // 注释2 &#125;) ) .pipe(gulp.dest('dist/'));&#125;); 在根目录 css 文件夹下新增 spritesmithTemplateStr.css 模板12345678&#123;&#123;#sprites&#125;&#125;.icon-&#123;&#123;name&#125;&#125;&#123; background-image: url(\"&#123;&#123;escaped_image&#125;&#125;\"); background-position: &#123;&#123;px.offset_x&#125;&#125; &#123;&#123;px.offset_y&#125;&#125;; width: &#123;&#123;px.width&#125;&#125;; height: &#123;&#123;px.height&#125;&#125;;&#125;&#123;&#123;/sprites&#125;&#125; cssTemplate 如果是函数式的方式123456789101112131415161718192021222324252627282930313233343536373839gulp.task('spritesmith2', function () &#123; return gulp .src('images/*.png') // 需要合并的图片地址 .pipe( spritesmith(&#123; imgName: 'images/sprite.png', // 保存合并后图片的地址 cssName: 'css/sprite.css', // 保存合并后对于css样式的地址 padding: 5, // 合并时两个图片的间距 algorithm: 'binary-tree', cssTemplate: function (data) &#123; var arr = []; data.sprites.forEach(function (sprite) &#123; arr.push( '.icon-' + sprite.name + '&#123;' + \"background-image: url('\" + sprite.escaped_image + \"');\" + 'background-position: ' + sprite.px.offset_x + ' ' + sprite.px.offset_y + ';' + 'width:' + sprite.px.width + ';' + 'height:' + sprite.px.height + ';' + '&#125;\\n' ); &#125;); return arr.join(''); &#125;, &#125;) ) .pipe(gulp.dest('dist/'));&#125;); gulp-css-spriter 插件跟 gulp-css-spriter 插件有点区别，它是允许保留你原来的样式，只是自动调整你原来的 css 代码里的图片地址。12345678910111213141516171819202122gulp.task('spriter', function () &#123; return gulp .src('./css/spriter.css') // spriter.css这个样式里面什么都不用改，是你想要合并的图就要引用这个样式。 很重要。 .pipe( spriter(&#123; // The path and file name of where we will save the sprite sheet spriteSheet: './dist/images/spritesheet.png', // 这是雪碧图自动合成的图。 很重要 // Because we don't know where you will end up saving the CSS file at this point in the pipe, // we need a litle help identifying where it will be. pathToSpriteSheetFromCSS: '../images/spritesheet.png', // 这是在css引用的图片路径，很重要 &#125;) ) .pipe(gulp.dest('./dist/css')); //最后生成出来&#125;);// 默认任务gulp.task('default', function () &#123; gulp.run('clean', 'img', 'spriter'); // Watch image files， 前者是监听路径，后者是task任务名称 gulp.watch('images/*.png', ['img', 'spriter']);&#125;); 在根目录 css 文件夹下新增 spriter.css 样式，测试匹配上面 gulp-css-spriter 插件合并图需要修改的引入样式123456789101112131415161718192021222324.icon-finished-Furniture-menu1 &#123; display: none; background-image: url('../images/finished-Furniture-menu1.png');&#125;.icon-finished-Furniture-menu1_active &#123; color: red; background-image: url('../images/finished-Furniture-menu1_active.png');&#125;.icon-finished-Furniture-menu2 &#123; font-size: 20px; background-image: url('../images/finished-Furniture-menu2.png');&#125;.icon-finished-Furniture-menu2_active &#123; border: 1px solid #ccc; background-image: url('../images/finished-Furniture-menu2_active.png');&#125;.icon-finished-Furniture-menu3 &#123; display: block; background-image: url('../images/finished-Furniture-menu3.png');&#125;.icon-finished-Furniture-menu3_active &#123; float: left; background-image: url('../images/finished-Furniture-menu3_active.png');&#125; 调用测试123456gulp //省略task名称，默认会去查找default任务gulp cleangulp spritesmith1gulp spritesmith2gulp spritergulp default //有监听图片文件夹内容变化 参考文献1、gulp 多张图片自动合成雪碧图2、把所有的小图标一起做成雪碧图吧 请用 gulp-css-spriter","tags":[{"name":"工具","slug":"工具","permalink":"https://liwenxin-jam.github.io/tags/工具/"}]},{"title":"jQuery插件的写法以及使用","date":"2017-10-04T12:15:23.000Z","path":"2017/10/04/jQuery插件的写法以及使用/","text":"如今做 web 开发，jquery 几乎是必不可少的，同时 jquery 插件也是不断的被大家所熟知，以及运用。写插件的方式有两种，下边我会举栗子说明。 dom 结构，后面的例子都以这个结构做演示。123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"jquery-3.1.1.js\"&gt;&lt;/script&gt; &lt;script src=\"index.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"formatFont\"&gt;Hello World!&lt;/p&gt; &lt;p class=\"changeFont1\"&gt;Weclome to Javascript!&lt;/p&gt; &lt;p class=\"changeFont2\"&gt;Weclome to Javascript!&lt;/p&gt; &lt;p class=\"changeFont3\"&gt;Weclome to Javascript!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 方式一，扩展 jQuery 对象本身，相当于添加一个静态方法，实质是浅复制123456789101112131415161718192021222324252627282930313233343536373839(function ($) &#123; // 默认参数 var defaults = &#123; color: 'blue', size: '30px' &#125;; // 重载版本：jQuery.extend([deep], target, object1, [objectN]) // 注意参数不同，调用方式区别，建议jQuery.fn.extend绑定 // 调用方式:$.color($(\".formatFont\"), &#123;color: 'red', size: '16px'&#125;); $.extend(&#123; color: function (targetArr, options) &#123; if (!isValid(options)) &#123; return this; &#125; options = $.extend(&#123;&#125;, defaults, options); // return jQuery对象，让我们的插件也支持链式调用 return targetArr.each(function () &#123; // 这里的this就是jQuery对象，它是一个数组 // 获取当前dom 的 jQuery对象，这里的this是当前循环的dom $(this).css(&#123; color: options.color, 'font-size': options.size &#125;); &#125;); &#125;, color2: function (targetArr, options) &#123; if (!isValid(options)) &#123; return this; &#125; options = $.extend(&#123;&#125;, defaults, options); // return jQuery对象，让我们的插件也支持链式调用 return targetArr.each(function () &#123; // 这里的this就是jQuery对象，它是一个数组 // 获取当前dom 的 jQuery对象，这里的this是当前循环的dom $(this).css(&#123; color: options.color, 'font-size': options.size &#125;); &#125;); &#125;, &#125;); // 私有方法，检测参数是否合法 function isValid(options) &#123; return !options || (options &amp;&amp; typeof options === 'object') ? true : false; &#125;&#125;)(jQuery); 调用测试 12345678// 第一种插件写法调用$.color($('.formatFont1'), &#123; color: 'red', size: '16px' &#125;);$.color($('.changeFont2'), &#123; color: 'pink', size: '24px' &#125;);// 对于链式操作不太友好$.color($.color($('.changeFont3'), &#123; color: 'pink', size: '24px' &#125;), &#123; color: 'red', size: '16px',&#125;); 方式二，扩展 jQuery 实例对象，添加实例方法。也就是原型 prototype，jQuery 给 prototype 定义一个别名叫 fn。在$.fn 上拓展有两种方式，看你个人业务需求和习惯。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778(function ($) &#123; // 默认参数 var defaults = &#123; color: 'blue', size: '30px' &#125;; // 调用方式:$(\".formatFont\").color(); // 方式一，一次只能写一种方法 $.fn.color = function (options) &#123; if (!isValid(options)) &#123; return this; &#125; options = $.extend(&#123;&#125;, defaults, options); // return jQuery对象，让我们的插件也支持链式调用 return this.each(function () &#123; // 这里的this就是jQuery对象，它是一个数组 // 获取当前dom 的 jQuery对象，这里的this是当前循环的dom $(this).css(&#123; color: options.color, 'font-size': options.size &#125;); &#125;); &#125;; $.fn.color2 = function (options) &#123; if (!isValid(options)) &#123; return this; &#125; options = $.extend(&#123;&#125;, defaults, options); // return jQuery对象，让我们的插件也支持链式调用 return this.each(function () &#123; // 这里的this就是jQuery对象，它是一个数组 // 获取当前dom 的 jQuery对象，这里的this是当前循环的dom $(this).css(&#123; color: options.color, 'font-size': options.size &#125;); &#125;); &#125;; // 方式二，可以写多种方法在一起 $.fn.extend(&#123; color: function (options) &#123; if (!isValid(options)) &#123; return this; &#125; options = $.extend(&#123;&#125;, defaults, options); // return jQuery对象，让我们的插件也支持链式调用 return this.each(function () &#123; // 这里的this就是jQuery对象，它是一个数组 // 获取当前dom 的 jQuery对象，这里的this是当前循环的dom $(this).css(&#123; color: options.color, 'font-size': options.size &#125;); // 格式化加粗文本 var markup = $(this).html(); markup = $.fn.color.format(markup); $(this).html(markup); &#125;); &#125;, color2: function (options) &#123; if (!isValid(options)) &#123; return this; &#125; options = $.extend(&#123;&#125;, defaults, options); // return jQuery对象，让我们的插件也支持链式调用 return this.each(function () &#123; // 这里的this就是jQuery对象，它是一个数组 // 获取当前dom 的 jQuery对象，这里的this是当前循环的dom $(this).css(&#123; color: options.color, 'font-size': options.size &#125;); &#125;); &#125;, &#125;); // 公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。 // 个人感觉意义不太大，如果又需要默认又需要自定义，这个就变成鸡肋 $.fn.color.format = function (str) &#123; return '&lt;strong&gt;' + str + '&lt;/strong&gt;'; &#125;; $.fn.color2.format = function (str) &#123; return '&lt;em&gt;' + str + '&lt;/em&gt;'; &#125;; // 私有方法，检测参数是否合法 function isValid(options) &#123; return !options || (options &amp;&amp; typeof options === 'object') ? true : false; &#125;&#125;)(jQuery); 调用测试 12345678910111213// 第二种插件写法调用$('.formatFont').color(); // $(\".formatFont\").color(&#123;&#125;); 也可以$('.changeFont1').color(&#123; color: 'red', size: '16px' &#125;);$('.changeFont2').color2(&#123; color: 'pink', size: '24px' &#125;);// 调用者覆盖插件暴露的共公方法$.fn.color.format = function (txt) &#123; return '&lt;em&gt;' + txt + '&lt;/em&gt;';&#125;;$('.changeFont3') .color2(&#123; color: 'pink', size: '24px' &#125;) .color(&#123; color: 'red', size: '16px' &#125;);$('*').color(&#123; color: 'red', size: '16px' &#125;); // 通配符循环 最后附上 jQuery 源码 extend，目的是实现浅复制或深复制。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051jQuery.extend = jQuery.fn.extend = function () &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; if (typeof target === 'boolean') &#123; deep = target; target = arguments[i] || &#123;&#125;; i++; &#125; if (typeof target !== 'object' &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; if (i === length) &#123; target = this; i--; &#125; for (; i &lt; length; i++) &#123; if ((options = arguments[i]) != null) &#123; for (name in options) &#123; src = target[name]; copy = options[name]; if (target === copy) &#123; continue; &#125; if ( deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; target[name] = jQuery.extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; &#125; &#125; &#125; &#125; return target;&#125;; 参考文献1、jQuery 插件的写法以及使用2、什么？你还不会写 JQuery 插件","tags":[{"name":"笔记","slug":"笔记","permalink":"https://liwenxin-jam.github.io/tags/笔记/"}]},{"title":"离线缓存Manifest","date":"2017-09-21T11:42:39.000Z","path":"2017/09/21/离线缓存Manifest/","text":"什么是离线 Web 应程序？例如坐在火车上，过了一个隧道（15 分钟），便无法访问网站，十分不便。而离线 web 应用允许我们在脱机时与网站进行交互。当客户端本地与 web 应用程序的服务器没有建立连接时，也能正常在客户端本地使用该 web 应用程序进行有关操作。Web 应用程序已经变的越来越复杂，很多领域都在利用 Web 应用程序。但是，它有一个致命的缺点：如果用户没有和 Internet 建立连接，他就不能利用这个 web 应用程序了。 H5 新增了一个 API，它使用一个本地缓存机制很好的解决了这个问题，使离线应用程序的开发成为了可能。要想使 web 应用程序在离线状态的时候也能正常工作，就必须把所有构成 web 应用程序的资源文件，如 HTML 文件、CSS 文件、JavaScript 脚本文件等放在本地缓存中，当服务器没有和 Internet 建立连接时，也可以利用本地缓存中的资源文件正常运行 web 应用程序。1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" manifest=\"cache.manifest\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;manifest-Demo&lt;/title&gt; &lt;style type=\"text/css\"&gt; #editor &#123; width: 100%; height: 250px; &#125; #statusline &#123; width: 100%; &#125; &lt;/style&gt; &lt;script src=\"index.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Hello World!&lt;/div&gt; &lt;div id=\"toobar\"&gt; &lt;button id=\"savebutton\" onclick=\"save()\"&gt;save&lt;/button&gt; &lt;button onclick=\"sync()\"&gt;SyncNote&lt;/button&gt; &lt;button onclick=\"applicationCache.update()\"&gt;UpdateApplication&lt;/button&gt; &lt;textarea id=\"editor\"&gt;&lt;/textarea&gt; &lt;div id=\"statusline\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; cache.manifest 内容如下：1234567891011121314151617CACHE MANIFEST#version 3.1 (更改这个数字以便让浏览器重新下载)// 需要离线存储的资源列表，包含manifest文件的页面将被自动离线存储，所以不需要将该页面罗列出来。CACHE:index.htmlindex.js// 在线状态才可以访问的资源，不会被离线存储。// 可以指定在线白名单，即列出我们不希望离线存储的文件，因为通常它们的内容需要联网访问才有意义。// 我们可以使用快捷方式：通配符*。这将告诉浏览器，应用服务器中获取没有在显示部分中提到的任何文件或URL。NETWORK:*// 如果第一个资源访问失败，那么就是用第二个资源来替代FALLBACK:online.js local.js index.js 内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// 定义全局变量var editor, statusline, savebutton, idletimer;// 首次载入应用window.onload = function () &#123; // 第一次载入时，初始化本地保存 if (localStorage.note == null) localStorage.note = ''; if (localStorage.lastModified == null) localStorage.lastModified = 0; if (localStorage.lastSaved == null) localStorage.lastSaved = 0; // 查找编辑器UI元素，并初始化全局变量 editor = document.getElementById('editor'); statusline = document.getElementById('statusline'); savebutton = document.getElementById('savebutton'); editor.value = localStorage.note; // 初始化编辑器，将保存的笔记数据填充到内容 editor.disabled = true; // 同步前禁止编辑 // 当输入框内容发生变化 editor.addEventListener( 'input', function (e) &#123; // 将新的内容保存至localStorage localStorage.note = editor.value; localStorage.lastModified = Date.now(); // 重置闲置计时器 if (idletimer) clearTimeout(idletimer); idletimer = setTimeout(save, 5000); // 启用保存按钮 savebutton.disabled = false; &#125;, false ); // 每次载入应用程序时，尝试同步服务器 sync();&#125;;// 离开页面前保存数据到服务器window.onbeforeunload = function () &#123; if (localStorage.lastModified &gt; localStorage.lastSaved) save();&#125;;// 离线时，告知用户window.onoffline = function () &#123; status('Offline');&#125;;// 再次返回在线状态时，进行同步window.ononline = function () &#123; sync();&#125;;// 当有新版本应用的时候，提醒用户// 也可使用location.reload()放大来强制刷新应用window.applicationCache.onupdateready = function () &#123; status('A new version of this application is available. Reload to run it');&#125;;// 当没有新版本的时候也通知用户window.applicationCache.onnoupdate = function () &#123; status('You are running the latest version of the application.');&#125;;// 状态栏显示相关信息提示function status(msg) &#123; statusline.innerHTML = msg;&#125;// 每当笔记本内容更新后，如果用户停止编辑超过5分钟// 就会自动将笔记文本上传至服务器（在线状态下）function save() &#123; if (idletimer) clearTimeout(idletimer); idletimer = null; if (navigator.onLine) &#123; var xhr = new XMLHttpRequest(); xhr.open('PUT', '/note'); xhr.send(editor.value); xhr.onload = function () &#123; localStorage.lastSaved = Date.now(); savebutton.disabled = true; &#125;; &#125;&#125;// 检查服务端是否有新版本的笔记，若无，则将当前版本保存到服务器端function sync() &#123; if (navigator.onLine) &#123; //这里调整至服务器接口保存地址 var xhr = new XMLHttpRequest(); xhr.open('GET', '/note'); xhr.send(); xhr.onload = function () &#123; var remoteModTime = 0; if (xhr.status == 200) &#123; var remoteModTime = xhr.getResponseHeader('Last-Modified'); remoteModTime = new Date(remoteModTime).getTime(); &#125; if (remoteModTime &gt; localStorage.lastModified) &#123; status('Newer note found on server.'); var useit = confirm( 'There is a newer version of the note\\n' + 'on the server. Click Ok to use that version\\n' + 'or click Cancel to continue editing this\\n' + 'version and overwrite the server' ); var now = Date.now(); if (useit) &#123; editor.value = localStorage.note = xhr.responseText; localStorage.lastSaved = now; status('Newest version downloaded.'); &#125; else status('Ignoring newer version of the note.'); localStorage.lastModified = now; &#125; else status('You are editing the current version of the note.'); if (localStorage.lastModified &gt; localStorage.lastSaved) &#123; save(); &#125; editor.disabled = false; // 再次启用编辑器 editor.focus(); // 将光标定位到编辑器中 &#125;; &#125; else &#123; // 离线状态下，不能同步 status(\"Can't sync while offline\"); editor.disabled = false; editor.focus(); &#125;&#125; 个人想法，移动端如果是想实现离线保存操作，大部分可以借助 localStorage 保存操作队列数据，当网络正常，提示用户主动点击按钮触发重新上传至服务器。 参考文献1、HTML5 新特性之离线缓存技术","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"本地缓存Cookie,LocalStorge,SessionStorge","date":"2017-08-11T14:23:21.000Z","path":"2017/08/11/本地缓存Cookie,LocalStorge,SessionStorge/","text":"sessionStorage、localStorage、cookie 都是在浏览器端存储的数据。区别：cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。 Cookie 浏览器和服务器端都可以设置，传统的用来存储数据的方法。但 Cookie 技术主要是客户端的解决方案，Cookie 就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。cookie 的内容主要包括：名字，值，过期时间，路径和域。单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。12345678910111213141516171819202122232425262728293031323334353637383940// 设置cookiefunction setCookie(cname, cvalue, exdays) &#123; var d = new Date(); d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000); var expires = 'expires=' + d.toGMTString(); document.cookie = cname + '=' + cvalue + '; ' + expires;&#125;// 获取cookiefunction getCookie(cname) &#123; var name = cname + '='; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return '';&#125;// 删除cookiefunction delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = getCookie(name); if (cval != null) document.cookie = name + '=' + cval + ';expires=' + exp.toGMTString();&#125;// 验证cookiefunction checkCookie() &#123; var user = getCookie('username'); if (user &amp;&amp; user != '') &#123; alert('欢迎 ' + user + ' 再次访问'); &#125; else &#123; user = prompt('请输入你的名字:', ''); if (user != '' &amp;&amp; user != null) &#123; setCookie('username', user, 30); &#125; &#125;&#125;checkCookie(); cookie 与 localStorage cookie 是可以伪造的，所以建议还是不要明文存储，建议加密处理后再保存。如果觉得自己处理 cookie 麻烦，可以借助第三方插件，如 jquery.cookie。具体用法各位看官自己去官网下载插件和看 API 了解和实践，这里就不列举它的 API 使用说明。 localStorage 这是一种持久化的存储方式，也就是说如果不手动清除，数据就永远不会过期。它也是采用 Key-Value 的方式存储数据，底层数据接口是 sqlite，按域名将数据分别保存到对应数据库文件里。它能保存更大的数据大概 5MB 左右，同时保存的数据不会再发送给服务器，避免带宽浪费。 123456789101112// 以“key”为名称存储一个值“value”localStorage.setItem('key', 'value');// 获得storage中的个数console.log(localStorage.length); //1// 获得storage中第n个元素对的键值（第一个元素是0）console.log(localStorage.key(0)); //key// 获取名称为“key”的值console.log(localStorage.getItem('key')); //value// 删除名称为“key”的信息。localStorage.removeItem('key');// 清空localStorage中所有信息，需要慎重使用localStorage.clear(); sessionStorage 和服务器端使用的 session 类似，是一种会话级别的缓存，关闭浏览器会数据会被清除。不过有点特别的是它的作用域是窗口级别的，也就是说不同窗口间的 sessionStorage 数据不能共享的。使用方法（和 localStorage 完全相同）123456789101112// 以“key”为名称存储一个值“value”sessionStorage.setItem('key', 'value');// 获得storage中的个数console.log(sessionStorage.length); //1// 获得storage中第n个元素对的键值（第一个元素是0）console.log(sessionStorage.key(0)); //key// 获取名称为“key”的值console.log(sessionStorage.getItem('key')); //value// 删除名称为“key”的信息。sessionStorage.removeItem('key');// 清空localStorage中所有信息，需要慎重使用sessionStorage.clear(); 使用场景： localStorage 可以用来统计页面访问次数。 sessionStorage 可以用来统计当前页面元素的点击次数。 cookie 一般存储用户名密码相关信息，一般使用 escape 转义编码后存储，解决使用 unescape。 参考文献1、菜鸟教程 JavaScriptCookie2、前端几种本地缓存机制","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"apply、call、bind的区别和用法","date":"2017-07-03T15:12:51.000Z","path":"2017/07/03/apply、call、bind的区别和用法/","text":"在 js 中，call、apply 和 bind 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中 other 没有 say 方法），但是其他的有（本栗子中 person 有 say 方法），我们可以借助 call、apply 或 bind 用其它对象的方法来操作。由此可见，这三种方法都是用来改变函数的 this 对象的指向的。有共同相似点：1、都是用来改变函数的 this 对象的指向的 2、第一个参数都是 this 要指向的对象 3、都可以继续传递参数 无传参的情况1234567891011121314151617var person = &#123; name: '小菜', gender: '男', say: function () &#123; console.log(this.name + ',' + this.gender); &#125;,&#125;;var other = &#123; name: 'hathy', gender: '女',&#125;;person.say(); // hathy,女// 如果我们想要用xb的say()方法输出other的数据，要怎么办呢？// 其实call和apply方法，都是对函数的直接调用，但是bind()方法需要加上()来执行person.say.call(other); // hathy,女person.say.apply(other); // hathy,女person.say.bind(other)(); // hathy,女 带传参的情况，调用参数的形式有区别。标准格式参考：1、func.call(this, arg1, arg2);2、func.apply(this, [arg1, arg2]);3、func.bind(this, arg1, arg2)();123456789101112131415161718192021var person = &#123; name: '小菜', gender: '男', say: function (age, school) &#123; console.log(this.name + ',' + this.gender + '---' + age + ',' + school); &#125;,&#125;;var other = &#123; name: 'hathy', gender: '女',&#125;;// call()和apply()函数的用法其实是一样的，只是传参的形式不一样，这是他们最大的差别// bind()跟call()传参很像，返回的其实还是一个函数，并没有执行person.say.call(other, 28, '清华大学'); // hathy,女---28,清华大学person.say.apply(other, [27, '北京大学']); // hathy,女---27,北京大学person.say.bind(other, 28, '清华大学')(); // hathy,女---28,清华大学// 定义全局变量var name = 'xx';var gender = '男';// 不指定上下文对象，用null代表将执行上下文交回给全局作用域person.say.call(null, 28, '清华大学'); //xx,男---28,清华大学 某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call。而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。12345678910111213141516171819202122// 数组之间追加var array1 = [12, 'foo', &#123; name: 'Joe' &#125;, -2458];var array2 = ['Doe', 555, 100];console.log(Array.prototype.push.apply(array1, array2)); // 7 == array1.length// 获取数组中的最大值和最小值var numbers = [5, 458, 120, -215];var maxInNumbers1 = Math.max.apply(Math, numbers), // 458 maxInNumbers2 = Math.max.call(Math, 5, 458, 120, -215); // 458// 验证是否是数组（前提是toString()方法没有被重写过）function isArray(obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]';&#125;console.log(isArray(array1)); // true// 类（伪）数组使用数组方法var domNodes = Array.prototype.slice.call(document.getElementsByTagName('*'));// 自定义日志方法，内部代理console.logfunction myLog() &#123; var args = Array.prototype.slice.call(arguments); args.unshift('(tips)'); console.log.apply(console, args);&#125;myLog(1, 2); // (tips) 1 2 bind 函数的理解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 单体模式中，通常我们会使用_this,that,self等保存this这样我们可以在改变了上下文之后继续引用到它var foo = &#123; bar: 1, eventBind: function () &#123; var _this = this; document.body.onclick = function () &#123; console.log(_this.bar); // 1 注意需要设html,body的height为100% &#125;; &#125;,&#125;;foo.eventBind();// 使用bind()可以更加优雅的解决这个问题var foo = &#123; bar: 1, eventBind: function () &#123; document.body.onclick = function () &#123; /* Act on the event */ console.log(this.bar); //1 &#125;.bind(this); &#125;,&#125;;foo.eventBind();// 当回调函数被执行的时候，this便指向foo对象。再来一个简单的栗子：var other = function () &#123; console.log(this.bar);&#125;;other(); // undefinedvar func = other.bind(foo);func(); // 1// 在Javascript中，多次bind()是无效的。更深层次的原因，bind()的实现，相当于使用函数在内部包了一个call/apply，第二次bind()相当于再包住第一次bind(),故第二次以后的bind是无法生效的var bar = function () &#123; console.log(this.x);&#125;;var foo = &#123; x: 3,&#125;;var sed = &#123; x: 4,&#125;;var func = bar.bind(foo).bind(sed);func(); // 3var fiv = &#123; x: 5,&#125;;var func = bar.bind(foo).bind(sed).bind(fiv);func(); // 3 附上 bind 实现的源码实现，其本质是内部调用 apply123456789// the .bind method from prototype.jsFunction.prototype.bind = function () &#123; var fn = this, args = Array.prototype.slice.call(arguments), object = args.shift(); return function () &#123; return fn.apply(object, args.concat(Array.prototype.slice.call(arguments))); &#125;;&#125;; 参考文献1、apply， call， bind 在 js 中的区别2、深入浅出妙用 Javascript 中 apply、call、bind","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"Javascript中this的用法","date":"2017-06-25T13:32:44.000Z","path":"2017/06/25/Javascript中this的用法/","text":"我们在写 js 时，特别是用到回调函数时，经常会发现 this 指代的对象总是可能脱离自己的思路而发生改变。面向对象语言的特性告诉我们 this 始终指代它的调用者，而在 js 中回调函数中内部的 this 默认指向全局环境即最终上下文，所以很多时候我们不作 this 对象的声明绑定，就会发生指向错误，找不到我们想要的值。 函数声明式，没有 return 一个对象，此时函数内的 this 相当于全局 window12345678910111213141516function test() &#123; this.a = 1; console.log(a);&#125;test(); // 1console.log(a); // 1console.log(this.a); // 1console.log(window.a); // 1// 局部变量function test() &#123; var a = 1; console.log(a); // 1 console.log(this.a); // undefined&#125;test(); 作为对象方法调用，this 指代上级对象1234567function test() &#123; console.log(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 作为构造函数调用，this 指代 new 出的对象。构造函数一般首字母大写，需要用 new 来声明对象，区别普通 function1234567var x = 2;function Test() &#123; this.x = 1; // 为了表明这时this不是全局对象&#125;var o = new Test();console.log(o.x); // 1console.log(this.x); // 2 函数有 return 对象的时候，this 指向构造函数对象本身。return 返回多个值，通过对象的属性访问。123456789101112131415161718192021222324252627function Test() &#123; this.b = 1; // this = Test&#123;&#125; return &#123; a: 2, &#125;;&#125;var o = new Test();console.log(o.a); // 2console.log(this.b); // undefined// 在JavaScript构造函数中：如果return值类型，那么对构造函数没有影响，实例化对象返回空对象；如果return引用类型（数组，函数，对象），那么实例化对象就会返回该引用类型；function Super(a) &#123; this.a = a; return 123;&#125;Super.prototype.sayHello = function () &#123; console.log('Hello');&#125;;function Super1(a) &#123; this.a = a; return &#123; a: 2 &#125;;&#125;Super1.prototype.sayHello = function () &#123; console.log('Hello');&#125;;console.log(new Super(1)); // 返回Super&#123;a:1&#125;,有原型方法sayHelloconsole.log(new Super1(2)); // 返回Object&#123;a:2&#125;,没有原型方法sayHello ES6 中引入了箭头函数，箭头函数使用操作符=&gt;定义。箭头函数不使用上面 4 种 this 绑定规则，而是根据外层作用域来决定 this。foo 内部的箭头函数创建时，foo 函数内 this 绑定到 obj1 上，bar(箭头函数)的 this 也会绑定到 obj1 上，箭头函数内的 this 是不能被修改的。123456789101112function foo() &#123; // this.b = 1; //this = Test&#123;&#125; return (a) =&gt; &#123; console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2 &#125;;var obj2 = &#123; a: 3 &#125;;var bar = foo.call(obj1);bar.call(obj2); // 2 参考文献1、JS 中 this 的四种用法","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"Javascript闭包","date":"2017-05-16T11:13:28.000Z","path":"2017/05/16/Javascript闭包/","text":"闭包其实就是函数嵌套函数，内部函数可以使用外部函数的参数和变量。但，这还不是闭包。当你 return 的是内部 function 时，就是一个闭包。JS 里处理 object 时是用到引用传递的，那么，你调用方法 Function 时传递一个 object，foo 函数 return 的闭包也会引用最初那个 object！ 以下的例子的变量 a 和 b 都不会被 JS 的垃圾回收机制所收回，因为变量 a 和 b 都还要在内部函数 bbb 中引用，所以不会被 JS 的垃圾回收机制所收回。JS 存在垃圾回收机制：节省内存。123456789101112function aaa(b) &#123; var a = 12; function bbb() &#123; alert(a); alert(b); &#125; return bbb;&#125;var ccc = aaa(100);// result: a == 12，b = 100ccc(); 使用闭包需要注意的地方？在 IE 下会引发内存泄漏的问题使用闭包的好处，如下：1.希望一个变量长期驻扎在内存当中 2.避免全局变量的污染当然理解了 JS 的执行的环境和作用域链之后，闭包也成了显而易见的东西，但是我们也不可以滥用闭包。从下面的例子可以看出，闭包会使子函数保持其作用域链的所有变量及函数在内存中，内存消耗很大，建议尽量销毁父函数不再使用的变量(类似置为 a = null;就行了)1234567891011121314151617//全局作用域var a = 12;function aaa() &#123; a++; alert(a);&#125;aaa(); // result: a = 13aaa(); // result: a = 14;// 局部作用域function aaa() &#123; var a = 12; a++; alert(a);&#125;aaa(); // result: a = 13aaa(); // result: a = 13 闭包的写法有多种方式，看业务需求和个人习惯。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//函数声明式function aaa() &#123; var a = 12; return function () &#123; a++; alert(a); &#125;;&#125;var result = aaa();result(); // result: a = 13result(); // result: a = 14// 将函数声明变成函数表达式的写法var aaa = (function () &#123; var a = 12; return function () &#123; a++; alert(a); &#125;;&#125;)();aaa(); // result: a = 13aaa(); // result: a = 14// 模块化代码的写法var aaa = (function () &#123; var a = 12; function bbb() &#123; a++; alert(a); &#125; function ccc() &#123; a++; alert(a); &#125; return &#123; b: bbb, c: ccc, &#125;;&#125;)();// 调用方法aaa.b(); // result: a = 13aaa.b(); // result: a = 14aaa.c(); // result: a = 15aaa.c(); // result: a = 16 Javascript 闭包解决 i 值循环问题123456789101112131415161718192021222324252627282930313233343536373839404142window.onload = function () &#123; var oWrap = document.getElementById('wrap'); var aBtn = oWrap.getElementsByTagName('button'); var nowIndex = 0; // alert(aBtn.length); // result: length = 3 for (var i = 0; i &lt; aBtn.length; i++) &#123; // aBtn[i].onclick = function () &#123; // 这里获取到的永远是i = 3 // alert(i); // &#125;; // 第一种解决办法，添加自定义索引值 /** * 为当前点击的按钮添加自定义索引值，记录我点的是第几个 * 按钮 */ // aBtn[i].index = i; // aBtn[i].onclick = function () &#123; // nowIndex = this.index; // result: correct // alert(nowIndex); // &#125;; // 第二种写法，通过闭包将i值传入进来 // (function (a) &#123; // aBtn[a].onclick = function () &#123; // result: correct // alert(a); // &#125;; // &#125;)(i); /** * 第三种写法，通过闭包将i值传入进来，然后再将i值 * 通过一个匿名函数返回出去即可 */ aBtn[i].onclick = (function (a) &#123; return function () &#123; alert(a); &#125;; &#125;)(i); &#125;&#125;; IE 下内存泄漏的解决方案，在同一个作用域内（全局域或者函数域内），如果出现 js 对象引用 dom 对象，该 dom 对象又引用同一个作用域内的 js 对象时，将发生泄漏。1234567891011121314151617181920212223// 获取div中id的值window.onload = function () &#123; var oDiv = document.getElementById('div1'); oDiv.onclick = function () &#123; // 这样的获取div中id的属性值在IE下会引发内存泄漏的问题 alert(this.id); &#125;; // 第一种解决IE下内存泄漏的方案 window.onunload = function () &#123; oDiv.onclick = null; &#125;;&#125;;// 第二种解决IE下内存泄漏的方案window.onload = function () &#123; var oDiv = document.getElementById('div1'); // 在这里先将要获取div中的id属性值先用变量存起来 var id = oDiv.id; oDiv.onclick = function () &#123; alert(id); &#125;;&#125;;","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"jquery.validation插件学习","date":"2017-04-06T14:12:53.000Z","path":"2017/04/06/jquery.validation插件学习/","text":"jQuery Validate 插件为表单提供了强大的验证功能，让客户端表单验证变得更简单，同时提供了大量的定制选项，满足应用程序各种需求。该插件捆绑了一套有用的验证方法，包括 URL 和电子邮件验证，同时提供了一个用来编写用户自定义方法的 API。所有的捆绑方法默认使用英语作为错误信息，且已翻译成多国语言。 jquery.validationr 插件可以到官网下载，教程可以参考菜鸟教程 jquery.validate 是基于 jquery 库的，所以需要先引进 jquery 库。错误默认提示都是英文的，如果需要使用中文，可以引进 messages_zh.js 文件。jQuery.Validate 提供了中文信息提示包，位于下载包的 dist/localization/messages_zh.js。123&lt;script src=\"lib/jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"lib/jquery.validate.js\"&gt;&lt;/script&gt;&lt;script src=\"lib/messages_zh.js\"&gt;&lt;/script&gt; 默认校验规则，可以使用 class 验证规则，也可以使用 Json 对象验证的规则，也可以使用高级验证方法，宝座 rules 和 message规则 描述required:true 必须输入的字段。remote:”check.php” 使用 ajax 方法调用 check.php 验证输入值。email:true 必须输入正确格式的电子邮件。url:true 必须输入正确格式的网址。date:true 必须输入正确格式的日期。日期校验 ie6 出错，慎用。dateISO:true 必须输入正确格式的日期（ISO），例如：2009-06-23，1998/01/22。只验证格式，不验证有效性。number:true 必须输入合法的数字（负数，小数）。digits:true 必须输入整数。creditcard: 必须输入合法的信用卡号。equalTo:”#field” 输入值必须和 #field 相同。accept: 输入拥有合法后缀名的字符串（上传文件的后缀）。maxlength:5 输入长度最多是 5 的字符串（汉字算一个字符）。minlength:10 输入长度最小是 10 的字符串（汉字算一个字符）。rangelength:[5,10] 输入长度必须介于 5 和 10 之间的字符串（汉字算一个字符）。range:[5,10] 输入值必须介于 5 和 10 之间。max:5 输入值不能大于 5。min:10 输入值不能小于 10。 初始化1234567891011$.validator.setDefaults(&#123; // 更改插件所有默认配置 submitHandler: function () &#123; alert('提交事件!'); &#125;,&#125;);$().ready(function () &#123; $('#commentForm').validate(&#123; debug: true, // 如果这个参数为true，那么表单不会提交，只进行检查，调试时十分方便。 &#125;);&#125;); 自定义规则，也就是高级验证方式。如果某个控件没有 message，将调用默认的信息12345678910111213141516171819202122232425262728293031323334$(document).ready(function () &#123; $('#myform').validate(&#123; rules: &#123; username: &#123; required: true, minlength: 2 &#125;, password: &#123; required: true, minlength: 6, maxlength: 16 &#125;, repassword: &#123; required: true, equalTo: '#password' &#125;, amt: &#123; required: true, isAmount: true &#125;, idcard: &#123; required: true, isIdCardNo: true &#125;, &#125;, messages: &#123; username: &#123; required: '用户名不能为空', minlength: '用户名的最小长度为2', &#125;, password: &#123; required: '密码不能为空', minlength: '密码长度不能少于6个字符', maxlength: '密码长度不能超过16个字符', &#125;, repassword: &#123; required: '确认密码不能为空', equalTo: '确认密码和密码不一致', &#125;, amt: &#123; required: '金额不能为空', isAmount: '交易金额必须大于0，且最多有两位小数', &#125;, idcard: &#123; required: '身份证不能为空', isIdCardNo: '身份证号码错误', &#125;, &#125;, &#125;);&#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;div&gt; &lt;form id=\"myform\" method=\"post\" action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;jquery-validate表单校验验证&lt;/legend&gt; &lt;div class=\"item\"&gt; &lt;label for=\"username\" class=\"item-label\"&gt;用户名:&lt;/label&gt; &lt;input type=\"text\" id=\"username\" name=\"username\" class=\"item-text\" placeholder=\"设置用户名\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;label for=\"password\" class=\"item-label\"&gt;密码:&lt;/label&gt; &lt;input type=\"password\" id=\"password\" name=\"password\" class=\"item-text\" placeholder=\"设置密码\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;label for=\"password\" class=\"item-label\"&gt;确认密码:&lt;/label&gt; &lt;input type=\"password\" name=\"repassword\" class=\"item-text\" placeholder=\"设置确认密码\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;label for=\"amt\" class=\"item-label\"&gt;金额:&lt;/label&gt; &lt;input type=\"text\" id=\"amt\" name=\"amt\" class=\"item-text\" placeholder=\"交易金额\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;label for=\"idcard\" class=\"item-label\"&gt;身份证号码:&lt;/label&gt; &lt;input type=\"text\" id=\"idcard\" name=\"idcard\" class=\"item-text\" placeholder=\"身份证号码\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;input type=\"submit\" value=\"提交\" class=\"item-submit\" /&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/form&gt;&lt;/div&gt; 自定义验证方法，参考格式：addMethod：name, method, message123456789101112131415161718192021222324// 中文字两个字节jQuery.validator.addMethod( 'byteRangeLength', function (value, element, param) &#123; var length = value.length; for (var i = 0; i &lt; value.length; i++) &#123; if (value.charCodeAt(i) &gt; 127) &#123; length++; &#125; &#125; return this.optional(element) || (length &gt;= param[0] &amp;&amp; length &lt;= param[1]); &#125;, $.validator.format('请确保输入的值在&#123;0&#125;-&#123;1&#125;个字节之间(一个中文字算2个字节)'));// 邮政编码验证jQuery.validator.addMethod( 'isZipCode', function (value, element) &#123; var tel = /^[0-9]&#123;6&#125;$/; return this.optional(element) || tel.test(value); &#125;, '请正确填写您的邮政编码'); 参考文献1、扩展 jquery.validate 自定义验证，自定义提示，本地化","tags":[{"name":"笔记","slug":"笔记","permalink":"https://liwenxin-jam.github.io/tags/笔记/"}]},{"title":"圣杯布局 & 双飞翼布局","date":"2017-03-26T09:33:48.000Z","path":"2017/03/26/圣杯布局 & 双飞翼布局/","text":"圣杯布局和双飞翼布局基本上是一致的，都是两边固定宽度，中间自适应的三栏布局，其中，中间栏放到文档流前面，保证先行渲染。解决方案大体相同，但在这里实现起来还是有一些区别的。它们都是三栏全部 float:left 浮动，区别在于解决中间栏 div 的内容不被遮挡上，圣杯布局是中间栏在添加相对定位，并配合 left 和 right 属性，效果上表现为三栏是单独分开的（如果可以看到空隙的话），而双飞翼布局是在中间栏的 div 中嵌套一个 div，内容写在嵌套的 div 里，然后对嵌套的 div 设置 margin-left 和 margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是 100%宽度，只不过中间栏的内容通过 margin 的值显示在中间。 圣杯布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; header &#123; width: 100%; height: 40px; background-color: darkseagreen; &#125; .container &#123; height: 200px; padding: 0 200px; overflow: hidden; &#125; .middle &#123; width: 100%; height: 200px; background-color: deeppink; float: left; &#125; .left &#123; position: relative; left: -200px; width: 200px; height: 200px; background-color: blue; float: left; margin-left: -100%; &#125; .right &#123; position: relative; right: -200px; width: 200px; height: 200px; background-color: darkorchid; float: left; margin-left: -200px; &#125; footer &#123; width: 100%; height: 30px; background-color: darkslategray; clear: both; /*记得清楚浮动*/ &#125;&lt;/style&gt;&lt;body&gt; &lt;header&gt;头部&lt;/header&gt; &lt;section class=\"container\"&gt; &lt;section class=\"middle\"&gt;中间&lt;/section&gt; &lt;aside class=\"left\"&gt;left&lt;/aside&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/section&gt; &lt;footer&gt;底部&lt;/footer&gt;&lt;/body&gt; 通过缩放页面就可以发现，随着页面的宽度的变化，这三栏布局是中间盒子优先渲染，两边的盒子框子固定不变，即使页面宽度变小，也不影响我们的浏览。为了保证窗口不能缩太小无法展示左右，可以给 body 加上 min-width。 双飞翼布局则是源于淘宝的 UED，可以说是灵感来自于页面渲染。如果把三栏布局比作一只大鸟，可以把 middle 看成是鸟的身体，left 和 right 则是鸟的翅膀。这个布局的实现思路是，先把最重要的身体部分放好，然后再将翅膀移动到适当的地方。相比圣杯布局，双飞翼不必设置左右栏的 position: relative，也不必设置左右 left、right 值，只需多添加一个子元素包含，相应的 padding 换成 margin。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; header &#123; width: 100%; height: 40px; background-color: darkseagreen; &#125; .container &#123; height: 200px; overflow: hidden; &#125; .middle &#123; width: 100%; height: 200px; background-color: deeppink; float: left; &#125; .mc &#123; margin-left: 200px; &#125; .left &#123; width: 200px; height: 200px; background-color: blue; float: left; margin-left: -100%; &#125; .right &#123; width: 200px; height: 200px; background-color: darkorchid; float: left; margin-left: -200px; &#125; footer &#123; width: 100%; height: 30px; background-color: darkslategray; clear: both; /*记得清楚浮动*/ &#125;&lt;/style&gt;&lt;body&gt; &lt;header&gt;头部&lt;/header&gt; &lt;section class=\"container\"&gt; &lt;section class=\"middle\"&gt; &lt;section class=\"mc\"&gt;中间&lt;/section&gt; &lt;/section&gt; &lt;aside class=\"left\"&gt;left&lt;/aside&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/section&gt; &lt;footer&gt;底部&lt;/footer&gt;&lt;/body&gt; 参考文献1、圣杯布局和双飞翼布局的理解和区别2、CSS 布局 – 圣杯布局 &amp; 双飞翼布局","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"text-align的justify小实践","date":"2017-02-13T14:12:52.000Z","path":"2017/02/13/text-align的justify小实践/","text":"多列均匀布局主要是利用了 text-align:justify，但 text-align:justify 不处理块内的最后一行文本（包括块内仅有一行文本的情况，这时既是第一行也是最后一行），也就是单行是不生效的，需要借助伪类 after 来实现多行，并将:after 设为 inline-block。 多列均匀布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style type=\"text/css\"&gt; .justify &#123; position: relative; width: 80%; height: 24px; text-align: justify; margin-bottom: 20px; border: 1px solid #000; &#125; i &#123; width: 24px; line-height: 24px; display: inline-block; text-align: center; background: #333; color: white; border-radius: 50%; overflow: hidden; font-style: normal; &#125; .justify:after &#123; content: ''; width: 100%; display: inline-block; position: relative; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"justify\"&gt; &lt;i&gt;1&lt;/i&gt; &lt;i&gt;2&lt;/i&gt; &lt;i&gt;3&lt;/i&gt; &lt;i&gt;4&lt;/i&gt; &lt;i&gt;5&lt;/i&gt; &lt;i&gt;6&lt;/i&gt; &lt;i&gt;7&lt;/i&gt; &lt;i&gt;8&lt;/i&gt; &lt;/div&gt; &lt;div class=\"justify\"&gt; &lt;i&gt;1&lt;/i&gt; &lt;i&gt;2&lt;/i&gt; &lt;i&gt;3&lt;/i&gt; &lt;/div&gt; &lt;div class=\"justify\"&gt; &lt;i&gt;1&lt;/i&gt; &lt;i&gt;2&lt;/i&gt; &lt;i&gt;3&lt;/i&gt; &lt;i&gt;4&lt;/i&gt; &lt;i&gt;5&lt;/i&gt; &lt;i&gt;6&lt;/i&gt; &lt;/div&gt;&lt;/body&gt; 利用这种原理同样可以处理表单元素文本长度不一致的情况，justify 可以使文本的两端都对齐。在两端对齐文本中，文本行的左右两端都放在父元素的内边界上，例如帐号/用户密码描述长度不一样。123456789101112131415161718192021222324252627&lt;style type=\"text/css\"&gt;span &#123; width: 100px; text-align: justify; float: left;&#125;span:after &#123; content: ''; width: 100%; display: inline-block; overflow: hidden; height: 0;&#125;input &#123; width: 100px;&#125;&lt;style&gt;&lt;body&gt; &lt;div class=\"demo\"&gt; &lt;span&gt;昵称&lt;/span&gt;： &lt;input type=\"text\" style='width: 100px'&gt; &lt;br&gt; &lt;br&gt; &lt;span&gt;电子邮箱&lt;/span&gt;： &lt;input type=\"email\" style='width: 100px;'&gt; &lt;/div&gt;&lt;/body&gt;","tags":[{"name":"前端","slug":"前端","permalink":"https://liwenxin-jam.github.io/tags/前端/"}]},{"title":"Dom与Jquery区别比较","date":"2017-01-07T12:48:13.000Z","path":"2017/01/07/Dom与Jquery区别比较/","text":"DOM 是文档对象模型（Document Object Model，简称 DOM），jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程。注意 dom 对象与 jquery 对象，如果需要详情了解可以参考 w3c 网址和 jQuery官网。 自定义 getElementsByClassName 方法123456789101112131415161718// 自定义getElementsByClassName方法function getElementsByClassName(node, className) &#123; if (node.getElementsByClassName) &#123; // 使用现有方法 getElementsByClassName只会获取父级下的所有子类符合条件的，而不是从当前级别开始查找 return node.getElementsByClassName(className); &#125; else &#123; var results = new Array(); var elems = document.getElementsByTagName('*'); for (var i = 0; i &lt; elems.length; i++) &#123; if (elems[i].className.indexOf(className) != -1) &#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125;var dom = document.getElementById('test');var selector = getElementsByClassName(dom, 'box'); window.onload 的处理机制与用法，以及与$(document).ready(function(){})的区别1234567891011121314151617181920212223242526272829303132// window.onload 网页加载完毕后会触发一个onload事件，每个事件处理函数只能绑定一条指定window.onload = firstFunc;window.onload = secondFunc; // 只会触发第二个// 解决方案一window.onload = function()&#123; firstFunc(); secondFunc();&#125; // 创建匿名函数容纳两个函数// 解决方案二function addLoadEvent(func)&#123; var oldOnLoad = window.onload; if(typeof oldOnLoad != \"function\")&#123; window.onload = func; &#125;else&#123; window.onload = function()&#123; oldOnLoad(); func(); &#125; &#125;&#125;function firstFunc()&#123; console.log('111111111');&#125;function secondFunc()&#123; console.log('222222222');&#125;addLoadEvent(firstFunc);addLoadEvent(secondFunc);// 效果类似window.onload，window.onload是必须等待网页中所有的内容加载完比后(包括图片)才能执行。document.ready是网页中所有DOM结构绘制完毕就执行，可能DOM元素所关联的东西并没有加载完(例如图片)。也就是说$(document).ready要比window.onload先执行。$(document).ready(function()&#123;&#125;）// 可以简写为 $(function()&#123;&#125;)，可以重复绑定多个初始化$(document).ready(function()&#123; console.log(\"Hello World!\"); $(this).addClass(\"highlight\").children(\"a\").show().end().siblings().removeClass(\"highlight\").children(\"a\").hide();&#125;); 节点属性和节点方法123456789&lt;style type=\"text/css\"&gt; .container &#123; font-size: 20px; &#125;&lt;/style&gt;&lt;div id=\"test\" class=\"container\" style=\"font-size: 30px;\"&gt; &lt;div id=\"box\" class=\"box\"&gt;&lt;/div&gt; &lt;p id=\"text\"&gt;text&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// nodeType 节点类型，1是标签节点 2属性节点 3是文本节点// nodeValue 节点值，主要是针对文本节点的值，类似jq的text// nodeName 节点名称，返回的字符串是全大写，例如 DIV/IMG等// childNodes 孩子节点数量，包括元素节点和文本节点// style.property 获取自身的样式，需要引用中间带一个减号的CSS属性，例如font-size需要转变成驼峰命名法fontSize。// style.property这种方式只能获取元素的行内样式，无法获取浏览器默认样式和它的ID选择器或者类选择器附带的样式// className 任何一个元素节点都有一个classNamevar dom = document.getElementById('test');dom.nodeName; // DIVvar text = document.getElementById('text');text.nodeType; // 1text.firstChild.nodeType; // 3text.firstChild.nodeValue; // textdom.childNodes; // 5dom.style.fontSize; // 30pxdom.className; // container// filter方法可以筛选过滤条件$('ul li:gt(5):not(:last)'); // 获得索引值大于5的，但不包含最后一个的所有li元素$('ul li') .filter(\":contains('苹果'),:contains('香蕉'),:contains('雪梨')\") .addClass('highlight');// 删除节点 remove()删除包括自身和后代所有元素 empty()只删除后代所有元素，不清空自身$('div').remove();$('div').empty();// 复制节点 clone(flag) flag为true代表绑定事件也复制，默认不复制$('#test').clone(true);// 替换节点 replaceWith和 replaceAll$('p').replaceWith('&lt;span&gt;test&lt;/span&gt;') == $('&lt;span&gt;test&lt;/span&gt;').replaceAll('p');// 包裹节点 wrap() 和 wrapAll() 前者是匹配的都重新包一层，后者是把所有匹配的只包最外一层(慎用，会改变dom结构)// wrapInner 匹配元素里面的把文本节点包一层$('span').wrap('&lt;strong&gt;&lt;/strong&gt;');$('span').wrapAll('&lt;strong&gt;&lt;/strong&gt;');$('span').wrapInner('&lt;strong&gt;&lt;/strong&gt;');// 切换样式，控制行为上的重复切换。如果是原来就显示则隐藏，否则相反。$('#test').toggle( function () &#123; //显示元素 &#125;, function () &#123; //隐藏元素 &#125;);// 样式重复切换，效果类似前者toggle切换$('#test').toggleClass('myClass');//判断是否有某个样式$('#test').hasClass('myClass');//判断元素是否显示，可以使用jq方式的is$('#panel box').bind('click', function () &#123; if ($(this).next('div.btn').is('visible')) &#123; // 如果已经显示就隐藏，do something &#125;&#125;); 创建元素节点和文本节点增加给某个父级12345678var container = document.getElementById('test');var dom = document.createElement('p');var text = document.createTextNode(\"This's my content\");dom.appendChild(text);container.appendChild(dom);parentElement.insertBefore(newElement, targetElement);var box = document.getElementById('box');box.parentNode.insertBefore(dom, box); Dom 原生 Ajax 请求12345678910111213141516171819202122232425function getHTTPObject() &#123; if (typeof XMLHttpRequest == 'undefined') &#123; XMLHttpRequest = new ActiveXObject('MSXML2.XMLHTTP'); // 兼容IE &#125; return new XMLHttpRequest();&#125;// 获取服务端数据function getContent() &#123; var request = getHTTPObject(); if (request) &#123; // 第一个参数是访问请求类型GET POST SEND, // 第二个参数是数据来源地址，一般指服务器接口 // 第三个参数代表是否异步方式发送和处理 request.open('GET', 'data.json', true); request.onreadystatechange = function () &#123; // readyState有5种值，0是未初始化 1是正在加载 2是加载完毕 3是正在交互 4是完成 if (request.readyState == 4) &#123; console.log(request.responseText); &#125; &#125;; request.send(null); &#125; else &#123; alert('Sorry, Error'); &#125;&#125; addClass 和 insertAfter 实现原理12345678910111213141516171819// 给元素增加样式function addClass(element, className) &#123; if (!element.className) &#123; element.className = className; &#125; else &#123; element.className += ' ' + className; &#125;&#125;addClass(document.getElementById('test'), 'addCustomerClass');// 默认没有insertAfter，可以借助nextSibling实现function insertAfter(newElement, targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement) &#123; parent.appendChild(newElement); &#125; else &#123; parent.insertBefore(newElement, targetElement.nextSibling); &#125;&#125; canvas 实践123&lt;canvas id=\"canvas\" width=\"120\" height=\"40\"&gt; &lt;p&gt;Power by Html5 Canvas&lt;/p&gt;&lt;/canvas&gt; 1234567891011121314151617181920212223242526// canvas原点(0,0)位于左上角，越往右x的值越大，右往下的y的越大function draw() &#123; var canvas = document.getElementById('canvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.moveTo(120.0, 32.0); // 从某起点开始画 // 三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。 ctx.bezierCurveTo(120.0, 36.4, 116.4, 40.0, 112.0, 40.0); // 绘制一条三次贝塞尔曲线 ctx.lineTo(8.0, 40.0); // 画一条线 ctx.bezierCurveTo(3.6, 40.0, 0.0, 36.4, 0.0, 32.0); ctx.lineTo(0.0, 8.0); ctx.bezierCurveTo(0.0, 3.6, 3.6, 0.0, 8.0, 0.0); ctx.lineTo(112.0, 0.0); ctx.bezierCurveTo(116.4, 0.0, 120.0, 3.6, 120.0, 8.0); ctx.lineTo(120.0, 32.0); ctx.closePath(); ctx.fillStyle = 'green'; // 填充颜色 ctx.fill(); ctx.lineWidth = 2.0; // 线宽度 ctx.strokeStyle = '#0000ff'; // 线颜色 // ctx.strokeStyle = \"rgb(255,255,255)\"; ctx.stroke(); &#125;&#125;window.onload = draw(); dom 方式与 Jquery 获取元素方式和判断对象是否为空1234567891011121314151617// dom方式与Jquery方式document.getElementById('test').innerHTML == $('#test').html();var text = document.getElementById('text');((text.firstChild.nodeValue == text.innerText) == text.textContent) == $('#text').text();// dom对象是否存在document.getElementById('xx').style.color = 'red'; //报错，打不到ID为xx的dom对象if (document.getElementById('xx')) &#123;&#125;// jq对象是否存在$('#xx').css('color', 'red'); // 不报错，找不到对象会忽略，jq方式访问永远会返回的是一个对象if ($('#xx')) &#123;&#125; // 不允许这样判断是否存在if ($('#xx').length &gt; 0) &#123;&#125; // 根据元素的长度去判断，推荐if ($('#xx')[0]) &#123;&#125; // dom对象方式去判断 dom 对象与 jq 对象互转1234567// dom与jq互转，jq对象只能用jq方法，dom对象只能用内置的dom方法，不能互窜$('#test'); // jq对象$('#test')[0]; // dom对象$('#test').get(0); // dom对象var dom = document.getElementById('test'); // dom对象$(dom); // jq对象 checkbox 是否选中判断方式1&lt;input type=\"checkbox\" id=\"ck\" checked=\"true\" /&gt;&lt;label for=\"ck\"&gt;同意&lt;/label&gt; 123456789var ck = document.getElementById('ck');if (ck.checked) &#123; // dom方式判断 console.log('checked');&#125;if ($(ck).is(':checked')) &#123; // jq方式判断 console.log('checked');&#125; dom 与 jquery 等价关系12345678910111213141516171819202122$('.one+div') == $('.one').next('div'); // 选择.one后下一个相邻的div标签$('#prev~div') == $('#prev').nextAll('div'); // 选择#prev后所有同级的div标签$('#prev').siblings('div'); // 选择#prev所有同级的div标签，无论前后位置// 创建元素节点document.createElement('li') == $('&lt;li&gt;&lt;/li&gt;');var li = document.createElement('li');document.getElementById('ul').appendChild(li) == $('ul').append('&lt;li&gt;&lt;/li&gt;');// 创建文本节点var dom = document.createElement('p');var text = document.createTextNode(\"This's my content\");dom.appendChild(text);// 等价于以下的jq方式$(\"&lt;p&gt;This's my content&lt;/p&gt;\");// 创建属性节点var dom = document.createElement('p');var title = dom.setAttribute('title', '标题');dom.appendChild(text);// 等价于以下的jq方式var p = $(\"&lt;p title='标题'&gt;&lt;/p&gt;\");$('body').append(p);// 注意append prepend是元素内部后置插入/前置插入，和appendTo prependTo是跟前面两个操作颠倒，例如是$(\"&lt;p&gt;This's my content&lt;/p&gt;\").appendTo('body');// after before是匹配元素后面插入/前面插入 和 insertAfter insertBefore是跟前面两个操作颠倒 jquery 过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 基本过滤选择器$('div:first'); // 选择所有div标签元素中的第一个div元素$('div:last'); // 选择所有div标签元素中的最后一个div元素$('div:not(.myClass)'); // 选择class类不包含myClass的所有div标签元素$('div:odd'); // 选择索引是奇数的所有div标签元素$('div:even'); // 选择索引是偶数的所有div标签元素$('div:eq(0)'); // index从0开始算起，有扩展是 :gt(index)大于index不包括自身 :lt(index)小于index不包括自身$(':header'); // 所有h标签元素$(':animated'); // 所有当前正在执行动画的所有元素// 内容过滤选择器$(\"div:contains('测试')\"); // 选取文本内容包含'测试'的元素$('div:empty'); // 选取不包含子元素或者文本的空元素$('div:has(p)'); // 选取含有p元素的div元素$('div:parent'); // 选取含有子元素或者文本的div元素// 可见性过滤选择器$(':hidden'); // 选取所有不可见的元素$('div:visible'); // 选取所有可见的div元素// 属性过滤选择器$('div[id]'); // 选取含有id属性的所有div元素$('div[title=test]'); // 选取含有title属性为test的所有div元素$('div[title!=test]'); // 选取title属性不等于test的所有div元素(注意没有title属性也会被选中)$('div[title=test]'); // 选取含有title属性为test的所有div元素$('div[title^=test]'); // 选取含有title属性以test开头的所有div元素$('div[title$=test]'); // 选取含有title属性以test结尾的所有div元素$('div[title*=test]'); // 选取含有title属性含有test的所有div元素$('div[id][title*=test]'); // 选取含有id属性并含有title属性为test的所有div元素// 子元素过滤选择器$('div:nth-child(3n+1)'); // :nth-child(index/odd/even) n从0开始算，index从1开始算起，区别eq(0)。可以选取奇偶数$('ul li:first-child'); // 选取每个ul中第一个li元素$('ul li:last-child'); // 选取每个ul中最后一个li元素$('ul li:only-child'); // 选取每个ul中只有唯一一个li元素// 表单对象属性选择器$('#form1:enabled'); // 选取id为form1的表单内所有可用元素$('#form1:disabled'); // 选取id为form1的表单内所有不可用元素$('input:checked'); // 选取所有被选中的input元素$('select:selected'); // 选取所有被选中的选项元素// 表单选择器$(':input'); // 选取所有input textarea select button元素$(':text'); // 选取所有单行文本框元素$(':password'); // 选取所有的密码框元素$(':radio'); // 选取所有的单选框元素$(':checkbox'); // 选取所有的复选框元素$(':submit'); // 选取所有的提交按钮$(':image'); // 选取所有的图像按钮$(':reset'); // 选取所有的重置按钮$(':button'); // 选取所有的button按钮$(':file'); // 选取所有的文件上传域$(':hidden'); // 选取所有不可见元素 jq 事件和鼠标移入移出效果实现1&lt;a href=\"\" class=\"tooltip\"&gt;测试鼠标悬浮移入移出功能&lt;/a&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$('input').focus(); // 获取焦点事件$('input').blur(); // 失去焦点事件$('div').children(); // 获取匹配的元素下的所有子元素，而不考虑后代元素和文本节点$('div').next(); // 获取匹配的元素后面相邻的同辈元素$('div').prev(); // 获取匹配的元素前面相邻的同辈元素$('div').siblings(); // 获取匹配的元素前后所有的同辈元素$('div').closest(); // 获取最近的匹配元素，首先判断当前元素是否匹配，不匹配就继续往父级查找，一直查找不到返回一个空对象// 此外还有find() filter() nextAll() prevAll() parent() parents()等等方法// 前者返回实际高度，不带单位，后者返回可能是样式，例如是auto$('#test').heigth() != $('#test').css('height');// 获取元素在当前视窗相对偏移量，返回对象包含两个属性，即top和left，它只对可见元素可效$('div').offset();// 获取元素相对于最近的一个祖父级样式设为relative或absolute的相对偏移量，返回对象跟offset()一样$('div').position();// scrollTop() scrollLeft() // 分别获取元素的滚动条距离顶端和左侧的距离，也可以设参数赋值// mouseover() mouseout() 鼠标移入移出效果，也可以用hover的方式实现 hover(enter,leave)// 方式一$('a.tooltip') .mouseover(function (e) &#123; var tooltip = \"&lt;div id='tooltip'&gt;我是弹出框提示&lt;/div&gt;\"; $('body').append(tooltip); $('#tooltip') .css(&#123; top: e.pageY + 'px', left: e.pageX + 'px', &#125;) .show('fast'); &#125;) .mouseout(function () &#123; $('#tooltip').remove(); &#125;) .mousemove(function (e) &#123; $('#tooltip').css(&#123; top: e.pageY + 'px', left: e.pageX + 'px', &#125;); &#125;);// 方式二$('a.tooltip').hover( function (e) &#123; var tooltip = \"&lt;div id='tooltip'&gt;我是弹出框提示&lt;/div&gt;\"; $('body').append(tooltip); $('#tooltip') .css(&#123; top: e.pageY + 'px', left: e.pageX + 'px', &#125;) .show('fast'); &#125;, function () &#123; $('#tooltip').remove(); &#125;); 事件绑定 12345678910111213141516171819202122232425262728// 事件绑定可以用bind和on，删除事件绑定用unbind$(\"#panel box\").bind(\"click\", function()&#123;&#125;) 等价于 $(\"#panel box\").on(\"click\", function()&#123;&#125;)$(\"#panel box\").bind(\"click\", function()&#123;&#125;) 等价于 $(\"#panel box\").click(function()&#123;&#125;)$(\"#panel box\").unbind(); // 不带任何参数，全部事件类型的绑定事件被删除$(\"#panel box\").unbind(\"click\"); // 只带事件类型参数，只会删除所有事件类型的绑定方法$(\"#panel box\").unbind(\"click\", funcName); // 只删除事件类型一致且方法一样的绑定方法// 一次性绑定多个事件类型，用空格隔开多个事件类型$(\"#panel box\").bind(\"mouseover mouseout\", function()&#123; $(this).toggleClass('over');&#125;)// 只想绑定事件触发一次用one，用法类似bind$(\"#panel box\").one(\"click\", function()&#123;&#125;)// 主动触发绑定事件可以用trigger$(\"input\").trigger(\"focus\") // 不仅会触发input上绑定的focus事件，也会使input获得焦点(默认行为)$(\"input\").triggerHandler(\"focus\") // 只会触发input上绑定的focus事件，不会获取焦点// 事件对象的属性$(\"a\").click(function(event)&#123; console.log(event.type); // 事件的类型，返回click event.preventDefault(); // 阻止事件的默认行为 event.stopPropagation(); // 阻止事件的向上(父级)冒泡行为 event.target; // 获取触发事件的元素本身对象 event.relatedTarget; // 属性的返回值是不确定的，这取决于触发事件的具体行为，返回的是相关元素 return false; // 阻止链接跳转&#125;); 自定义 animate 动画12345678910// fadeIn() fadeOut() //淡入淡出功能，参数是 fast/slow/normal/1000(毫秒)// fadeTo(speed, opacityVal) //eg:fadeTo(600, 0.2)// slideDown() slideUp() 当某个元素dispaly为none时候，slideDown从上到下延伸，参数跟fadeIn一样// slideToggle() 跟slideDown() slideUp()切换效果一致// 自定义animate(params, speed, callback)动画// 停止动画用stop(flag) 没指定参数时候只会停止当前正在执行的动画，如果flag为true，还会清空所有的动画队列$('#panel1').click(function () &#123; $(this).animate(&#123; left: '+=500px', height: '200px' &#125;, 300); // 两个距离同时发生 $(this).animate(&#123; left: '+=500px' &#125;, 300).animate(&#123; height: '200px' &#125;, 300); // 链式写法，一个接一个&#125;);","tags":[{"name":"笔记","slug":"笔记","permalink":"https://liwenxin-jam.github.io/tags/笔记/"}]}]